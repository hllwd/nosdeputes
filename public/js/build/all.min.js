!function (e, t) {
	"object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function (e) {
		if (!e.document)throw new Error("jQuery requires a window with a document");
		return t(e)
	} : t(e)
}("undefined" != typeof window ? window : this, function (e, t) {
	function n(e) {
		var t = e.length, n = J.type(e);
		return"function" === n || J.isWindow(e) ? !1 : 1 === e.nodeType && t ? !0 : "array" === n || 0 === t || "number" == typeof t && t > 0 && t - 1 in e
	}

	function r(e, t, n) {
		if (J.isFunction(t))return J.grep(e, function (e, r) {
			return!!t.call(e, r, e) !== n
		});
		if (t.nodeType)return J.grep(e, function (e) {
			return e === t !== n
		});
		if ("string" == typeof t) {
			if (st.test(t))return J.filter(t, e, n);
			t = J.filter(t, e)
		}
		return J.grep(e, function (e) {
			return X.call(t, e) >= 0 !== n
		})
	}

	function i(e, t) {
		for (; (e = e[t]) && 1 !== e.nodeType;);
		return e
	}

	function o(e) {
		var t = pt[e] = {};
		return J.each(e.match(dt) || [], function (e, n) {
			t[n] = !0
		}), t
	}

	function a() {
		Q.removeEventListener("DOMContentLoaded", a, !1), e.removeEventListener("load", a, !1), J.ready()
	}

	function s() {
		Object.defineProperty(this.cache = {}, 0, {get: function () {
			return{}
		}}), this.expando = J.expando + Math.random()
	}

	function l(e, t, n) {
		var r;
		if (void 0 === n && 1 === e.nodeType)if (r = "data-" + t.replace(Tt, "-$1").toLowerCase(), n = e.getAttribute(r), "string" == typeof n) {
			try {
				n = "true" === n ? !0 : "false" === n ? !1 : "null" === n ? null : +n + "" === n ? +n : yt.test(n) ? J.parseJSON(n) : n
			} catch (i) {
			}
			vt.set(e, t, n)
		} else n = void 0;
		return n
	}

	function u() {
		return!0
	}

	function c() {
		return!1
	}

	function h() {
		try {
			return Q.activeElement
		} catch (e) {
		}
	}

	function f(e, t) {
		return J.nodeName(e, "table") && J.nodeName(11 !== t.nodeType ? t : t.firstChild, "tr") ? e.getElementsByTagName("tbody")[0] || e.appendChild(e.ownerDocument.createElement("tbody")) : e
	}

	function d(e) {
		return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e
	}

	function p(e) {
		var t = Nt.exec(e.type);
		return t ? e.type = t[1] : e.removeAttribute("type"), e
	}

	function m(e, t) {
		for (var n = 0, r = e.length; r > n; n++)Et.set(e[n], "globalEval", !t || Et.get(t[n], "globalEval"))
	}

	function g(e, t) {
		var n, r, i, o, a, s, l, u;
		if (1 === t.nodeType) {
			if (Et.hasData(e) && (o = Et.access(e), a = Et.set(t, o), u = o.events)) {
				delete a.handle, a.events = {};
				for (i in u)for (n = 0, r = u[i].length; r > n; n++)J.event.add(t, i, u[i][n])
			}
			vt.hasData(e) && (s = vt.access(e), l = J.extend({}, s), vt.set(t, l))
		}
	}

	function E(e, t) {
		var n = e.getElementsByTagName ? e.getElementsByTagName(t || "*") : e.querySelectorAll ? e.querySelectorAll(t || "*") : [];
		return void 0 === t || t && J.nodeName(e, t) ? J.merge([e], n) : n
	}

	function v(e, t) {
		var n = t.nodeName.toLowerCase();
		"input" === n && _t.test(e.type) ? t.checked = e.checked : ("input" === n || "textarea" === n) && (t.defaultValue = e.defaultValue)
	}

	function y(t, n) {
		var r, i = J(n.createElement(t)).appendTo(n.body), o = e.getDefaultComputedStyle && (r = e.getDefaultComputedStyle(i[0])) ? r.display : J.css(i[0], "display");
		return i.detach(), o
	}

	function T(e) {
		var t = Q, n = Bt[e];
		return n || (n = y(e, t), "none" !== n && n || (Vt = (Vt || J("<iframe frameborder='0' width='0' height='0'/>")).appendTo(t.documentElement), t = Vt[0].contentDocument, t.write(), t.close(), n = y(e, t), Vt.detach()), Bt[e] = n), n
	}

	function x(e, t, n) {
		var r, i, o, a, s = e.style;
		return n = n || jt(e), n && (a = n.getPropertyValue(t) || n[t]), n && ("" !== a || J.contains(e.ownerDocument, e) || (a = J.style(e, t)), It.test(a) && Ot.test(t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0 !== a ? a + "" : a
	}

	function R(e, t) {
		return{get: function () {
			return e() ? void delete this.get : (this.get = t).apply(this, arguments)
		}}
	}

	function b(e, t) {
		if (t in e)return t;
		for (var n = t[0].toUpperCase() + t.slice(1), r = t, i = Kt.length; i--;)if (t = Kt[i] + n, t in e)return t;
		return r
	}

	function _(e, t, n) {
		var r = Gt.exec(t);
		return r ? Math.max(0, r[1] - (n || 0)) + (r[2] || "px") : t
	}

	function w(e, t, n, r, i) {
		for (var o = n === (r ? "border" : "content") ? 4 : "width" === t ? 1 : 0, a = 0; 4 > o; o += 2)"margin" === n && (a += J.css(e, n + Rt[o], !0, i)), r ? ("content" === n && (a -= J.css(e, "padding" + Rt[o], !0, i)), "margin" !== n && (a -= J.css(e, "border" + Rt[o] + "Width", !0, i))) : (a += J.css(e, "padding" + Rt[o], !0, i), "padding" !== n && (a += J.css(e, "border" + Rt[o] + "Width", !0, i)));
		return a
	}

	function H(e, t, n) {
		var r = !0, i = "width" === t ? e.offsetWidth : e.offsetHeight, o = jt(e), a = "border-box" === J.css(e, "boxSizing", !1, o);
		if (0 >= i || null == i) {
			if (i = x(e, t, o), (0 > i || null == i) && (i = e.style[t]), It.test(i))return i;
			r = a && (Z.boxSizingReliable() || i === e.style[t]), i = parseFloat(i) || 0
		}
		return i + w(e, t, n || (a ? "border" : "content"), r, o) + "px"
	}

	function M(e, t) {
		for (var n, r, i, o = [], a = 0, s = e.length; s > a; a++)r = e[a], r.style && (o[a] = Et.get(r, "olddisplay"), n = r.style.display, t ? (o[a] || "none" !== n || (r.style.display = ""), "" === r.style.display && bt(r) && (o[a] = Et.access(r, "olddisplay", T(r.nodeName)))) : (i = bt(r), "none" === n && i || Et.set(r, "olddisplay", i ? n : J.css(r, "display"))));
		for (a = 0; s > a; a++)r = e[a], r.style && (t && "none" !== r.style.display && "" !== r.style.display || (r.style.display = t ? o[a] || "" : "none"));
		return e
	}

	function S(e, t, n, r, i) {
		return new S.prototype.init(e, t, n, r, i)
	}

	function C() {
		return setTimeout(function () {
			Zt = void 0
		}), Zt = J.now()
	}

	function A(e, t) {
		var n, r = 0, i = {height: e};
		for (t = t ? 1 : 0; 4 > r; r += 2 - t)n = Rt[r], i["margin" + n] = i["padding" + n] = e;
		return t && (i.opacity = i.width = e), i
	}

	function L(e, t, n) {
		for (var r, i = (nn[t] || []).concat(nn["*"]), o = 0, a = i.length; a > o; o++)if (r = i[o].call(n, t, e))return r
	}

	function k(e, t, n) {
		var r, i, o, a, s, l, u, c, h = this, f = {}, d = e.style, p = e.nodeType && bt(e), m = Et.get(e, "fxshow");
		n.queue || (s = J._queueHooks(e, "fx"), null == s.unqueued && (s.unqueued = 0, l = s.empty.fire, s.empty.fire = function () {
			s.unqueued || l()
		}), s.unqueued++, h.always(function () {
			h.always(function () {
				s.unqueued--, J.queue(e, "fx").length || s.empty.fire()
			})
		})), 1 === e.nodeType && ("height"in t || "width"in t) && (n.overflow = [d.overflow, d.overflowX, d.overflowY], u = J.css(e, "display"), c = "none" === u ? Et.get(e, "olddisplay") || T(e.nodeName) : u, "inline" === c && "none" === J.css(e, "float") && (d.display = "inline-block")), n.overflow && (d.overflow = "hidden", h.always(function () {
			d.overflow = n.overflow[0], d.overflowX = n.overflow[1], d.overflowY = n.overflow[2]
		}));
		for (r in t)if (i = t[r], $t.exec(i)) {
			if (delete t[r], o = o || "toggle" === i, i === (p ? "hide" : "show")) {
				if ("show" !== i || !m || void 0 === m[r])continue;
				p = !0
			}
			f[r] = m && m[r] || J.style(e, r)
		} else u = void 0;
		if (J.isEmptyObject(f))"inline" === ("none" === u ? T(e.nodeName) : u) && (d.display = u); else {
			m ? "hidden"in m && (p = m.hidden) : m = Et.access(e, "fxshow", {}), o && (m.hidden = !p), p ? J(e).show() : h.done(function () {
				J(e).hide()
			}), h.done(function () {
				var t;
				Et.remove(e, "fxshow");
				for (t in f)J.style(e, t, f[t])
			});
			for (r in f)a = L(p ? m[r] : 0, r, h), r in m || (m[r] = a.start, p && (a.end = a.start, a.start = "width" === r || "height" === r ? 1 : 0))
		}
	}

	function P(e, t) {
		var n, r, i, o, a;
		for (n in e)if (r = J.camelCase(n), i = t[r], o = e[n], J.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), a = J.cssHooks[r], a && "expand"in a) {
			o = a.expand(o), delete e[r];
			for (n in o)n in e || (e[n] = o[n], t[n] = i)
		} else t[r] = i
	}

	function D(e, t, n) {
		var r, i, o = 0, a = tn.length, s = J.Deferred().always(function () {
			delete l.elem
		}), l = function () {
			if (i)return!1;
			for (var t = Zt || C(), n = Math.max(0, u.startTime + u.duration - t), r = n / u.duration || 0, o = 1 - r, a = 0, l = u.tweens.length; l > a; a++)u.tweens[a].run(o);
			return s.notifyWith(e, [u, o, n]), 1 > o && l ? n : (s.resolveWith(e, [u]), !1)
		}, u = s.promise({elem: e, props: J.extend({}, t), opts: J.extend(!0, {specialEasing: {}}, n), originalProperties: t, originalOptions: n, startTime: Zt || C(), duration: n.duration, tweens: [], createTween: function (t, n) {
			var r = J.Tween(e, u.opts, t, n, u.opts.specialEasing[t] || u.opts.easing);
			return u.tweens.push(r), r
		}, stop: function (t) {
			var n = 0, r = t ? u.tweens.length : 0;
			if (i)return this;
			for (i = !0; r > n; n++)u.tweens[n].run(1);
			return t ? s.resolveWith(e, [u, t]) : s.rejectWith(e, [u, t]), this
		}}), c = u.props;
		for (P(c, u.opts.specialEasing); a > o; o++)if (r = tn[o].call(u, e, c, u.opts))return r;
		return J.map(c, L, u), J.isFunction(u.opts.start) && u.opts.start.call(e, u), J.fx.timer(J.extend(l, {elem: e, anim: u, queue: u.opts.queue})), u.progress(u.opts.progress).done(u.opts.done, u.opts.complete).fail(u.opts.fail).always(u.opts.always)
	}

	function F(e) {
		return function (t, n) {
			"string" != typeof t && (n = t, t = "*");
			var r, i = 0, o = t.toLowerCase().match(dt) || [];
			if (J.isFunction(n))for (; r = o[i++];)"+" === r[0] ? (r = r.slice(1) || "*", (e[r] = e[r] || []).unshift(n)) : (e[r] = e[r] || []).push(n)
		}
	}

	function N(e, t, n, r) {
		function i(s) {
			var l;
			return o[s] = !0, J.each(e[s] || [], function (e, s) {
				var u = s(t, n, r);
				return"string" != typeof u || a || o[u] ? a ? !(l = u) : void 0 : (t.dataTypes.unshift(u), i(u), !1)
			}), l
		}

		var o = {}, a = e === Rn;
		return i(t.dataTypes[0]) || !o["*"] && i("*")
	}

	function z(e, t) {
		var n, r, i = J.ajaxSettings.flatOptions || {};
		for (n in t)void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]);
		return r && J.extend(!0, e, r), e
	}

	function U(e, t, n) {
		for (var r, i, o, a, s = e.contents, l = e.dataTypes; "*" === l[0];)l.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type"));
		if (r)for (i in s)if (s[i] && s[i].test(r)) {
			l.unshift(i);
			break
		}
		if (l[0]in n)o = l[0]; else {
			for (i in n) {
				if (!l[0] || e.converters[i + " " + l[0]]) {
					o = i;
					break
				}
				a || (a = i)
			}
			o = o || a
		}
		return o ? (o !== l[0] && l.unshift(o), n[o]) : void 0
	}

	function V(e, t, n, r) {
		var i, o, a, s, l, u = {}, c = e.dataTypes.slice();
		if (c[1])for (a in e.converters)u[a.toLowerCase()] = e.converters[a];
		for (o = c.shift(); o;)if (e.responseFields[o] && (n[e.responseFields[o]] = t), !l && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), l = o, o = c.shift())if ("*" === o)o = l; else if ("*" !== l && l !== o) {
			if (a = u[l + " " + o] || u["* " + o], !a)for (i in u)if (s = i.split(" "), s[1] === o && (a = u[l + " " + s[0]] || u["* " + s[0]])) {
				a === !0 ? a = u[i] : u[i] !== !0 && (o = s[0], c.unshift(s[1]));
				break
			}
			if (a !== !0)if (a && e["throws"])t = a(t); else try {
				t = a(t)
			} catch (h) {
				return{state: "parsererror", error: a ? h : "No conversion from " + l + " to " + o}
			}
		}
		return{state: "success", data: t}
	}

	function B(e, t, n, r) {
		var i;
		if (J.isArray(t))J.each(t, function (t, i) {
			n || Hn.test(e) ? r(e, i) : B(e + "[" + ("object" == typeof i ? t : "") + "]", i, n, r)
		}); else if (n || "object" !== J.type(t))r(e, t); else for (i in t)B(e + "[" + i + "]", t[i], n, r)
	}

	function O(e) {
		return J.isWindow(e) ? e : 9 === e.nodeType && e.defaultView
	}

	var I = [], j = I.slice, W = I.concat, G = I.push, X = I.indexOf, q = {}, Y = q.toString, K = q.hasOwnProperty, Z = {}, Q = e.document, $ = "2.1.1", J = function (e, t) {
		return new J.fn.init(e, t)
	}, et = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, tt = /^-ms-/, nt = /-([\da-z])/gi, rt = function (e, t) {
		return t.toUpperCase()
	};
	J.fn = J.prototype = {jquery: $, constructor: J, selector: "", length: 0, toArray: function () {
		return j.call(this)
	}, get: function (e) {
		return null != e ? 0 > e ? this[e + this.length] : this[e] : j.call(this)
	}, pushStack: function (e) {
		var t = J.merge(this.constructor(), e);
		return t.prevObject = this, t.context = this.context, t
	}, each: function (e, t) {
		return J.each(this, e, t)
	}, map: function (e) {
		return this.pushStack(J.map(this, function (t, n) {
			return e.call(t, n, t)
		}))
	}, slice: function () {
		return this.pushStack(j.apply(this, arguments))
	}, first: function () {
		return this.eq(0)
	}, last: function () {
		return this.eq(-1)
	}, eq: function (e) {
		var t = this.length, n = +e + (0 > e ? t : 0);
		return this.pushStack(n >= 0 && t > n ? [this[n]] : [])
	}, end: function () {
		return this.prevObject || this.constructor(null)
	}, push: G, sort: I.sort, splice: I.splice}, J.extend = J.fn.extend = function () {
		var e, t, n, r, i, o, a = arguments[0] || {}, s = 1, l = arguments.length, u = !1;
		for ("boolean" == typeof a && (u = a, a = arguments[s] || {}, s++), "object" == typeof a || J.isFunction(a) || (a = {}), s === l && (a = this, s--); l > s; s++)if (null != (e = arguments[s]))for (t in e)n = a[t], r = e[t], a !== r && (u && r && (J.isPlainObject(r) || (i = J.isArray(r))) ? (i ? (i = !1, o = n && J.isArray(n) ? n : []) : o = n && J.isPlainObject(n) ? n : {}, a[t] = J.extend(u, o, r)) : void 0 !== r && (a[t] = r));
		return a
	}, J.extend({expando: "jQuery" + ($ + Math.random()).replace(/\D/g, ""), isReady: !0, error: function (e) {
		throw new Error(e)
	}, noop: function () {
	}, isFunction: function (e) {
		return"function" === J.type(e)
	}, isArray: Array.isArray, isWindow: function (e) {
		return null != e && e === e.window
	}, isNumeric: function (e) {
		return!J.isArray(e) && e - parseFloat(e) >= 0
	}, isPlainObject: function (e) {
		return"object" !== J.type(e) || e.nodeType || J.isWindow(e) ? !1 : e.constructor && !K.call(e.constructor.prototype, "isPrototypeOf") ? !1 : !0
	}, isEmptyObject: function (e) {
		var t;
		for (t in e)return!1;
		return!0
	}, type: function (e) {
		return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? q[Y.call(e)] || "object" : typeof e
	}, globalEval: function (e) {
		var t, n = eval;
		e = J.trim(e), e && (1 === e.indexOf("use strict") ? (t = Q.createElement("script"), t.text = e, Q.head.appendChild(t).parentNode.removeChild(t)) : n(e))
	}, camelCase: function (e) {
		return e.replace(tt, "ms-").replace(nt, rt)
	}, nodeName: function (e, t) {
		return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
	}, each: function (e, t, r) {
		var i, o = 0, a = e.length, s = n(e);
		if (r) {
			if (s)for (; a > o && (i = t.apply(e[o], r), i !== !1); o++); else for (o in e)if (i = t.apply(e[o], r), i === !1)break
		} else if (s)for (; a > o && (i = t.call(e[o], o, e[o]), i !== !1); o++); else for (o in e)if (i = t.call(e[o], o, e[o]), i === !1)break;
		return e
	}, trim: function (e) {
		return null == e ? "" : (e + "").replace(et, "")
	}, makeArray: function (e, t) {
		var r = t || [];
		return null != e && (n(Object(e)) ? J.merge(r, "string" == typeof e ? [e] : e) : G.call(r, e)), r
	}, inArray: function (e, t, n) {
		return null == t ? -1 : X.call(t, e, n)
	}, merge: function (e, t) {
		for (var n = +t.length, r = 0, i = e.length; n > r; r++)e[i++] = t[r];
		return e.length = i, e
	}, grep: function (e, t, n) {
		for (var r, i = [], o = 0, a = e.length, s = !n; a > o; o++)r = !t(e[o], o), r !== s && i.push(e[o]);
		return i
	}, map: function (e, t, r) {
		var i, o = 0, a = e.length, s = n(e), l = [];
		if (s)for (; a > o; o++)i = t(e[o], o, r), null != i && l.push(i); else for (o in e)i = t(e[o], o, r), null != i && l.push(i);
		return W.apply([], l)
	}, guid: 1, proxy: function (e, t) {
		var n, r, i;
		return"string" == typeof t && (n = e[t], t = e, e = n), J.isFunction(e) ? (r = j.call(arguments, 2), i = function () {
			return e.apply(t || this, r.concat(j.call(arguments)))
		}, i.guid = e.guid = e.guid || J.guid++, i) : void 0
	}, now: Date.now, support: Z}), J.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (e, t) {
		q["[object " + t + "]"] = t.toLowerCase()
	});
	var it = function (e) {
		function t(e, t, n, r) {
			var i, o, a, s, l, u, h, d, p, m;
			if ((t ? t.ownerDocument || t : B) !== k && L(t), t = t || k, n = n || [], !e || "string" != typeof e)return n;
			if (1 !== (s = t.nodeType) && 9 !== s)return[];
			if (D && !r) {
				if (i = vt.exec(e))if (a = i[1]) {
					if (9 === s) {
						if (o = t.getElementById(a), !o || !o.parentNode)return n;
						if (o.id === a)return n.push(o), n
					} else if (t.ownerDocument && (o = t.ownerDocument.getElementById(a)) && U(t, o) && o.id === a)return n.push(o), n
				} else {
					if (i[2])return J.apply(n, t.getElementsByTagName(e)), n;
					if ((a = i[3]) && x.getElementsByClassName && t.getElementsByClassName)return J.apply(n, t.getElementsByClassName(a)), n
				}
				if (x.qsa && (!F || !F.test(e))) {
					if (d = h = V, p = t, m = 9 === s && e, 1 === s && "object" !== t.nodeName.toLowerCase()) {
						for (u = w(e), (h = t.getAttribute("id")) ? d = h.replace(Tt, "\\$&") : t.setAttribute("id", d), d = "[id='" + d + "'] ", l = u.length; l--;)u[l] = d + f(u[l]);
						p = yt.test(e) && c(t.parentNode) || t, m = u.join(",")
					}
					if (m)try {
						return J.apply(n, p.querySelectorAll(m)), n
					} catch (g) {
					} finally {
						h || t.removeAttribute("id")
					}
				}
			}
			return M(e.replace(lt, "$1"), t, n, r)
		}

		function n() {
			function e(n, r) {
				return t.push(n + " ") > R.cacheLength && delete e[t.shift()], e[n + " "] = r
			}

			var t = [];
			return e
		}

		function r(e) {
			return e[V] = !0, e
		}

		function i(e) {
			var t = k.createElement("div");
			try {
				return!!e(t)
			} catch (n) {
				return!1
			} finally {
				t.parentNode && t.parentNode.removeChild(t), t = null
			}
		}

		function o(e, t) {
			for (var n = e.split("|"), r = e.length; r--;)R.attrHandle[n[r]] = t
		}

		function a(e, t) {
			var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && (~t.sourceIndex || Y) - (~e.sourceIndex || Y);
			if (r)return r;
			if (n)for (; n = n.nextSibling;)if (n === t)return-1;
			return e ? 1 : -1
		}

		function s(e) {
			return function (t) {
				var n = t.nodeName.toLowerCase();
				return"input" === n && t.type === e
			}
		}

		function l(e) {
			return function (t) {
				var n = t.nodeName.toLowerCase();
				return("input" === n || "button" === n) && t.type === e
			}
		}

		function u(e) {
			return r(function (t) {
				return t = +t, r(function (n, r) {
					for (var i, o = e([], n.length, t), a = o.length; a--;)n[i = o[a]] && (n[i] = !(r[i] = n[i]))
				})
			})
		}

		function c(e) {
			return e && typeof e.getElementsByTagName !== q && e
		}

		function h() {
		}

		function f(e) {
			for (var t = 0, n = e.length, r = ""; n > t; t++)r += e[t].value;
			return r
		}

		function d(e, t, n) {
			var r = t.dir, i = n && "parentNode" === r, o = I++;
			return t.first ? function (t, n, o) {
				for (; t = t[r];)if (1 === t.nodeType || i)return e(t, n, o)
			} : function (t, n, a) {
				var s, l, u = [O, o];
				if (a) {
					for (; t = t[r];)if ((1 === t.nodeType || i) && e(t, n, a))return!0
				} else for (; t = t[r];)if (1 === t.nodeType || i) {
					if (l = t[V] || (t[V] = {}), (s = l[r]) && s[0] === O && s[1] === o)return u[2] = s[2];
					if (l[r] = u, u[2] = e(t, n, a))return!0
				}
			}
		}

		function p(e) {
			return e.length > 1 ? function (t, n, r) {
				for (var i = e.length; i--;)if (!e[i](t, n, r))return!1;
				return!0
			} : e[0]
		}

		function m(e, n, r) {
			for (var i = 0, o = n.length; o > i; i++)t(e, n[i], r);
			return r
		}

		function g(e, t, n, r, i) {
			for (var o, a = [], s = 0, l = e.length, u = null != t; l > s; s++)(o = e[s]) && (!n || n(o, r, i)) && (a.push(o), u && t.push(s));
			return a
		}

		function E(e, t, n, i, o, a) {
			return i && !i[V] && (i = E(i)), o && !o[V] && (o = E(o, a)), r(function (r, a, s, l) {
				var u, c, h, f = [], d = [], p = a.length, E = r || m(t || "*", s.nodeType ? [s] : s, []), v = !e || !r && t ? E : g(E, f, e, s, l), y = n ? o || (r ? e : p || i) ? [] : a : v;
				if (n && n(v, y, s, l), i)for (u = g(y, d), i(u, [], s, l), c = u.length; c--;)(h = u[c]) && (y[d[c]] = !(v[d[c]] = h));
				if (r) {
					if (o || e) {
						if (o) {
							for (u = [], c = y.length; c--;)(h = y[c]) && u.push(v[c] = h);
							o(null, y = [], u, l)
						}
						for (c = y.length; c--;)(h = y[c]) && (u = o ? tt.call(r, h) : f[c]) > -1 && (r[u] = !(a[u] = h))
					}
				} else y = g(y === a ? y.splice(p, y.length) : y), o ? o(null, a, y, l) : J.apply(a, y)
			})
		}

		function v(e) {
			for (var t, n, r, i = e.length, o = R.relative[e[0].type], a = o || R.relative[" "], s = o ? 1 : 0, l = d(function (e) {
				return e === t
			}, a, !0), u = d(function (e) {
				return tt.call(t, e) > -1
			}, a, !0), c = [function (e, n, r) {
				return!o && (r || n !== S) || ((t = n).nodeType ? l(e, n, r) : u(e, n, r))
			}]; i > s; s++)if (n = R.relative[e[s].type])c = [d(p(c), n)]; else {
				if (n = R.filter[e[s].type].apply(null, e[s].matches), n[V]) {
					for (r = ++s; i > r && !R.relative[e[r].type]; r++);
					return E(s > 1 && p(c), s > 1 && f(e.slice(0, s - 1).concat({value: " " === e[s - 2].type ? "*" : ""})).replace(lt, "$1"), n, r > s && v(e.slice(s, r)), i > r && v(e = e.slice(r)), i > r && f(e))
				}
				c.push(n)
			}
			return p(c)
		}

		function y(e, n) {
			var i = n.length > 0, o = e.length > 0, a = function (r, a, s, l, u) {
				var c, h, f, d = 0, p = "0", m = r && [], E = [], v = S, y = r || o && R.find.TAG("*", u), T = O += null == v ? 1 : Math.random() || .1, x = y.length;
				for (u && (S = a !== k && a); p !== x && null != (c = y[p]); p++) {
					if (o && c) {
						for (h = 0; f = e[h++];)if (f(c, a, s)) {
							l.push(c);
							break
						}
						u && (O = T)
					}
					i && ((c = !f && c) && d--, r && m.push(c))
				}
				if (d += p, i && p !== d) {
					for (h = 0; f = n[h++];)f(m, E, a, s);
					if (r) {
						if (d > 0)for (; p--;)m[p] || E[p] || (E[p] = Q.call(l));
						E = g(E)
					}
					J.apply(l, E), u && !r && E.length > 0 && d + n.length > 1 && t.uniqueSort(l)
				}
				return u && (O = T, S = v), m
			};
			return i ? r(a) : a
		}

		var T, x, R, b, _, w, H, M, S, C, A, L, k, P, D, F, N, z, U, V = "sizzle" + -new Date, B = e.document, O = 0, I = 0, j = n(), W = n(), G = n(), X = function (e, t) {
			return e === t && (A = !0), 0
		}, q = "undefined", Y = 1 << 31, K = {}.hasOwnProperty, Z = [], Q = Z.pop, $ = Z.push, J = Z.push, et = Z.slice, tt = Z.indexOf || function (e) {
			for (var t = 0, n = this.length; n > t; t++)if (this[t] === e)return t;
			return-1
		}, nt = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", rt = "[\\x20\\t\\r\\n\\f]", it = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", ot = it.replace("w", "w#"), at = "\\[" + rt + "*(" + it + ")(?:" + rt + "*([*^$|!~]?=)" + rt + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + ot + "))|)" + rt + "*\\]", st = ":(" + it + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + at + ")*)|.*)\\)|)", lt = new RegExp("^" + rt + "+|((?:^|[^\\\\])(?:\\\\.)*)" + rt + "+$", "g"), ut = new RegExp("^" + rt + "*," + rt + "*"), ct = new RegExp("^" + rt + "*([>+~]|" + rt + ")" + rt + "*"), ht = new RegExp("=" + rt + "*([^\\]'\"]*?)" + rt + "*\\]", "g"), ft = new RegExp(st), dt = new RegExp("^" + ot + "$"), pt = {ID: new RegExp("^#(" + it + ")"), CLASS: new RegExp("^\\.(" + it + ")"), TAG: new RegExp("^(" + it.replace("w", "w*") + ")"), ATTR: new RegExp("^" + at), PSEUDO: new RegExp("^" + st), CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + rt + "*(even|odd|(([+-]|)(\\d*)n|)" + rt + "*(?:([+-]|)" + rt + "*(\\d+)|))" + rt + "*\\)|)", "i"), bool: new RegExp("^(?:" + nt + ")$", "i"), needsContext: new RegExp("^" + rt + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + rt + "*((?:-\\d)?\\d*)" + rt + "*\\)|)(?=[^-]|$)", "i")}, mt = /^(?:input|select|textarea|button)$/i, gt = /^h\d$/i, Et = /^[^{]+\{\s*\[native \w/, vt = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, yt = /[+~]/, Tt = /'|\\/g, xt = new RegExp("\\\\([\\da-f]{1,6}" + rt + "?|(" + rt + ")|.)", "ig"), Rt = function (e, t, n) {
			var r = "0x" + t - 65536;
			return r !== r || n ? t : 0 > r ? String.fromCharCode(r + 65536) : String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320)
		};
		try {
			J.apply(Z = et.call(B.childNodes), B.childNodes), Z[B.childNodes.length].nodeType
		} catch (bt) {
			J = {apply: Z.length ? function (e, t) {
				$.apply(e, et.call(t))
			} : function (e, t) {
				for (var n = e.length, r = 0; e[n++] = t[r++];);
				e.length = n - 1
			}}
		}
		x = t.support = {}, _ = t.isXML = function (e) {
			var t = e && (e.ownerDocument || e).documentElement;
			return t ? "HTML" !== t.nodeName : !1
		}, L = t.setDocument = function (e) {
			var t, n = e ? e.ownerDocument || e : B, r = n.defaultView;
			return n !== k && 9 === n.nodeType && n.documentElement ? (k = n, P = n.documentElement, D = !_(n), r && r !== r.top && (r.addEventListener ? r.addEventListener("unload", function () {
				L()
			}, !1) : r.attachEvent && r.attachEvent("onunload", function () {
				L()
			})), x.attributes = i(function (e) {
				return e.className = "i", !e.getAttribute("className")
			}), x.getElementsByTagName = i(function (e) {
				return e.appendChild(n.createComment("")), !e.getElementsByTagName("*").length
			}), x.getElementsByClassName = Et.test(n.getElementsByClassName) && i(function (e) {
				return e.innerHTML = "<div class='a'></div><div class='a i'></div>", e.firstChild.className = "i", 2 === e.getElementsByClassName("i").length
			}), x.getById = i(function (e) {
				return P.appendChild(e).id = V, !n.getElementsByName || !n.getElementsByName(V).length
			}), x.getById ? (R.find.ID = function (e, t) {
				if (typeof t.getElementById !== q && D) {
					var n = t.getElementById(e);
					return n && n.parentNode ? [n] : []
				}
			}, R.filter.ID = function (e) {
				var t = e.replace(xt, Rt);
				return function (e) {
					return e.getAttribute("id") === t
				}
			}) : (delete R.find.ID, R.filter.ID = function (e) {
				var t = e.replace(xt, Rt);
				return function (e) {
					var n = typeof e.getAttributeNode !== q && e.getAttributeNode("id");
					return n && n.value === t
				}
			}), R.find.TAG = x.getElementsByTagName ? function (e, t) {
				return typeof t.getElementsByTagName !== q ? t.getElementsByTagName(e) : void 0
			} : function (e, t) {
				var n, r = [], i = 0, o = t.getElementsByTagName(e);
				if ("*" === e) {
					for (; n = o[i++];)1 === n.nodeType && r.push(n);
					return r
				}
				return o
			}, R.find.CLASS = x.getElementsByClassName && function (e, t) {
				return typeof t.getElementsByClassName !== q && D ? t.getElementsByClassName(e) : void 0
			}, N = [], F = [], (x.qsa = Et.test(n.querySelectorAll)) && (i(function (e) {
				e.innerHTML = "<select msallowclip=''><option selected=''></option></select>", e.querySelectorAll("[msallowclip^='']").length && F.push("[*^$]=" + rt + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || F.push("\\[" + rt + "*(?:value|" + nt + ")"), e.querySelectorAll(":checked").length || F.push(":checked")
			}), i(function (e) {
				var t = n.createElement("input");
				t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && F.push("name" + rt + "*[*^$|!~]?="), e.querySelectorAll(":enabled").length || F.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), F.push(",.*:")
			})), (x.matchesSelector = Et.test(z = P.matches || P.webkitMatchesSelector || P.mozMatchesSelector || P.oMatchesSelector || P.msMatchesSelector)) && i(function (e) {
				x.disconnectedMatch = z.call(e, "div"), z.call(e, "[s!='']:x"), N.push("!=", st)
			}), F = F.length && new RegExp(F.join("|")), N = N.length && new RegExp(N.join("|")), t = Et.test(P.compareDocumentPosition), U = t || Et.test(P.contains) ? function (e, t) {
				var n = 9 === e.nodeType ? e.documentElement : e, r = t && t.parentNode;
				return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)))
			} : function (e, t) {
				if (t)for (; t = t.parentNode;)if (t === e)return!0;
				return!1
			}, X = t ? function (e, t) {
				if (e === t)return A = !0, 0;
				var r = !e.compareDocumentPosition - !t.compareDocumentPosition;
				return r ? r : (r = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1, 1 & r || !x.sortDetached && t.compareDocumentPosition(e) === r ? e === n || e.ownerDocument === B && U(B, e) ? -1 : t === n || t.ownerDocument === B && U(B, t) ? 1 : C ? tt.call(C, e) - tt.call(C, t) : 0 : 4 & r ? -1 : 1)
			} : function (e, t) {
				if (e === t)return A = !0, 0;
				var r, i = 0, o = e.parentNode, s = t.parentNode, l = [e], u = [t];
				if (!o || !s)return e === n ? -1 : t === n ? 1 : o ? -1 : s ? 1 : C ? tt.call(C, e) - tt.call(C, t) : 0;
				if (o === s)return a(e, t);
				for (r = e; r = r.parentNode;)l.unshift(r);
				for (r = t; r = r.parentNode;)u.unshift(r);
				for (; l[i] === u[i];)i++;
				return i ? a(l[i], u[i]) : l[i] === B ? -1 : u[i] === B ? 1 : 0
			}, n) : k
		}, t.matches = function (e, n) {
			return t(e, null, null, n)
		}, t.matchesSelector = function (e, n) {
			if ((e.ownerDocument || e) !== k && L(e), n = n.replace(ht, "='$1']"), !(!x.matchesSelector || !D || N && N.test(n) || F && F.test(n)))try {
				var r = z.call(e, n);
				if (r || x.disconnectedMatch || e.document && 11 !== e.document.nodeType)return r
			} catch (i) {
			}
			return t(n, k, null, [e]).length > 0
		}, t.contains = function (e, t) {
			return(e.ownerDocument || e) !== k && L(e), U(e, t)
		}, t.attr = function (e, t) {
			(e.ownerDocument || e) !== k && L(e);
			var n = R.attrHandle[t.toLowerCase()], r = n && K.call(R.attrHandle, t.toLowerCase()) ? n(e, t, !D) : void 0;
			return void 0 !== r ? r : x.attributes || !D ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null
		}, t.error = function (e) {
			throw new Error("Syntax error, unrecognized expression: " + e)
		}, t.uniqueSort = function (e) {
			var t, n = [], r = 0, i = 0;
			if (A = !x.detectDuplicates, C = !x.sortStable && e.slice(0), e.sort(X), A) {
				for (; t = e[i++];)t === e[i] && (r = n.push(i));
				for (; r--;)e.splice(n[r], 1)
			}
			return C = null, e
		}, b = t.getText = function (e) {
			var t, n = "", r = 0, i = e.nodeType;
			if (i) {
				if (1 === i || 9 === i || 11 === i) {
					if ("string" == typeof e.textContent)return e.textContent;
					for (e = e.firstChild; e; e = e.nextSibling)n += b(e)
				} else if (3 === i || 4 === i)return e.nodeValue
			} else for (; t = e[r++];)n += b(t);
			return n
		}, R = t.selectors = {cacheLength: 50, createPseudo: r, match: pt, attrHandle: {}, find: {}, relative: {">": {dir: "parentNode", first: !0}, " ": {dir: "parentNode"}, "+": {dir: "previousSibling", first: !0}, "~": {dir: "previousSibling"}}, preFilter: {ATTR: function (e) {
			return e[1] = e[1].replace(xt, Rt), e[3] = (e[3] || e[4] || e[5] || "").replace(xt, Rt), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4)
		}, CHILD: function (e) {
			return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || t.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && t.error(e[0]), e
		}, PSEUDO: function (e) {
			var t, n = !e[6] && e[2];
			return pt.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && ft.test(n) && (t = w(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3))
		}}, filter: {TAG: function (e) {
			var t = e.replace(xt, Rt).toLowerCase();
			return"*" === e ? function () {
				return!0
			} : function (e) {
				return e.nodeName && e.nodeName.toLowerCase() === t
			}
		}, CLASS: function (e) {
			var t = j[e + " "];
			return t || (t = new RegExp("(^|" + rt + ")" + e + "(" + rt + "|$)")) && j(e, function (e) {
				return t.test("string" == typeof e.className && e.className || typeof e.getAttribute !== q && e.getAttribute("class") || "")
			})
		}, ATTR: function (e, n, r) {
			return function (i) {
				var o = t.attr(i, e);
				return null == o ? "!=" === n : n ? (o += "", "=" === n ? o === r : "!=" === n ? o !== r : "^=" === n ? r && 0 === o.indexOf(r) : "*=" === n ? r && o.indexOf(r) > -1 : "$=" === n ? r && o.slice(-r.length) === r : "~=" === n ? (" " + o + " ").indexOf(r) > -1 : "|=" === n ? o === r || o.slice(0, r.length + 1) === r + "-" : !1) : !0
			}
		}, CHILD: function (e, t, n, r, i) {
			var o = "nth" !== e.slice(0, 3), a = "last" !== e.slice(-4), s = "of-type" === t;
			return 1 === r && 0 === i ? function (e) {
				return!!e.parentNode
			} : function (t, n, l) {
				var u, c, h, f, d, p, m = o !== a ? "nextSibling" : "previousSibling", g = t.parentNode, E = s && t.nodeName.toLowerCase(), v = !l && !s;
				if (g) {
					if (o) {
						for (; m;) {
							for (h = t; h = h[m];)if (s ? h.nodeName.toLowerCase() === E : 1 === h.nodeType)return!1;
							p = m = "only" === e && !p && "nextSibling"
						}
						return!0
					}
					if (p = [a ? g.firstChild : g.lastChild], a && v) {
						for (c = g[V] || (g[V] = {}), u = c[e] || [], d = u[0] === O && u[1], f = u[0] === O && u[2], h = d && g.childNodes[d]; h = ++d && h && h[m] || (f = d = 0) || p.pop();)if (1 === h.nodeType && ++f && h === t) {
							c[e] = [O, d, f];
							break
						}
					} else if (v && (u = (t[V] || (t[V] = {}))[e]) && u[0] === O)f = u[1]; else for (; (h = ++d && h && h[m] || (f = d = 0) || p.pop()) && ((s ? h.nodeName.toLowerCase() !== E : 1 !== h.nodeType) || !++f || (v && ((h[V] || (h[V] = {}))[e] = [O, f]), h !== t)););
					return f -= i, f === r || f % r === 0 && f / r >= 0
				}
			}
		}, PSEUDO: function (e, n) {
			var i, o = R.pseudos[e] || R.setFilters[e.toLowerCase()] || t.error("unsupported pseudo: " + e);
			return o[V] ? o(n) : o.length > 1 ? (i = [e, e, "", n], R.setFilters.hasOwnProperty(e.toLowerCase()) ? r(function (e, t) {
				for (var r, i = o(e, n), a = i.length; a--;)r = tt.call(e, i[a]), e[r] = !(t[r] = i[a])
			}) : function (e) {
				return o(e, 0, i)
			}) : o
		}}, pseudos: {not: r(function (e) {
			var t = [], n = [], i = H(e.replace(lt, "$1"));
			return i[V] ? r(function (e, t, n, r) {
				for (var o, a = i(e, null, r, []), s = e.length; s--;)(o = a[s]) && (e[s] = !(t[s] = o))
			}) : function (e, r, o) {
				return t[0] = e, i(t, null, o, n), !n.pop()
			}
		}), has: r(function (e) {
			return function (n) {
				return t(e, n).length > 0
			}
		}), contains: r(function (e) {
			return function (t) {
				return(t.textContent || t.innerText || b(t)).indexOf(e) > -1
			}
		}), lang: r(function (e) {
			return dt.test(e || "") || t.error("unsupported lang: " + e), e = e.replace(xt, Rt).toLowerCase(), function (t) {
				var n;
				do if (n = D ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang"))return n = n.toLowerCase(), n === e || 0 === n.indexOf(e + "-"); while ((t = t.parentNode) && 1 === t.nodeType);
				return!1
			}
		}), target: function (t) {
			var n = e.location && e.location.hash;
			return n && n.slice(1) === t.id
		}, root: function (e) {
			return e === P
		}, focus: function (e) {
			return e === k.activeElement && (!k.hasFocus || k.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)
		}, enabled: function (e) {
			return e.disabled === !1
		}, disabled: function (e) {
			return e.disabled === !0
		}, checked: function (e) {
			var t = e.nodeName.toLowerCase();
			return"input" === t && !!e.checked || "option" === t && !!e.selected
		}, selected: function (e) {
			return e.parentNode && e.parentNode.selectedIndex, e.selected === !0
		}, empty: function (e) {
			for (e = e.firstChild; e; e = e.nextSibling)if (e.nodeType < 6)return!1;
			return!0
		}, parent: function (e) {
			return!R.pseudos.empty(e)
		}, header: function (e) {
			return gt.test(e.nodeName)
		}, input: function (e) {
			return mt.test(e.nodeName)
		}, button: function (e) {
			var t = e.nodeName.toLowerCase();
			return"input" === t && "button" === e.type || "button" === t
		}, text: function (e) {
			var t;
			return"input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase())
		}, first: u(function () {
			return[0]
		}), last: u(function (e, t) {
			return[t - 1]
		}), eq: u(function (e, t, n) {
			return[0 > n ? n + t : n]
		}), even: u(function (e, t) {
			for (var n = 0; t > n; n += 2)e.push(n);
			return e
		}), odd: u(function (e, t) {
			for (var n = 1; t > n; n += 2)e.push(n);
			return e
		}), lt: u(function (e, t, n) {
			for (var r = 0 > n ? n + t : n; --r >= 0;)e.push(r);
			return e
		}), gt: u(function (e, t, n) {
			for (var r = 0 > n ? n + t : n; ++r < t;)e.push(r);
			return e
		})}}, R.pseudos.nth = R.pseudos.eq;
		for (T in{radio: !0, checkbox: !0, file: !0, password: !0, image: !0})R.pseudos[T] = s(T);
		for (T in{submit: !0, reset: !0})R.pseudos[T] = l(T);
		return h.prototype = R.filters = R.pseudos, R.setFilters = new h, w = t.tokenize = function (e, n) {
			var r, i, o, a, s, l, u, c = W[e + " "];
			if (c)return n ? 0 : c.slice(0);
			for (s = e, l = [], u = R.preFilter; s;) {
				(!r || (i = ut.exec(s))) && (i && (s = s.slice(i[0].length) || s), l.push(o = [])), r = !1, (i = ct.exec(s)) && (r = i.shift(), o.push({value: r, type: i[0].replace(lt, " ")}), s = s.slice(r.length));
				for (a in R.filter)!(i = pt[a].exec(s)) || u[a] && !(i = u[a](i)) || (r = i.shift(), o.push({value: r, type: a, matches: i}), s = s.slice(r.length));
				if (!r)break
			}
			return n ? s.length : s ? t.error(e) : W(e, l).slice(0)
		}, H = t.compile = function (e, t) {
			var n, r = [], i = [], o = G[e + " "];
			if (!o) {
				for (t || (t = w(e)), n = t.length; n--;)o = v(t[n]), o[V] ? r.push(o) : i.push(o);
				o = G(e, y(i, r)), o.selector = e
			}
			return o
		}, M = t.select = function (e, t, n, r) {
			var i, o, a, s, l, u = "function" == typeof e && e, h = !r && w(e = u.selector || e);
			if (n = n || [], 1 === h.length) {
				if (o = h[0] = h[0].slice(0), o.length > 2 && "ID" === (a = o[0]).type && x.getById && 9 === t.nodeType && D && R.relative[o[1].type]) {
					if (t = (R.find.ID(a.matches[0].replace(xt, Rt), t) || [])[0], !t)return n;
					u && (t = t.parentNode), e = e.slice(o.shift().value.length)
				}
				for (i = pt.needsContext.test(e) ? 0 : o.length; i-- && (a = o[i], !R.relative[s = a.type]);)if ((l = R.find[s]) && (r = l(a.matches[0].replace(xt, Rt), yt.test(o[0].type) && c(t.parentNode) || t))) {
					if (o.splice(i, 1), e = r.length && f(o), !e)return J.apply(n, r), n;
					break
				}
			}
			return(u || H(e, h))(r, t, !D, n, yt.test(e) && c(t.parentNode) || t), n
		}, x.sortStable = V.split("").sort(X).join("") === V, x.detectDuplicates = !!A, L(), x.sortDetached = i(function (e) {
			return 1 & e.compareDocumentPosition(k.createElement("div"))
		}), i(function (e) {
			return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href")
		}) || o("type|href|height|width", function (e, t, n) {
			return n ? void 0 : e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2)
		}), x.attributes && i(function (e) {
			return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value")
		}) || o("value", function (e, t, n) {
			return n || "input" !== e.nodeName.toLowerCase() ? void 0 : e.defaultValue
		}), i(function (e) {
			return null == e.getAttribute("disabled")
		}) || o(nt, function (e, t, n) {
			var r;
			return n ? void 0 : e[t] === !0 ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null
		}), t
	}(e);
	J.find = it, J.expr = it.selectors, J.expr[":"] = J.expr.pseudos, J.unique = it.uniqueSort, J.text = it.getText, J.isXMLDoc = it.isXML, J.contains = it.contains;
	var ot = J.expr.match.needsContext, at = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, st = /^.[^:#\[\.,]*$/;
	J.filter = function (e, t, n) {
		var r = t[0];
		return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? J.find.matchesSelector(r, e) ? [r] : [] : J.find.matches(e, J.grep(t, function (e) {
			return 1 === e.nodeType
		}))
	}, J.fn.extend({find: function (e) {
		var t, n = this.length, r = [], i = this;
		if ("string" != typeof e)return this.pushStack(J(e).filter(function () {
			for (t = 0; n > t; t++)if (J.contains(i[t], this))return!0
		}));
		for (t = 0; n > t; t++)J.find(e, i[t], r);
		return r = this.pushStack(n > 1 ? J.unique(r) : r), r.selector = this.selector ? this.selector + " " + e : e, r
	}, filter: function (e) {
		return this.pushStack(r(this, e || [], !1))
	}, not: function (e) {
		return this.pushStack(r(this, e || [], !0))
	}, is: function (e) {
		return!!r(this, "string" == typeof e && ot.test(e) ? J(e) : e || [], !1).length
	}});
	var lt, ut = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, ct = J.fn.init = function (e, t) {
		var n, r;
		if (!e)return this;
		if ("string" == typeof e) {
			if (n = "<" === e[0] && ">" === e[e.length - 1] && e.length >= 3 ? [null, e, null] : ut.exec(e), !n || !n[1] && t)return!t || t.jquery ? (t || lt).find(e) : this.constructor(t).find(e);
			if (n[1]) {
				if (t = t instanceof J ? t[0] : t, J.merge(this, J.parseHTML(n[1], t && t.nodeType ? t.ownerDocument || t : Q, !0)), at.test(n[1]) && J.isPlainObject(t))for (n in t)J.isFunction(this[n]) ? this[n](t[n]) : this.attr(n, t[n]);
				return this
			}
			return r = Q.getElementById(n[2]), r && r.parentNode && (this.length = 1, this[0] = r), this.context = Q, this.selector = e, this
		}
		return e.nodeType ? (this.context = this[0] = e, this.length = 1, this) : J.isFunction(e) ? "undefined" != typeof lt.ready ? lt.ready(e) : e(J) : (void 0 !== e.selector && (this.selector = e.selector, this.context = e.context), J.makeArray(e, this))
	};
	ct.prototype = J.fn, lt = J(Q);
	var ht = /^(?:parents|prev(?:Until|All))/, ft = {children: !0, contents: !0, next: !0, prev: !0};
	J.extend({dir: function (e, t, n) {
		for (var r = [], i = void 0 !== n; (e = e[t]) && 9 !== e.nodeType;)if (1 === e.nodeType) {
			if (i && J(e).is(n))break;
			r.push(e)
		}
		return r
	}, sibling: function (e, t) {
		for (var n = []; e; e = e.nextSibling)1 === e.nodeType && e !== t && n.push(e);
		return n
	}}), J.fn.extend({has: function (e) {
		var t = J(e, this), n = t.length;
		return this.filter(function () {
			for (var e = 0; n > e; e++)if (J.contains(this, t[e]))return!0
		})
	}, closest: function (e, t) {
		for (var n, r = 0, i = this.length, o = [], a = ot.test(e) || "string" != typeof e ? J(e, t || this.context) : 0; i > r; r++)for (n = this[r]; n && n !== t; n = n.parentNode)if (n.nodeType < 11 && (a ? a.index(n) > -1 : 1 === n.nodeType && J.find.matchesSelector(n, e))) {
			o.push(n);
			break
		}
		return this.pushStack(o.length > 1 ? J.unique(o) : o)
	}, index: function (e) {
		return e ? "string" == typeof e ? X.call(J(e), this[0]) : X.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
	}, add: function (e, t) {
		return this.pushStack(J.unique(J.merge(this.get(), J(e, t))))
	}, addBack: function (e) {
		return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
	}}), J.each({parent: function (e) {
		var t = e.parentNode;
		return t && 11 !== t.nodeType ? t : null
	}, parents: function (e) {
		return J.dir(e, "parentNode")
	}, parentsUntil: function (e, t, n) {
		return J.dir(e, "parentNode", n)
	}, next: function (e) {
		return i(e, "nextSibling")
	}, prev: function (e) {
		return i(e, "previousSibling")
	}, nextAll: function (e) {
		return J.dir(e, "nextSibling")
	}, prevAll: function (e) {
		return J.dir(e, "previousSibling")
	}, nextUntil: function (e, t, n) {
		return J.dir(e, "nextSibling", n)
	}, prevUntil: function (e, t, n) {
		return J.dir(e, "previousSibling", n)
	}, siblings: function (e) {
		return J.sibling((e.parentNode || {}).firstChild, e)
	}, children: function (e) {
		return J.sibling(e.firstChild)
	}, contents: function (e) {
		return e.contentDocument || J.merge([], e.childNodes)
	}}, function (e, t) {
		J.fn[e] = function (n, r) {
			var i = J.map(this, t, n);
			return"Until" !== e.slice(-5) && (r = n), r && "string" == typeof r && (i = J.filter(r, i)), this.length > 1 && (ft[e] || J.unique(i), ht.test(e) && i.reverse()), this.pushStack(i)
		}
	});
	var dt = /\S+/g, pt = {};
	J.Callbacks = function (e) {
		e = "string" == typeof e ? pt[e] || o(e) : J.extend({}, e);
		var t, n, r, i, a, s, l = [], u = !e.once && [], c = function (o) {
			for (t = e.memory && o, n = !0, s = i || 0, i = 0, a = l.length, r = !0; l && a > s; s++)if (l[s].apply(o[0], o[1]) === !1 && e.stopOnFalse) {
				t = !1;
				break
			}
			r = !1, l && (u ? u.length && c(u.shift()) : t ? l = [] : h.disable())
		}, h = {add: function () {
			if (l) {
				var n = l.length;
				!function o(t) {
					J.each(t, function (t, n) {
						var r = J.type(n);
						"function" === r ? e.unique && h.has(n) || l.push(n) : n && n.length && "string" !== r && o(n)
					})
				}(arguments), r ? a = l.length : t && (i = n, c(t))
			}
			return this
		}, remove: function () {
			return l && J.each(arguments, function (e, t) {
				for (var n; (n = J.inArray(t, l, n)) > -1;)l.splice(n, 1), r && (a >= n && a--, s >= n && s--)
			}), this
		}, has: function (e) {
			return e ? J.inArray(e, l) > -1 : !(!l || !l.length)
		}, empty: function () {
			return l = [], a = 0, this
		}, disable: function () {
			return l = u = t = void 0, this
		}, disabled: function () {
			return!l
		}, lock: function () {
			return u = void 0, t || h.disable(), this
		}, locked: function () {
			return!u
		}, fireWith: function (e, t) {
			return!l || n && !u || (t = t || [], t = [e, t.slice ? t.slice() : t], r ? u.push(t) : c(t)), this
		}, fire: function () {
			return h.fireWith(this, arguments), this
		}, fired: function () {
			return!!n
		}};
		return h
	}, J.extend({Deferred: function (e) {
		var t = [
			["resolve", "done", J.Callbacks("once memory"), "resolved"],
			["reject", "fail", J.Callbacks("once memory"), "rejected"],
			["notify", "progress", J.Callbacks("memory")]
		], n = "pending", r = {state: function () {
			return n
		}, always: function () {
			return i.done(arguments).fail(arguments), this
		}, then: function () {
			var e = arguments;
			return J.Deferred(function (n) {
				J.each(t, function (t, o) {
					var a = J.isFunction(e[t]) && e[t];
					i[o[1]](function () {
						var e = a && a.apply(this, arguments);
						e && J.isFunction(e.promise) ? e.promise().done(n.resolve).fail(n.reject).progress(n.notify) : n[o[0] + "With"](this === r ? n.promise() : this, a ? [e] : arguments)
					})
				}), e = null
			}).promise()
		}, promise: function (e) {
			return null != e ? J.extend(e, r) : r
		}}, i = {};
		return r.pipe = r.then, J.each(t, function (e, o) {
			var a = o[2], s = o[3];
			r[o[1]] = a.add, s && a.add(function () {
				n = s
			}, t[1 ^ e][2].disable, t[2][2].lock), i[o[0]] = function () {
				return i[o[0] + "With"](this === i ? r : this, arguments), this
			}, i[o[0] + "With"] = a.fireWith
		}), r.promise(i), e && e.call(i, i), i
	}, when: function (e) {
		var t, n, r, i = 0, o = j.call(arguments), a = o.length, s = 1 !== a || e && J.isFunction(e.promise) ? a : 0, l = 1 === s ? e : J.Deferred(), u = function (e, n, r) {
			return function (i) {
				n[e] = this, r[e] = arguments.length > 1 ? j.call(arguments) : i, r === t ? l.notifyWith(n, r) : --s || l.resolveWith(n, r)
			}
		};
		if (a > 1)for (t = new Array(a), n = new Array(a), r = new Array(a); a > i; i++)o[i] && J.isFunction(o[i].promise) ? o[i].promise().done(u(i, r, o)).fail(l.reject).progress(u(i, n, t)) : --s;
		return s || l.resolveWith(r, o), l.promise()
	}});
	var mt;
	J.fn.ready = function (e) {
		return J.ready.promise().done(e), this
	}, J.extend({isReady: !1, readyWait: 1, holdReady: function (e) {
		e ? J.readyWait++ : J.ready(!0)
	}, ready: function (e) {
		(e === !0 ? --J.readyWait : J.isReady) || (J.isReady = !0, e !== !0 && --J.readyWait > 0 || (mt.resolveWith(Q, [J]), J.fn.triggerHandler && (J(Q).triggerHandler("ready"), J(Q).off("ready"))))
	}}), J.ready.promise = function (t) {
		return mt || (mt = J.Deferred(), "complete" === Q.readyState ? setTimeout(J.ready) : (Q.addEventListener("DOMContentLoaded", a, !1), e.addEventListener("load", a, !1))), mt.promise(t)
	}, J.ready.promise();
	var gt = J.access = function (e, t, n, r, i, o, a) {
		var s = 0, l = e.length, u = null == n;
		if ("object" === J.type(n)) {
			i = !0;
			for (s in n)J.access(e, t, s, n[s], !0, o, a)
		} else if (void 0 !== r && (i = !0, J.isFunction(r) || (a = !0), u && (a ? (t.call(e, r), t = null) : (u = t, t = function (e, t, n) {
			return u.call(J(e), n)
		})), t))for (; l > s; s++)t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n)));
		return i ? e : u ? t.call(e) : l ? t(e[0], n) : o
	};
	J.acceptData = function (e) {
		return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType
	}, s.uid = 1, s.accepts = J.acceptData, s.prototype = {key: function (e) {
		if (!s.accepts(e))return 0;
		var t = {}, n = e[this.expando];
		if (!n) {
			n = s.uid++;
			try {
				t[this.expando] = {value: n}, Object.defineProperties(e, t)
			} catch (r) {
				t[this.expando] = n, J.extend(e, t)
			}
		}
		return this.cache[n] || (this.cache[n] = {}), n
	}, set: function (e, t, n) {
		var r, i = this.key(e), o = this.cache[i];
		if ("string" == typeof t)o[t] = n; else if (J.isEmptyObject(o))J.extend(this.cache[i], t); else for (r in t)o[r] = t[r];
		return o
	}, get: function (e, t) {
		var n = this.cache[this.key(e)];
		return void 0 === t ? n : n[t]
	}, access: function (e, t, n) {
		var r;
		return void 0 === t || t && "string" == typeof t && void 0 === n ? (r = this.get(e, t), void 0 !== r ? r : this.get(e, J.camelCase(t))) : (this.set(e, t, n), void 0 !== n ? n : t)
	}, remove: function (e, t) {
		var n, r, i, o = this.key(e), a = this.cache[o];
		if (void 0 === t)this.cache[o] = {}; else {
			J.isArray(t) ? r = t.concat(t.map(J.camelCase)) : (i = J.camelCase(t), t in a ? r = [t, i] : (r = i, r = r in a ? [r] : r.match(dt) || [])), n = r.length;
			for (; n--;)delete a[r[n]]
		}
	}, hasData: function (e) {
		return!J.isEmptyObject(this.cache[e[this.expando]] || {})
	}, discard: function (e) {
		e[this.expando] && delete this.cache[e[this.expando]]
	}};
	var Et = new s, vt = new s, yt = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, Tt = /([A-Z])/g;
	J.extend({hasData: function (e) {
		return vt.hasData(e) || Et.hasData(e)
	}, data: function (e, t, n) {
		return vt.access(e, t, n)
	}, removeData: function (e, t) {
		vt.remove(e, t)
	}, _data: function (e, t, n) {
		return Et.access(e, t, n)
	}, _removeData: function (e, t) {
		Et.remove(e, t)
	}}), J.fn.extend({data: function (e, t) {
		var n, r, i, o = this[0], a = o && o.attributes;
		if (void 0 === e) {
			if (this.length && (i = vt.get(o), 1 === o.nodeType && !Et.get(o, "hasDataAttrs"))) {
				for (n = a.length; n--;)a[n] && (r = a[n].name, 0 === r.indexOf("data-") && (r = J.camelCase(r.slice(5)), l(o, r, i[r])));
				Et.set(o, "hasDataAttrs", !0)
			}
			return i
		}
		return"object" == typeof e ? this.each(function () {
			vt.set(this, e)
		}) : gt(this, function (t) {
			var n, r = J.camelCase(e);
			if (o && void 0 === t) {
				if (n = vt.get(o, e), void 0 !== n)return n;
				if (n = vt.get(o, r), void 0 !== n)return n;
				if (n = l(o, r, void 0), void 0 !== n)return n
			} else this.each(function () {
				var n = vt.get(this, r);
				vt.set(this, r, t), -1 !== e.indexOf("-") && void 0 !== n && vt.set(this, e, t)
			})
		}, null, t, arguments.length > 1, null, !0)
	}, removeData: function (e) {
		return this.each(function () {
			vt.remove(this, e)
		})
	}}), J.extend({queue: function (e, t, n) {
		var r;
		return e ? (t = (t || "fx") + "queue", r = Et.get(e, t), n && (!r || J.isArray(n) ? r = Et.access(e, t, J.makeArray(n)) : r.push(n)), r || []) : void 0
	}, dequeue: function (e, t) {
		t = t || "fx";
		var n = J.queue(e, t), r = n.length, i = n.shift(), o = J._queueHooks(e, t), a = function () {
			J.dequeue(e, t)
		};
		"inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, a, o)), !r && o && o.empty.fire()
	}, _queueHooks: function (e, t) {
		var n = t + "queueHooks";
		return Et.get(e, n) || Et.access(e, n, {empty: J.Callbacks("once memory").add(function () {
			Et.remove(e, [t + "queue", n])
		})})
	}}), J.fn.extend({queue: function (e, t) {
		var n = 2;
		return"string" != typeof e && (t = e, e = "fx", n--), arguments.length < n ? J.queue(this[0], e) : void 0 === t ? this : this.each(function () {
			var n = J.queue(this, e, t);
			J._queueHooks(this, e), "fx" === e && "inprogress" !== n[0] && J.dequeue(this, e)
		})
	}, dequeue: function (e) {
		return this.each(function () {
			J.dequeue(this, e)
		})
	}, clearQueue: function (e) {
		return this.queue(e || "fx", [])
	}, promise: function (e, t) {
		var n, r = 1, i = J.Deferred(), o = this, a = this.length, s = function () {
			--r || i.resolveWith(o, [o])
		};
		for ("string" != typeof e && (t = e, e = void 0), e = e || "fx"; a--;)n = Et.get(o[a], e + "queueHooks"), n && n.empty && (r++, n.empty.add(s));
		return s(), i.promise(t)
	}});
	var xt = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, Rt = ["Top", "Right", "Bottom", "Left"], bt = function (e, t) {
		return e = t || e, "none" === J.css(e, "display") || !J.contains(e.ownerDocument, e)
	}, _t = /^(?:checkbox|radio)$/i;
	!function () {
		var e = Q.createDocumentFragment(), t = e.appendChild(Q.createElement("div")), n = Q.createElement("input");
		n.setAttribute("type", "radio"), n.setAttribute("checked", "checked"), n.setAttribute("name", "t"), t.appendChild(n), Z.checkClone = t.cloneNode(!0).cloneNode(!0).lastChild.checked, t.innerHTML = "<textarea>x</textarea>", Z.noCloneChecked = !!t.cloneNode(!0).lastChild.defaultValue
	}();
	var wt = "undefined";
	Z.focusinBubbles = "onfocusin"in e;
	var Ht = /^key/, Mt = /^(?:mouse|pointer|contextmenu)|click/, St = /^(?:focusinfocus|focusoutblur)$/, Ct = /^([^.]*)(?:\.(.+)|)$/;
	J.event = {global: {}, add: function (e, t, n, r, i) {
		var o, a, s, l, u, c, h, f, d, p, m, g = Et.get(e);
		if (g)for (n.handler && (o = n, n = o.handler, i = o.selector), n.guid || (n.guid = J.guid++), (l = g.events) || (l = g.events = {}), (a = g.handle) || (a = g.handle = function (t) {
			return typeof J !== wt && J.event.triggered !== t.type ? J.event.dispatch.apply(e, arguments) : void 0
		}), t = (t || "").match(dt) || [""], u = t.length; u--;)s = Ct.exec(t[u]) || [], d = m = s[1], p = (s[2] || "").split(".").sort(), d && (h = J.event.special[d] || {}, d = (i ? h.delegateType : h.bindType) || d, h = J.event.special[d] || {}, c = J.extend({type: d, origType: m, data: r, handler: n, guid: n.guid, selector: i, needsContext: i && J.expr.match.needsContext.test(i), namespace: p.join(".")}, o), (f = l[d]) || (f = l[d] = [], f.delegateCount = 0, h.setup && h.setup.call(e, r, p, a) !== !1 || e.addEventListener && e.addEventListener(d, a, !1)), h.add && (h.add.call(e, c), c.handler.guid || (c.handler.guid = n.guid)), i ? f.splice(f.delegateCount++, 0, c) : f.push(c), J.event.global[d] = !0)
	}, remove: function (e, t, n, r, i) {
		var o, a, s, l, u, c, h, f, d, p, m, g = Et.hasData(e) && Et.get(e);
		if (g && (l = g.events)) {
			for (t = (t || "").match(dt) || [""], u = t.length; u--;)if (s = Ct.exec(t[u]) || [], d = m = s[1], p = (s[2] || "").split(".").sort(), d) {
				for (h = J.event.special[d] || {}, d = (r ? h.delegateType : h.bindType) || d, f = l[d] || [], s = s[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = f.length; o--;)c = f[o], !i && m !== c.origType || n && n.guid !== c.guid || s && !s.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (f.splice(o, 1), c.selector && f.delegateCount--, h.remove && h.remove.call(e, c));
				a && !f.length && (h.teardown && h.teardown.call(e, p, g.handle) !== !1 || J.removeEvent(e, d, g.handle), delete l[d])
			} else for (d in l)J.event.remove(e, d + t[u], n, r, !0);
			J.isEmptyObject(l) && (delete g.handle, Et.remove(e, "events"))
		}
	}, trigger: function (t, n, r, i) {
		var o, a, s, l, u, c, h, f = [r || Q], d = K.call(t, "type") ? t.type : t, p = K.call(t, "namespace") ? t.namespace.split(".") : [];
		if (a = s = r = r || Q, 3 !== r.nodeType && 8 !== r.nodeType && !St.test(d + J.event.triggered) && (d.indexOf(".") >= 0 && (p = d.split("."), d = p.shift(), p.sort()), u = d.indexOf(":") < 0 && "on" + d, t = t[J.expando] ? t : new J.Event(d, "object" == typeof t && t), t.isTrigger = i ? 2 : 3, t.namespace = p.join("."), t.namespace_re = t.namespace ? new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, t.result = void 0, t.target || (t.target = r), n = null == n ? [t] : J.makeArray(n, [t]), h = J.event.special[d] || {}, i || !h.trigger || h.trigger.apply(r, n) !== !1)) {
			if (!i && !h.noBubble && !J.isWindow(r)) {
				for (l = h.delegateType || d, St.test(l + d) || (a = a.parentNode); a; a = a.parentNode)f.push(a), s = a;
				s === (r.ownerDocument || Q) && f.push(s.defaultView || s.parentWindow || e)
			}
			for (o = 0; (a = f[o++]) && !t.isPropagationStopped();)t.type = o > 1 ? l : h.bindType || d, c = (Et.get(a, "events") || {})[t.type] && Et.get(a, "handle"), c && c.apply(a, n), c = u && a[u], c && c.apply && J.acceptData(a) && (t.result = c.apply(a, n), t.result === !1 && t.preventDefault());
			return t.type = d, i || t.isDefaultPrevented() || h._default && h._default.apply(f.pop(), n) !== !1 || !J.acceptData(r) || u && J.isFunction(r[d]) && !J.isWindow(r) && (s = r[u], s && (r[u] = null), J.event.triggered = d, r[d](), J.event.triggered = void 0, s && (r[u] = s)), t.result
		}
	}, dispatch: function (e) {
		e = J.event.fix(e);
		var t, n, r, i, o, a = [], s = j.call(arguments), l = (Et.get(this, "events") || {})[e.type] || [], u = J.event.special[e.type] || {};
		if (s[0] = e, e.delegateTarget = this, !u.preDispatch || u.preDispatch.call(this, e) !== !1) {
			for (a = J.event.handlers.call(this, e, l), t = 0; (i = a[t++]) && !e.isPropagationStopped();)for (e.currentTarget = i.elem, n = 0; (o = i.handlers[n++]) && !e.isImmediatePropagationStopped();)(!e.namespace_re || e.namespace_re.test(o.namespace)) && (e.handleObj = o, e.data = o.data, r = ((J.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, s), void 0 !== r && (e.result = r) === !1 && (e.preventDefault(), e.stopPropagation()));
			return u.postDispatch && u.postDispatch.call(this, e), e.result
		}
	}, handlers: function (e, t) {
		var n, r, i, o, a = [], s = t.delegateCount, l = e.target;
		if (s && l.nodeType && (!e.button || "click" !== e.type))for (; l !== this; l = l.parentNode || this)if (l.disabled !== !0 || "click" !== e.type) {
			for (r = [], n = 0; s > n; n++)o = t[n], i = o.selector + " ", void 0 === r[i] && (r[i] = o.needsContext ? J(i, this).index(l) >= 0 : J.find(i, this, null, [l]).length), r[i] && r.push(o);
			r.length && a.push({elem: l, handlers: r})
		}
		return s < t.length && a.push({elem: this, handlers: t.slice(s)}), a
	}, props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "), fixHooks: {}, keyHooks: {props: "char charCode key keyCode".split(" "), filter: function (e, t) {
		return null == e.which && (e.which = null != t.charCode ? t.charCode : t.keyCode), e
	}}, mouseHooks: {props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "), filter: function (e, t) {
		var n, r, i, o = t.button;
		return null == e.pageX && null != t.clientX && (n = e.target.ownerDocument || Q, r = n.documentElement, i = n.body, e.pageX = t.clientX + (r && r.scrollLeft || i && i.scrollLeft || 0) - (r && r.clientLeft || i && i.clientLeft || 0), e.pageY = t.clientY + (r && r.scrollTop || i && i.scrollTop || 0) - (r && r.clientTop || i && i.clientTop || 0)), e.which || void 0 === o || (e.which = 1 & o ? 1 : 2 & o ? 3 : 4 & o ? 2 : 0), e
	}}, fix: function (e) {
		if (e[J.expando])return e;
		var t, n, r, i = e.type, o = e, a = this.fixHooks[i];
		for (a || (this.fixHooks[i] = a = Mt.test(i) ? this.mouseHooks : Ht.test(i) ? this.keyHooks : {}), r = a.props ? this.props.concat(a.props) : this.props, e = new J.Event(o), t = r.length; t--;)n = r[t], e[n] = o[n];
		return e.target || (e.target = Q), 3 === e.target.nodeType && (e.target = e.target.parentNode), a.filter ? a.filter(e, o) : e
	}, special: {load: {noBubble: !0}, focus: {trigger: function () {
		return this !== h() && this.focus ? (this.focus(), !1) : void 0
	}, delegateType: "focusin"}, blur: {trigger: function () {
		return this === h() && this.blur ? (this.blur(), !1) : void 0
	}, delegateType: "focusout"}, click: {trigger: function () {
		return"checkbox" === this.type && this.click && J.nodeName(this, "input") ? (this.click(), !1) : void 0
	}, _default: function (e) {
		return J.nodeName(e.target, "a")
	}}, beforeunload: {postDispatch: function (e) {
		void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)
	}}}, simulate: function (e, t, n, r) {
		var i = J.extend(new J.Event, n, {type: e, isSimulated: !0, originalEvent: {}});
		r ? J.event.trigger(i, null, t) : J.event.dispatch.call(t, i), i.isDefaultPrevented() && n.preventDefault()
	}}, J.removeEvent = function (e, t, n) {
		e.removeEventListener && e.removeEventListener(t, n, !1)
	}, J.Event = function (e, t) {
		return this instanceof J.Event ? (e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && e.returnValue === !1 ? u : c) : this.type = e, t && J.extend(this, t), this.timeStamp = e && e.timeStamp || J.now(), void(this[J.expando] = !0)) : new J.Event(e, t)
	}, J.Event.prototype = {isDefaultPrevented: c, isPropagationStopped: c, isImmediatePropagationStopped: c, preventDefault: function () {
		var e = this.originalEvent;
		this.isDefaultPrevented = u, e && e.preventDefault && e.preventDefault()
	}, stopPropagation: function () {
		var e = this.originalEvent;
		this.isPropagationStopped = u, e && e.stopPropagation && e.stopPropagation()
	}, stopImmediatePropagation: function () {
		var e = this.originalEvent;
		this.isImmediatePropagationStopped = u, e && e.stopImmediatePropagation && e.stopImmediatePropagation(), this.stopPropagation()
	}}, J.each({mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout"}, function (e, t) {
		J.event.special[e] = {delegateType: t, bindType: t, handle: function (e) {
			var n, r = this, i = e.relatedTarget, o = e.handleObj;
			return(!i || i !== r && !J.contains(r, i)) && (e.type = o.origType, n = o.handler.apply(this, arguments), e.type = t), n
		}}
	}), Z.focusinBubbles || J.each({focus: "focusin", blur: "focusout"}, function (e, t) {
		var n = function (e) {
			J.event.simulate(t, e.target, J.event.fix(e), !0)
		};
		J.event.special[t] = {setup: function () {
			var r = this.ownerDocument || this, i = Et.access(r, t);
			i || r.addEventListener(e, n, !0), Et.access(r, t, (i || 0) + 1)
		}, teardown: function () {
			var r = this.ownerDocument || this, i = Et.access(r, t) - 1;
			i ? Et.access(r, t, i) : (r.removeEventListener(e, n, !0), Et.remove(r, t))
		}}
	}), J.fn.extend({on: function (e, t, n, r, i) {
		var o, a;
		if ("object" == typeof e) {
			"string" != typeof t && (n = n || t, t = void 0);
			for (a in e)this.on(a, t, n, e[a], i);
			return this
		}
		if (null == n && null == r ? (r = t, n = t = void 0) : null == r && ("string" == typeof t ? (r = n, n = void 0) : (r = n, n = t, t = void 0)), r === !1)r = c; else if (!r)return this;
		return 1 === i && (o = r, r = function (e) {
			return J().off(e), o.apply(this, arguments)
		}, r.guid = o.guid || (o.guid = J.guid++)), this.each(function () {
			J.event.add(this, e, r, n, t)
		})
	}, one: function (e, t, n, r) {
		return this.on(e, t, n, r, 1)
	}, off: function (e, t, n) {
		var r, i;
		if (e && e.preventDefault && e.handleObj)return r = e.handleObj, J(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this;
		if ("object" == typeof e) {
			for (i in e)this.off(i, t, e[i]);
			return this
		}
		return(t === !1 || "function" == typeof t) && (n = t, t = void 0), n === !1 && (n = c), this.each(function () {
			J.event.remove(this, e, n, t)
		})
	}, trigger: function (e, t) {
		return this.each(function () {
			J.event.trigger(e, t, this)
		})
	}, triggerHandler: function (e, t) {
		var n = this[0];
		return n ? J.event.trigger(e, t, n, !0) : void 0
	}});
	var At = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, Lt = /<([\w:]+)/, kt = /<|&#?\w+;/, Pt = /<(?:script|style|link)/i, Dt = /checked\s*(?:[^=]|=\s*.checked.)/i, Ft = /^$|\/(?:java|ecma)script/i, Nt = /^true\/(.*)/, zt = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, Ut = {option: [1, "<select multiple='multiple'>", "</select>"], thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""]};
	Ut.optgroup = Ut.option, Ut.tbody = Ut.tfoot = Ut.colgroup = Ut.caption = Ut.thead, Ut.th = Ut.td, J.extend({clone: function (e, t, n) {
		var r, i, o, a, s = e.cloneNode(!0), l = J.contains(e.ownerDocument, e);
		if (!(Z.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || J.isXMLDoc(e)))for (a = E(s), o = E(e), r = 0, i = o.length; i > r; r++)v(o[r], a[r]);
		if (t)if (n)for (o = o || E(e), a = a || E(s), r = 0, i = o.length; i > r; r++)g(o[r], a[r]); else g(e, s);
		return a = E(s, "script"), a.length > 0 && m(a, !l && E(e, "script")), s
	}, buildFragment: function (e, t, n, r) {
		for (var i, o, a, s, l, u, c = t.createDocumentFragment(), h = [], f = 0, d = e.length; d > f; f++)if (i = e[f], i || 0 === i)if ("object" === J.type(i))J.merge(h, i.nodeType ? [i] : i); else if (kt.test(i)) {
			for (o = o || c.appendChild(t.createElement("div")), a = (Lt.exec(i) || ["", ""])[1].toLowerCase(), s = Ut[a] || Ut._default, o.innerHTML = s[1] + i.replace(At, "<$1></$2>") + s[2], u = s[0]; u--;)o = o.lastChild;
			J.merge(h, o.childNodes), o = c.firstChild, o.textContent = ""
		} else h.push(t.createTextNode(i));
		for (c.textContent = "", f = 0; i = h[f++];)if ((!r || -1 === J.inArray(i, r)) && (l = J.contains(i.ownerDocument, i), o = E(c.appendChild(i), "script"), l && m(o), n))for (u = 0; i = o[u++];)Ft.test(i.type || "") && n.push(i);
		return c
	}, cleanData: function (e) {
		for (var t, n, r, i, o = J.event.special, a = 0; void 0 !== (n = e[a]); a++) {
			if (J.acceptData(n) && (i = n[Et.expando], i && (t = Et.cache[i]))) {
				if (t.events)for (r in t.events)o[r] ? J.event.remove(n, r) : J.removeEvent(n, r, t.handle);
				Et.cache[i] && delete Et.cache[i]
			}
			delete vt.cache[n[vt.expando]]
		}
	}}), J.fn.extend({text: function (e) {
		return gt(this, function (e) {
			return void 0 === e ? J.text(this) : this.empty().each(function () {
				(1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && (this.textContent = e)
			})
		}, null, e, arguments.length)
	}, append: function () {
		return this.domManip(arguments, function (e) {
			if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
				var t = f(this, e);
				t.appendChild(e)
			}
		})
	}, prepend: function () {
		return this.domManip(arguments, function (e) {
			if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
				var t = f(this, e);
				t.insertBefore(e, t.firstChild)
			}
		})
	}, before: function () {
		return this.domManip(arguments, function (e) {
			this.parentNode && this.parentNode.insertBefore(e, this)
		})
	}, after: function () {
		return this.domManip(arguments, function (e) {
			this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
		})
	}, remove: function (e, t) {
		for (var n, r = e ? J.filter(e, this) : this, i = 0; null != (n = r[i]); i++)t || 1 !== n.nodeType || J.cleanData(E(n)), n.parentNode && (t && J.contains(n.ownerDocument, n) && m(E(n, "script")), n.parentNode.removeChild(n));
		return this
	}, empty: function () {
		for (var e, t = 0; null != (e = this[t]); t++)1 === e.nodeType && (J.cleanData(E(e, !1)), e.textContent = "");
		return this
	}, clone: function (e, t) {
		return e = null == e ? !1 : e, t = null == t ? e : t, this.map(function () {
			return J.clone(this, e, t)
		})
	}, html: function (e) {
		return gt(this, function (e) {
			var t = this[0] || {}, n = 0, r = this.length;
			if (void 0 === e && 1 === t.nodeType)return t.innerHTML;
			if ("string" == typeof e && !Pt.test(e) && !Ut[(Lt.exec(e) || ["", ""])[1].toLowerCase()]) {
				e = e.replace(At, "<$1></$2>");
				try {
					for (; r > n; n++)t = this[n] || {}, 1 === t.nodeType && (J.cleanData(E(t, !1)), t.innerHTML = e);
					t = 0
				} catch (i) {
				}
			}
			t && this.empty().append(e)
		}, null, e, arguments.length)
	}, replaceWith: function () {
		var e = arguments[0];
		return this.domManip(arguments, function (t) {
			e = this.parentNode, J.cleanData(E(this)), e && e.replaceChild(t, this)
		}), e && (e.length || e.nodeType) ? this : this.remove()
	}, detach: function (e) {
		return this.remove(e, !0)
	}, domManip: function (e, t) {
		e = W.apply([], e);
		var n, r, i, o, a, s, l = 0, u = this.length, c = this, h = u - 1, f = e[0], m = J.isFunction(f);
		if (m || u > 1 && "string" == typeof f && !Z.checkClone && Dt.test(f))return this.each(function (n) {
			var r = c.eq(n);
			m && (e[0] = f.call(this, n, r.html())), r.domManip(e, t)
		});
		if (u && (n = J.buildFragment(e, this[0].ownerDocument, !1, this), r = n.firstChild, 1 === n.childNodes.length && (n = r), r)) {
			for (i = J.map(E(n, "script"), d), o = i.length; u > l; l++)a = n, l !== h && (a = J.clone(a, !0, !0), o && J.merge(i, E(a, "script"))), t.call(this[l], a, l);
			if (o)for (s = i[i.length - 1].ownerDocument, J.map(i, p), l = 0; o > l; l++)a = i[l], Ft.test(a.type || "") && !Et.access(a, "globalEval") && J.contains(s, a) && (a.src ? J._evalUrl && J._evalUrl(a.src) : J.globalEval(a.textContent.replace(zt, "")))
		}
		return this
	}}), J.each({appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith"}, function (e, t) {
		J.fn[e] = function (e) {
			for (var n, r = [], i = J(e), o = i.length - 1, a = 0; o >= a; a++)n = a === o ? this : this.clone(!0), J(i[a])[t](n), G.apply(r, n.get());
			return this.pushStack(r)
		}
	});
	var Vt, Bt = {}, Ot = /^margin/, It = new RegExp("^(" + xt + ")(?!px)[a-z%]+$", "i"), jt = function (e) {
		return e.ownerDocument.defaultView.getComputedStyle(e, null)
	};
	!function () {
		function t() {
			a.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute", a.innerHTML = "", i.appendChild(o);
			var t = e.getComputedStyle(a, null);
			n = "1%" !== t.top, r = "4px" === t.width, i.removeChild(o)
		}

		var n, r, i = Q.documentElement, o = Q.createElement("div"), a = Q.createElement("div");
		a.style && (a.style.backgroundClip = "content-box", a.cloneNode(!0).style.backgroundClip = "", Z.clearCloneStyle = "content-box" === a.style.backgroundClip, o.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute", o.appendChild(a), e.getComputedStyle && J.extend(Z, {pixelPosition: function () {
			return t(), n
		}, boxSizingReliable: function () {
			return null == r && t(), r
		}, reliableMarginRight: function () {
			var t, n = a.appendChild(Q.createElement("div"));
			return n.style.cssText = a.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", n.style.marginRight = n.style.width = "0", a.style.width = "1px", i.appendChild(o), t = !parseFloat(e.getComputedStyle(n, null).marginRight), i.removeChild(o), t
		}}))
	}(), J.swap = function (e, t, n, r) {
		var i, o, a = {};
		for (o in t)a[o] = e.style[o], e.style[o] = t[o];
		i = n.apply(e, r || []);
		for (o in t)e.style[o] = a[o];
		return i
	};
	var Wt = /^(none|table(?!-c[ea]).+)/, Gt = new RegExp("^(" + xt + ")(.*)$", "i"), Xt = new RegExp("^([+-])=(" + xt + ")", "i"), qt = {position: "absolute", visibility: "hidden", display: "block"}, Yt = {letterSpacing: "0", fontWeight: "400"}, Kt = ["Webkit", "O", "Moz", "ms"];
	J.extend({cssHooks: {opacity: {get: function (e, t) {
		if (t) {
			var n = x(e, "opacity");
			return"" === n ? "1" : n
		}
	}}}, cssNumber: {columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0}, cssProps: {"float": "cssFloat"}, style: function (e, t, n, r) {
		if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
			var i, o, a, s = J.camelCase(t), l = e.style;
			return t = J.cssProps[s] || (J.cssProps[s] = b(l, s)), a = J.cssHooks[t] || J.cssHooks[s], void 0 === n ? a && "get"in a && void 0 !== (i = a.get(e, !1, r)) ? i : l[t] : (o = typeof n, "string" === o && (i = Xt.exec(n)) && (n = (i[1] + 1) * i[2] + parseFloat(J.css(e, t)), o = "number"), void(null != n && n === n && ("number" !== o || J.cssNumber[s] || (n += "px"), Z.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"), a && "set"in a && void 0 === (n = a.set(e, n, r)) || (l[t] = n))))
		}
	}, css: function (e, t, n, r) {
		var i, o, a, s = J.camelCase(t);
		return t = J.cssProps[s] || (J.cssProps[s] = b(e.style, s)), a = J.cssHooks[t] || J.cssHooks[s], a && "get"in a && (i = a.get(e, !0, n)), void 0 === i && (i = x(e, t, r)), "normal" === i && t in Yt && (i = Yt[t]), "" === n || n ? (o = parseFloat(i), n === !0 || J.isNumeric(o) ? o || 0 : i) : i
	}}), J.each(["height", "width"], function (e, t) {
		J.cssHooks[t] = {get: function (e, n, r) {
			return n ? Wt.test(J.css(e, "display")) && 0 === e.offsetWidth ? J.swap(e, qt, function () {
				return H(e, t, r)
			}) : H(e, t, r) : void 0
		}, set: function (e, n, r) {
			var i = r && jt(e);
			return _(e, n, r ? w(e, t, r, "border-box" === J.css(e, "boxSizing", !1, i), i) : 0)
		}}
	}), J.cssHooks.marginRight = R(Z.reliableMarginRight, function (e, t) {
		return t ? J.swap(e, {display: "inline-block"}, x, [e, "marginRight"]) : void 0
	}), J.each({margin: "", padding: "", border: "Width"}, function (e, t) {
		J.cssHooks[e + t] = {expand: function (n) {
			for (var r = 0, i = {}, o = "string" == typeof n ? n.split(" ") : [n]; 4 > r; r++)i[e + Rt[r] + t] = o[r] || o[r - 2] || o[0];
			return i
		}}, Ot.test(e) || (J.cssHooks[e + t].set = _)
	}), J.fn.extend({css: function (e, t) {
		return gt(this, function (e, t, n) {
			var r, i, o = {}, a = 0;
			if (J.isArray(t)) {
				for (r = jt(e), i = t.length; i > a; a++)o[t[a]] = J.css(e, t[a], !1, r);
				return o
			}
			return void 0 !== n ? J.style(e, t, n) : J.css(e, t)
		}, e, t, arguments.length > 1)
	}, show: function () {
		return M(this, !0)
	}, hide: function () {
		return M(this)
	}, toggle: function (e) {
		return"boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function () {
			bt(this) ? J(this).show() : J(this).hide()
		})
	}}), J.Tween = S, S.prototype = {constructor: S, init: function (e, t, n, r, i, o) {
		this.elem = e, this.prop = n, this.easing = i || "swing", this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (J.cssNumber[n] ? "" : "px")
	}, cur: function () {
		var e = S.propHooks[this.prop];
		return e && e.get ? e.get(this) : S.propHooks._default.get(this)
	}, run: function (e) {
		var t, n = S.propHooks[this.prop];
		return this.pos = t = this.options.duration ? J.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : S.propHooks._default.set(this), this
	}}, S.prototype.init.prototype = S.prototype, S.propHooks = {_default: {get: function (e) {
		var t;
		return null == e.elem[e.prop] || e.elem.style && null != e.elem.style[e.prop] ? (t = J.css(e.elem, e.prop, ""), t && "auto" !== t ? t : 0) : e.elem[e.prop]
	}, set: function (e) {
		J.fx.step[e.prop] ? J.fx.step[e.prop](e) : e.elem.style && (null != e.elem.style[J.cssProps[e.prop]] || J.cssHooks[e.prop]) ? J.style(e.elem, e.prop, e.now + e.unit) : e.elem[e.prop] = e.now
	}}}, S.propHooks.scrollTop = S.propHooks.scrollLeft = {set: function (e) {
		e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now)
	}}, J.easing = {linear: function (e) {
		return e
	}, swing: function (e) {
		return.5 - Math.cos(e * Math.PI) / 2
	}}, J.fx = S.prototype.init, J.fx.step = {};
	var Zt, Qt, $t = /^(?:toggle|show|hide)$/, Jt = new RegExp("^(?:([+-])=|)(" + xt + ")([a-z%]*)$", "i"), en = /queueHooks$/, tn = [k], nn = {"*": [function (e, t) {
		var n = this.createTween(e, t), r = n.cur(), i = Jt.exec(t), o = i && i[3] || (J.cssNumber[e] ? "" : "px"), a = (J.cssNumber[e] || "px" !== o && +r) && Jt.exec(J.css(n.elem, e)), s = 1, l = 20;
		if (a && a[3] !== o) {
			o = o || a[3], i = i || [], a = +r || 1;
			do s = s || ".5", a /= s, J.style(n.elem, e, a + o); while (s !== (s = n.cur() / r) && 1 !== s && --l)
		}
		return i && (a = n.start = +a || +r || 0, n.unit = o, n.end = i[1] ? a + (i[1] + 1) * i[2] : +i[2]), n
	}]};
	J.Animation = J.extend(D, {tweener: function (e, t) {
		J.isFunction(e) ? (t = e, e = ["*"]) : e = e.split(" ");
		for (var n, r = 0, i = e.length; i > r; r++)n = e[r], nn[n] = nn[n] || [], nn[n].unshift(t)
	}, prefilter: function (e, t) {
		t ? tn.unshift(e) : tn.push(e)
	}}), J.speed = function (e, t, n) {
		var r = e && "object" == typeof e ? J.extend({}, e) : {complete: n || !n && t || J.isFunction(e) && e, duration: e, easing: n && t || t && !J.isFunction(t) && t};
		return r.duration = J.fx.off ? 0 : "number" == typeof r.duration ? r.duration : r.duration in J.fx.speeds ? J.fx.speeds[r.duration] : J.fx.speeds._default, (null == r.queue || r.queue === !0) && (r.queue = "fx"), r.old = r.complete, r.complete = function () {
			J.isFunction(r.old) && r.old.call(this), r.queue && J.dequeue(this, r.queue)
		}, r
	}, J.fn.extend({fadeTo: function (e, t, n, r) {
		return this.filter(bt).css("opacity", 0).show().end().animate({opacity: t}, e, n, r)
	}, animate: function (e, t, n, r) {
		var i = J.isEmptyObject(e), o = J.speed(t, n, r), a = function () {
			var t = D(this, J.extend({}, e), o);
			(i || Et.get(this, "finish")) && t.stop(!0)
		};
		return a.finish = a, i || o.queue === !1 ? this.each(a) : this.queue(o.queue, a)
	}, stop: function (e, t, n) {
		var r = function (e) {
			var t = e.stop;
			delete e.stop, t(n)
		};
		return"string" != typeof e && (n = t, t = e, e = void 0), t && e !== !1 && this.queue(e || "fx", []), this.each(function () {
			var t = !0, i = null != e && e + "queueHooks", o = J.timers, a = Et.get(this);
			if (i)a[i] && a[i].stop && r(a[i]); else for (i in a)a[i] && a[i].stop && en.test(i) && r(a[i]);
			for (i = o.length; i--;)o[i].elem !== this || null != e && o[i].queue !== e || (o[i].anim.stop(n), t = !1, o.splice(i, 1));
			(t || !n) && J.dequeue(this, e)
		})
	}, finish: function (e) {
		return e !== !1 && (e = e || "fx"), this.each(function () {
			var t, n = Et.get(this), r = n[e + "queue"], i = n[e + "queueHooks"], o = J.timers, a = r ? r.length : 0;
			for (n.finish = !0, J.queue(this, e, []), i && i.stop && i.stop.call(this, !0), t = o.length; t--;)o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0), o.splice(t, 1));
			for (t = 0; a > t; t++)r[t] && r[t].finish && r[t].finish.call(this);
			delete n.finish
		})
	}}), J.each(["toggle", "show", "hide"], function (e, t) {
		var n = J.fn[t];
		J.fn[t] = function (e, r, i) {
			return null == e || "boolean" == typeof e ? n.apply(this, arguments) : this.animate(A(t, !0), e, r, i)
		}
	}), J.each({slideDown: A("show"), slideUp: A("hide"), slideToggle: A("toggle"), fadeIn: {opacity: "show"}, fadeOut: {opacity: "hide"}, fadeToggle: {opacity: "toggle"}}, function (e, t) {
		J.fn[e] = function (e, n, r) {
			return this.animate(t, e, n, r)
		}
	}), J.timers = [], J.fx.tick = function () {
		var e, t = 0, n = J.timers;
		for (Zt = J.now(); t < n.length; t++)e = n[t], e() || n[t] !== e || n.splice(t--, 1);
		n.length || J.fx.stop(), Zt = void 0
	}, J.fx.timer = function (e) {
		J.timers.push(e), e() ? J.fx.start() : J.timers.pop()
	}, J.fx.interval = 13, J.fx.start = function () {
		Qt || (Qt = setInterval(J.fx.tick, J.fx.interval))
	}, J.fx.stop = function () {
		clearInterval(Qt), Qt = null
	}, J.fx.speeds = {slow: 600, fast: 200, _default: 400}, J.fn.delay = function (e, t) {
		return e = J.fx ? J.fx.speeds[e] || e : e, t = t || "fx", this.queue(t, function (t, n) {
			var r = setTimeout(t, e);
			n.stop = function () {
				clearTimeout(r)
			}
		})
	}, function () {
		var e = Q.createElement("input"), t = Q.createElement("select"), n = t.appendChild(Q.createElement("option"));
		e.type = "checkbox", Z.checkOn = "" !== e.value, Z.optSelected = n.selected, t.disabled = !0, Z.optDisabled = !n.disabled, e = Q.createElement("input"), e.value = "t", e.type = "radio", Z.radioValue = "t" === e.value
	}();
	var rn, on, an = J.expr.attrHandle;
	J.fn.extend({attr: function (e, t) {
		return gt(this, J.attr, e, t, arguments.length > 1)
	}, removeAttr: function (e) {
		return this.each(function () {
			J.removeAttr(this, e)
		})
	}}), J.extend({attr: function (e, t, n) {
		var r, i, o = e.nodeType;
		return e && 3 !== o && 8 !== o && 2 !== o ? typeof e.getAttribute === wt ? J.prop(e, t, n) : (1 === o && J.isXMLDoc(e) || (t = t.toLowerCase(), r = J.attrHooks[t] || (J.expr.match.bool.test(t) ? on : rn)), void 0 === n ? r && "get"in r && null !== (i = r.get(e, t)) ? i : (i = J.find.attr(e, t), null == i ? void 0 : i) : null !== n ? r && "set"in r && void 0 !== (i = r.set(e, n, t)) ? i : (e.setAttribute(t, n + ""), n) : void J.removeAttr(e, t)) : void 0
	}, removeAttr: function (e, t) {
		var n, r, i = 0, o = t && t.match(dt);
		if (o && 1 === e.nodeType)for (; n = o[i++];)r = J.propFix[n] || n, J.expr.match.bool.test(n) && (e[r] = !1), e.removeAttribute(n)
	}, attrHooks: {type: {set: function (e, t) {
		if (!Z.radioValue && "radio" === t && J.nodeName(e, "input")) {
			var n = e.value;
			return e.setAttribute("type", t), n && (e.value = n), t
		}
	}}}}), on = {set: function (e, t, n) {
		return t === !1 ? J.removeAttr(e, n) : e.setAttribute(n, n), n
	}}, J.each(J.expr.match.bool.source.match(/\w+/g), function (e, t) {
		var n = an[t] || J.find.attr;
		an[t] = function (e, t, r) {
			var i, o;
			return r || (o = an[t], an[t] = i, i = null != n(e, t, r) ? t.toLowerCase() : null, an[t] = o), i
		}
	});
	var sn = /^(?:input|select|textarea|button)$/i;
	J.fn.extend({prop: function (e, t) {
		return gt(this, J.prop, e, t, arguments.length > 1)
	}, removeProp: function (e) {
		return this.each(function () {
			delete this[J.propFix[e] || e]
		})
	}}), J.extend({propFix: {"for": "htmlFor", "class": "className"}, prop: function (e, t, n) {
		var r, i, o, a = e.nodeType;
		return e && 3 !== a && 8 !== a && 2 !== a ? (o = 1 !== a || !J.isXMLDoc(e), o && (t = J.propFix[t] || t, i = J.propHooks[t]), void 0 !== n ? i && "set"in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get"in i && null !== (r = i.get(e, t)) ? r : e[t]) : void 0
	}, propHooks: {tabIndex: {get: function (e) {
		return e.hasAttribute("tabindex") || sn.test(e.nodeName) || e.href ? e.tabIndex : -1
	}}}}), Z.optSelected || (J.propHooks.selected = {get: function (e) {
		var t = e.parentNode;
		return t && t.parentNode && t.parentNode.selectedIndex, null
	}}), J.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
		J.propFix[this.toLowerCase()] = this
	});
	var ln = /[\t\r\n\f]/g;
	J.fn.extend({addClass: function (e) {
		var t, n, r, i, o, a, s = "string" == typeof e && e, l = 0, u = this.length;
		if (J.isFunction(e))return this.each(function (t) {
			J(this).addClass(e.call(this, t, this.className))
		});
		if (s)for (t = (e || "").match(dt) || []; u > l; l++)if (n = this[l], r = 1 === n.nodeType && (n.className ? (" " + n.className + " ").replace(ln, " ") : " ")) {
			for (o = 0; i = t[o++];)r.indexOf(" " + i + " ") < 0 && (r += i + " ");
			a = J.trim(r), n.className !== a && (n.className = a)
		}
		return this
	}, removeClass: function (e) {
		var t, n, r, i, o, a, s = 0 === arguments.length || "string" == typeof e && e, l = 0, u = this.length;
		if (J.isFunction(e))return this.each(function (t) {
			J(this).removeClass(e.call(this, t, this.className))
		});
		if (s)for (t = (e || "").match(dt) || []; u > l; l++)if (n = this[l], r = 1 === n.nodeType && (n.className ? (" " + n.className + " ").replace(ln, " ") : "")) {
			for (o = 0; i = t[o++];)for (; r.indexOf(" " + i + " ") >= 0;)r = r.replace(" " + i + " ", " ");
			a = e ? J.trim(r) : "", n.className !== a && (n.className = a)
		}
		return this
	}, toggleClass: function (e, t) {
		var n = typeof e;
		return"boolean" == typeof t && "string" === n ? t ? this.addClass(e) : this.removeClass(e) : this.each(J.isFunction(e) ? function (n) {
			J(this).toggleClass(e.call(this, n, this.className, t), t)
		} : function () {
			if ("string" === n)for (var t, r = 0, i = J(this), o = e.match(dt) || []; t = o[r++];)i.hasClass(t) ? i.removeClass(t) : i.addClass(t); else(n === wt || "boolean" === n) && (this.className && Et.set(this, "__className__", this.className), this.className = this.className || e === !1 ? "" : Et.get(this, "__className__") || "")
		})
	}, hasClass: function (e) {
		for (var t = " " + e + " ", n = 0, r = this.length; r > n; n++)if (1 === this[n].nodeType && (" " + this[n].className + " ").replace(ln, " ").indexOf(t) >= 0)return!0;
		return!1
	}});
	var un = /\r/g;
	J.fn.extend({val: function (e) {
		var t, n, r, i = this[0];
		return arguments.length ? (r = J.isFunction(e), this.each(function (n) {
			var i;
			1 === this.nodeType && (i = r ? e.call(this, n, J(this).val()) : e, null == i ? i = "" : "number" == typeof i ? i += "" : J.isArray(i) && (i = J.map(i, function (e) {
				return null == e ? "" : e + ""
			})), t = J.valHooks[this.type] || J.valHooks[this.nodeName.toLowerCase()], t && "set"in t && void 0 !== t.set(this, i, "value") || (this.value = i))
		})) : i ? (t = J.valHooks[i.type] || J.valHooks[i.nodeName.toLowerCase()], t && "get"in t && void 0 !== (n = t.get(i, "value")) ? n : (n = i.value, "string" == typeof n ? n.replace(un, "") : null == n ? "" : n)) : void 0
	}}), J.extend({valHooks: {option: {get: function (e) {
		var t = J.find.attr(e, "value");
		return null != t ? t : J.trim(J.text(e))
	}}, select: {get: function (e) {
		for (var t, n, r = e.options, i = e.selectedIndex, o = "select-one" === e.type || 0 > i, a = o ? null : [], s = o ? i + 1 : r.length, l = 0 > i ? s : o ? i : 0; s > l; l++)if (n = r[l], !(!n.selected && l !== i || (Z.optDisabled ? n.disabled : null !== n.getAttribute("disabled")) || n.parentNode.disabled && J.nodeName(n.parentNode, "optgroup"))) {
			if (t = J(n).val(), o)return t;
			a.push(t)
		}
		return a
	}, set: function (e, t) {
		for (var n, r, i = e.options, o = J.makeArray(t), a = i.length; a--;)r = i[a], (r.selected = J.inArray(r.value, o) >= 0) && (n = !0);
		return n || (e.selectedIndex = -1), o
	}}}}), J.each(["radio", "checkbox"], function () {
		J.valHooks[this] = {set: function (e, t) {
			return J.isArray(t) ? e.checked = J.inArray(J(e).val(), t) >= 0 : void 0
		}}, Z.checkOn || (J.valHooks[this].get = function (e) {
			return null === e.getAttribute("value") ? "on" : e.value
		})
	}), J.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function (e, t) {
		J.fn[t] = function (e, n) {
			return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t)
		}
	}), J.fn.extend({hover: function (e, t) {
		return this.mouseenter(e).mouseleave(t || e)
	}, bind: function (e, t, n) {
		return this.on(e, null, t, n)
	}, unbind: function (e, t) {
		return this.off(e, null, t)
	}, delegate: function (e, t, n, r) {
		return this.on(t, e, n, r)
	}, undelegate: function (e, t, n) {
		return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n)
	}});
	var cn = J.now(), hn = /\?/;
	J.parseJSON = function (e) {
		return JSON.parse(e + "")
	}, J.parseXML = function (e) {
		var t, n;
		if (!e || "string" != typeof e)return null;
		try {
			n = new DOMParser, t = n.parseFromString(e, "text/xml")
		} catch (r) {
			t = void 0
		}
		return(!t || t.getElementsByTagName("parsererror").length) && J.error("Invalid XML: " + e), t
	};
	var fn, dn, pn = /#.*$/, mn = /([?&])_=[^&]*/, gn = /^(.*?):[ \t]*([^\r\n]*)$/gm, En = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, vn = /^(?:GET|HEAD)$/, yn = /^\/\//, Tn = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, xn = {}, Rn = {}, bn = "*/".concat("*");
	try {
		dn = location.href
	} catch (_n) {
		dn = Q.createElement("a"), dn.href = "", dn = dn.href
	}
	fn = Tn.exec(dn.toLowerCase()) || [], J.extend({active: 0, lastModified: {}, etag: {}, ajaxSettings: {url: dn, type: "GET", isLocal: En.test(fn[1]), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: {"*": bn, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript"}, contents: {xml: /xml/, html: /html/, json: /json/}, responseFields: {xml: "responseXML", text: "responseText", json: "responseJSON"}, converters: {"* text": String, "text html": !0, "text json": J.parseJSON, "text xml": J.parseXML}, flatOptions: {url: !0, context: !0}}, ajaxSetup: function (e, t) {
		return t ? z(z(e, J.ajaxSettings), t) : z(J.ajaxSettings, e)
	}, ajaxPrefilter: F(xn), ajaxTransport: F(Rn), ajax: function (e, t) {
		function n(e, t, n, a) {
			var l, c, E, v, T, R = t;
			2 !== y && (y = 2, s && clearTimeout(s), r = void 0, o = a || "", x.readyState = e > 0 ? 4 : 0, l = e >= 200 && 300 > e || 304 === e, n && (v = U(h, x, n)), v = V(h, v, x, l), l ? (h.ifModified && (T = x.getResponseHeader("Last-Modified"), T && (J.lastModified[i] = T), T = x.getResponseHeader("etag"), T && (J.etag[i] = T)), 204 === e || "HEAD" === h.type ? R = "nocontent" : 304 === e ? R = "notmodified" : (R = v.state, c = v.data, E = v.error, l = !E)) : (E = R, (e || !R) && (R = "error", 0 > e && (e = 0))), x.status = e, x.statusText = (t || R) + "", l ? p.resolveWith(f, [c, R, x]) : p.rejectWith(f, [x, R, E]), x.statusCode(g), g = void 0, u && d.trigger(l ? "ajaxSuccess" : "ajaxError", [x, h, l ? c : E]), m.fireWith(f, [x, R]), u && (d.trigger("ajaxComplete", [x, h]), --J.active || J.event.trigger("ajaxStop")))
		}

		"object" == typeof e && (t = e, e = void 0), t = t || {};
		var r, i, o, a, s, l, u, c, h = J.ajaxSetup({}, t), f = h.context || h, d = h.context && (f.nodeType || f.jquery) ? J(f) : J.event, p = J.Deferred(), m = J.Callbacks("once memory"), g = h.statusCode || {}, E = {}, v = {}, y = 0, T = "canceled", x = {readyState: 0, getResponseHeader: function (e) {
			var t;
			if (2 === y) {
				if (!a)for (a = {}; t = gn.exec(o);)a[t[1].toLowerCase()] = t[2];
				t = a[e.toLowerCase()]
			}
			return null == t ? null : t
		}, getAllResponseHeaders: function () {
			return 2 === y ? o : null
		}, setRequestHeader: function (e, t) {
			var n = e.toLowerCase();
			return y || (e = v[n] = v[n] || e, E[e] = t), this
		}, overrideMimeType: function (e) {
			return y || (h.mimeType = e), this
		}, statusCode: function (e) {
			var t;
			if (e)if (2 > y)for (t in e)g[t] = [g[t], e[t]]; else x.always(e[x.status]);
			return this
		}, abort: function (e) {
			var t = e || T;
			return r && r.abort(t), n(0, t), this
		}};
		if (p.promise(x).complete = m.add, x.success = x.done, x.error = x.fail, h.url = ((e || h.url || dn) + "").replace(pn, "").replace(yn, fn[1] + "//"), h.type = t.method || t.type || h.method || h.type, h.dataTypes = J.trim(h.dataType || "*").toLowerCase().match(dt) || [""], null == h.crossDomain && (l = Tn.exec(h.url.toLowerCase()), h.crossDomain = !(!l || l[1] === fn[1] && l[2] === fn[2] && (l[3] || ("http:" === l[1] ? "80" : "443")) === (fn[3] || ("http:" === fn[1] ? "80" : "443")))), h.data && h.processData && "string" != typeof h.data && (h.data = J.param(h.data, h.traditional)), N(xn, h, t, x), 2 === y)return x;
		u = h.global, u && 0 === J.active++ && J.event.trigger("ajaxStart"), h.type = h.type.toUpperCase(), h.hasContent = !vn.test(h.type), i = h.url, h.hasContent || (h.data && (i = h.url += (hn.test(i) ? "&" : "?") + h.data, delete h.data), h.cache === !1 && (h.url = mn.test(i) ? i.replace(mn, "$1_=" + cn++) : i + (hn.test(i) ? "&" : "?") + "_=" + cn++)), h.ifModified && (J.lastModified[i] && x.setRequestHeader("If-Modified-Since", J.lastModified[i]), J.etag[i] && x.setRequestHeader("If-None-Match", J.etag[i])), (h.data && h.hasContent && h.contentType !== !1 || t.contentType) && x.setRequestHeader("Content-Type", h.contentType), x.setRequestHeader("Accept", h.dataTypes[0] && h.accepts[h.dataTypes[0]] ? h.accepts[h.dataTypes[0]] + ("*" !== h.dataTypes[0] ? ", " + bn + "; q=0.01" : "") : h.accepts["*"]);
		for (c in h.headers)x.setRequestHeader(c, h.headers[c]);
		if (h.beforeSend && (h.beforeSend.call(f, x, h) === !1 || 2 === y))return x.abort();
		T = "abort";
		for (c in{success: 1, error: 1, complete: 1})x[c](h[c]);
		if (r = N(Rn, h, t, x)) {
			x.readyState = 1, u && d.trigger("ajaxSend", [x, h]), h.async && h.timeout > 0 && (s = setTimeout(function () {
				x.abort("timeout")
			}, h.timeout));
			try {
				y = 1, r.send(E, n)
			} catch (R) {
				if (!(2 > y))throw R;
				n(-1, R)
			}
		} else n(-1, "No Transport");
		return x
	}, getJSON: function (e, t, n) {
		return J.get(e, t, n, "json")
	}, getScript: function (e, t) {
		return J.get(e, void 0, t, "script")
	}}), J.each(["get", "post"], function (e, t) {
		J[t] = function (e, n, r, i) {
			return J.isFunction(n) && (i = i || r, r = n, n = void 0), J.ajax({url: e, type: t, dataType: i, data: n, success: r})
		}
	}), J.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t) {
		J.fn[t] = function (e) {
			return this.on(t, e)
		}
	}), J._evalUrl = function (e) {
		return J.ajax({url: e, type: "GET", dataType: "script", async: !1, global: !1, "throws": !0})
	}, J.fn.extend({wrapAll: function (e) {
		var t;
		return J.isFunction(e) ? this.each(function (t) {
			J(this).wrapAll(e.call(this, t))
		}) : (this[0] && (t = J(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function () {
			for (var e = this; e.firstElementChild;)e = e.firstElementChild;
			return e
		}).append(this)), this)
	}, wrapInner: function (e) {
		return this.each(J.isFunction(e) ? function (t) {
			J(this).wrapInner(e.call(this, t))
		} : function () {
			var t = J(this), n = t.contents();
			n.length ? n.wrapAll(e) : t.append(e)
		})
	}, wrap: function (e) {
		var t = J.isFunction(e);
		return this.each(function (n) {
			J(this).wrapAll(t ? e.call(this, n) : e)
		})
	}, unwrap: function () {
		return this.parent().each(function () {
			J.nodeName(this, "body") || J(this).replaceWith(this.childNodes)
		}).end()
	}}), J.expr.filters.hidden = function (e) {
		return e.offsetWidth <= 0 && e.offsetHeight <= 0
	}, J.expr.filters.visible = function (e) {
		return!J.expr.filters.hidden(e)
	};
	var wn = /%20/g, Hn = /\[\]$/, Mn = /\r?\n/g, Sn = /^(?:submit|button|image|reset|file)$/i, Cn = /^(?:input|select|textarea|keygen)/i;
	J.param = function (e, t) {
		var n, r = [], i = function (e, t) {
			t = J.isFunction(t) ? t() : null == t ? "" : t, r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(t)
		};
		if (void 0 === t && (t = J.ajaxSettings && J.ajaxSettings.traditional), J.isArray(e) || e.jquery && !J.isPlainObject(e))J.each(e, function () {
			i(this.name, this.value)
		}); else for (n in e)B(n, e[n], t, i);
		return r.join("&").replace(wn, "+")
	}, J.fn.extend({serialize: function () {
		return J.param(this.serializeArray())
	}, serializeArray: function () {
		return this.map(function () {
			var e = J.prop(this, "elements");
			return e ? J.makeArray(e) : this
		}).filter(function () {
			var e = this.type;
			return this.name && !J(this).is(":disabled") && Cn.test(this.nodeName) && !Sn.test(e) && (this.checked || !_t.test(e))
		}).map(function (e, t) {
			var n = J(this).val();
			return null == n ? null : J.isArray(n) ? J.map(n, function (e) {
				return{name: t.name, value: e.replace(Mn, "\r\n")}
			}) : {name: t.name, value: n.replace(Mn, "\r\n")}
		}).get()
	}}), J.ajaxSettings.xhr = function () {
		try {
			return new XMLHttpRequest
		} catch (e) {
		}
	};
	var An = 0, Ln = {}, kn = {0: 200, 1223: 204}, Pn = J.ajaxSettings.xhr();
	e.ActiveXObject && J(e).on("unload", function () {
		for (var e in Ln)Ln[e]()
	}), Z.cors = !!Pn && "withCredentials"in Pn, Z.ajax = Pn = !!Pn, J.ajaxTransport(function (e) {
		var t;
		return Z.cors || Pn && !e.crossDomain ? {send: function (n, r) {
			var i, o = e.xhr(), a = ++An;
			if (o.open(e.type, e.url, e.async, e.username, e.password), e.xhrFields)for (i in e.xhrFields)o[i] = e.xhrFields[i];
			e.mimeType && o.overrideMimeType && o.overrideMimeType(e.mimeType), e.crossDomain || n["X-Requested-With"] || (n["X-Requested-With"] = "XMLHttpRequest");
			for (i in n)o.setRequestHeader(i, n[i]);
			t = function (e) {
				return function () {
					t && (delete Ln[a], t = o.onload = o.onerror = null, "abort" === e ? o.abort() : "error" === e ? r(o.status, o.statusText) : r(kn[o.status] || o.status, o.statusText, "string" == typeof o.responseText ? {text: o.responseText} : void 0, o.getAllResponseHeaders()))
				}
			}, o.onload = t(), o.onerror = t("error"), t = Ln[a] = t("abort");
			try {
				o.send(e.hasContent && e.data || null)
			} catch (s) {
				if (t)throw s
			}
		}, abort: function () {
			t && t()
		}} : void 0
	}), J.ajaxSetup({accepts: {script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"}, contents: {script: /(?:java|ecma)script/}, converters: {"text script": function (e) {
		return J.globalEval(e), e
	}}}), J.ajaxPrefilter("script", function (e) {
		void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET")
	}), J.ajaxTransport("script", function (e) {
		if (e.crossDomain) {
			var t, n;
			return{send: function (r, i) {
				t = J("<script>").prop({async: !0, charset: e.scriptCharset, src: e.url}).on("load error", n = function (e) {
					t.remove(), n = null, e && i("error" === e.type ? 404 : 200, e.type)
				}), Q.head.appendChild(t[0])
			}, abort: function () {
				n && n()
			}}
		}
	});
	var Dn = [], Fn = /(=)\?(?=&|$)|\?\?/;
	J.ajaxSetup({jsonp: "callback", jsonpCallback: function () {
		var e = Dn.pop() || J.expando + "_" + cn++;
		return this[e] = !0, e
	}}), J.ajaxPrefilter("json jsonp", function (t, n, r) {
		var i, o, a, s = t.jsonp !== !1 && (Fn.test(t.url) ? "url" : "string" == typeof t.data && !(t.contentType || "").indexOf("application/x-www-form-urlencoded") && Fn.test(t.data) && "data");
		return s || "jsonp" === t.dataTypes[0] ? (i = t.jsonpCallback = J.isFunction(t.jsonpCallback) ? t.jsonpCallback() : t.jsonpCallback, s ? t[s] = t[s].replace(Fn, "$1" + i) : t.jsonp !== !1 && (t.url += (hn.test(t.url) ? "&" : "?") + t.jsonp + "=" + i), t.converters["script json"] = function () {
			return a || J.error(i + " was not called"), a[0]
		}, t.dataTypes[0] = "json", o = e[i], e[i] = function () {
			a = arguments
		}, r.always(function () {
			e[i] = o, t[i] && (t.jsonpCallback = n.jsonpCallback, Dn.push(i)), a && J.isFunction(o) && o(a[0]), a = o = void 0
		}), "script") : void 0
	}), J.parseHTML = function (e, t, n) {
		if (!e || "string" != typeof e)return null;
		"boolean" == typeof t && (n = t, t = !1), t = t || Q;
		var r = at.exec(e), i = !n && [];
		return r ? [t.createElement(r[1])] : (r = J.buildFragment([e], t, i), i && i.length && J(i).remove(), J.merge([], r.childNodes))
	};
	var Nn = J.fn.load;
	J.fn.load = function (e, t, n) {
		if ("string" != typeof e && Nn)return Nn.apply(this, arguments);
		var r, i, o, a = this, s = e.indexOf(" ");
		return s >= 0 && (r = J.trim(e.slice(s)), e = e.slice(0, s)), J.isFunction(t) ? (n = t, t = void 0) : t && "object" == typeof t && (i = "POST"), a.length > 0 && J.ajax({url: e, type: i, dataType: "html", data: t}).done(function (e) {
			o = arguments, a.html(r ? J("<div>").append(J.parseHTML(e)).find(r) : e)
		}).complete(n && function (e, t) {
			a.each(n, o || [e.responseText, t, e])
		}), this
	}, J.expr.filters.animated = function (e) {
		return J.grep(J.timers,function (t) {
			return e === t.elem
		}).length
	};
	var zn = e.document.documentElement;
	J.offset = {setOffset: function (e, t, n) {
		var r, i, o, a, s, l, u, c = J.css(e, "position"), h = J(e), f = {};
		"static" === c && (e.style.position = "relative"), s = h.offset(), o = J.css(e, "top"), l = J.css(e, "left"), u = ("absolute" === c || "fixed" === c) && (o + l).indexOf("auto") > -1, u ? (r = h.position(), a = r.top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(l) || 0), J.isFunction(t) && (t = t.call(e, n, s)), null != t.top && (f.top = t.top - s.top + a), null != t.left && (f.left = t.left - s.left + i), "using"in t ? t.using.call(e, f) : h.css(f)
	}}, J.fn.extend({offset: function (e) {
		if (arguments.length)return void 0 === e ? this : this.each(function (t) {
			J.offset.setOffset(this, e, t)
		});
		var t, n, r = this[0], i = {top: 0, left: 0}, o = r && r.ownerDocument;
		return o ? (t = o.documentElement, J.contains(t, r) ? (typeof r.getBoundingClientRect !== wt && (i = r.getBoundingClientRect()), n = O(o), {top: i.top + n.pageYOffset - t.clientTop, left: i.left + n.pageXOffset - t.clientLeft}) : i) : void 0
	}, position: function () {
		if (this[0]) {
			var e, t, n = this[0], r = {top: 0, left: 0};
			return"fixed" === J.css(n, "position") ? t = n.getBoundingClientRect() : (e = this.offsetParent(), t = this.offset(), J.nodeName(e[0], "html") || (r = e.offset()), r.top += J.css(e[0], "borderTopWidth", !0), r.left += J.css(e[0], "borderLeftWidth", !0)), {top: t.top - r.top - J.css(n, "marginTop", !0), left: t.left - r.left - J.css(n, "marginLeft", !0)}
		}
	}, offsetParent: function () {
		return this.map(function () {
			for (var e = this.offsetParent || zn; e && !J.nodeName(e, "html") && "static" === J.css(e, "position");)e = e.offsetParent;
			return e || zn
		})
	}}), J.each({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function (t, n) {
		var r = "pageYOffset" === n;
		J.fn[t] = function (i) {
			return gt(this, function (t, i, o) {
				var a = O(t);
				return void 0 === o ? a ? a[n] : t[i] : void(a ? a.scrollTo(r ? e.pageXOffset : o, r ? o : e.pageYOffset) : t[i] = o)
			}, t, i, arguments.length, null)
		}
	}), J.each(["top", "left"], function (e, t) {
		J.cssHooks[t] = R(Z.pixelPosition, function (e, n) {
			return n ? (n = x(e, t), It.test(n) ? J(e).position()[t] + "px" : n) : void 0
		})
	}), J.each({Height: "height", Width: "width"}, function (e, t) {
		J.each({padding: "inner" + e, content: t, "": "outer" + e}, function (n, r) {
			J.fn[r] = function (r, i) {
				var o = arguments.length && (n || "boolean" != typeof r), a = n || (r === !0 || i === !0 ? "margin" : "border");
				return gt(this, function (t, n, r) {
					var i;
					return J.isWindow(t) ? t.document.documentElement["client" + e] : 9 === t.nodeType ? (i = t.documentElement, Math.max(t.body["scroll" + e], i["scroll" + e], t.body["offset" + e], i["offset" + e], i["client" + e])) : void 0 === r ? J.css(t, n, a) : J.style(t, n, r, a)
				}, t, o ? r : void 0, o, null)
			}
		})
	}), J.fn.size = function () {
		return this.length
	}, J.fn.andSelf = J.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function () {
		return J
	});
	var Un = e.jQuery, Vn = e.$;
	return J.noConflict = function (t) {
		return e.$ === J && (e.$ = Vn), t && e.jQuery === J && (e.jQuery = Un), J
	}, typeof t === wt && (e.jQuery = e.$ = J), J
}), function (e) {
	"function" == typeof define && define.amd ? define(["jquery"], e) : e(jQuery)
}(function (e) {
	function t(n, r) {
		var i = function () {
		}, i = {autoSelectFirst: !1, appendTo: "body", serviceUrl: null, lookup: null, onSelect: null, width: "auto", minChars: 1, maxHeight: 300, deferRequestBy: 0, params: {}, formatResult: t.formatResult, delimiter: null, zIndex: 9999, type: "GET", noCache: !1, onSearchStart: i, onSearchComplete: i, onSearchError: i, containerClass: "autocomplete-suggestions", tabDisabled: !1, dataType: "text", currentRequest: null, triggerSelectOnValidInput: !0, lookupFilter: function (e, t, n) {
			return-1 !== e.value.toLowerCase().indexOf(n)
		}, paramName: "query", transformResult: function (t) {
			return"string" == typeof t ? e.parseJSON(t) : t
		}};
		this.element = n, this.el = e(n), this.suggestions = [], this.badQueries = [], this.selectedIndex = -1, this.currentValue = this.element.value, this.intervalId = 0, this.cachedResponse = {}, this.onChange = this.onChangeInterval = null, this.isLocal = !1, this.suggestionsContainer = null, this.options = e.extend({}, i, r), this.classes = {selected: "autocomplete-selected", suggestion: "autocomplete-suggestion"}, this.hint = null, this.hintValue = "", this.selection = null, this.initialize(), this.setOptions(r)
	}

	var n = function () {
		return{escapeRegExChars: function (e) {
			return e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&")
		}, createNode: function (e) {
			var t = document.createElement("div");
			return t.className = e, t.style.position = "absolute", t.style.display = "none", t
		}}
	}();
	t.utils = n, e.Autocomplete = t, t.formatResult = function (e, t) {
		var r = "(" + n.escapeRegExChars(t) + ")";
		return e.value.replace(RegExp(r, "gi"), "<strong>$1</strong>")
	}, t.prototype = {killerFn: null, initialize: function () {
		var n, r = this, i = "." + r.classes.suggestion, o = r.classes.selected, a = r.options;
		r.element.setAttribute("autocomplete", "off"), r.killerFn = function (t) {
			0 === e(t.target).closest("." + r.options.containerClass).length && (r.killSuggestions(), r.disableKillerFn())
		}, r.suggestionsContainer = t.utils.createNode(a.containerClass), n = e(r.suggestionsContainer), n.appendTo(a.appendTo), "auto" !== a.width && n.width(a.width), n.on("mouseover.autocomplete", i, function () {
			r.activate(e(this).data("index"))
		}), n.on("mouseout.autocomplete", function () {
			r.selectedIndex = -1, n.children("." + o).removeClass(o)
		}), n.on("click.autocomplete", i, function () {
			r.select(e(this).data("index"))
		}), r.fixPosition(), r.fixPositionCapture = function () {
			r.visible && r.fixPosition()
		}, e(window).on("resize.autocomplete", r.fixPositionCapture), r.el.on("keydown.autocomplete", function (e) {
			r.onKeyPress(e)
		}), r.el.on("keyup.autocomplete", function (e) {
			r.onKeyUp(e)
		}), r.el.on("blur.autocomplete", function () {
			r.onBlur()
		}), r.el.on("focus.autocomplete", function () {
			r.onFocus()
		}), r.el.on("change.autocomplete", function (e) {
			r.onKeyUp(e)
		})
	}, onFocus: function () {
		this.fixPosition(), this.options.minChars <= this.el.val().length && this.onValueChange()
	}, onBlur: function () {
		this.enableKillerFn()
	}, setOptions: function (t) {
		var n = this.options;
		e.extend(n, t), (this.isLocal = e.isArray(n.lookup)) && (n.lookup = this.verifySuggestionsFormat(n.lookup)), e(this.suggestionsContainer).css({"max-height": n.maxHeight + "px", width: n.width + "px", "z-index": n.zIndex})
	}, clearCache: function () {
		this.cachedResponse = {}, this.badQueries = []
	}, clear: function () {
		this.clearCache(), this.currentValue = "", this.suggestions = []
	}, disable: function () {
		this.disabled = !0, this.currentRequest && this.currentRequest.abort()
	}, enable: function () {
		this.disabled = !1
	}, fixPosition: function () {
		var t;
		"body" === this.options.appendTo && (t = this.el.offset(), t = {top: t.top + this.el.outerHeight() + "px", left: t.left + "px"}, "auto" === this.options.width && (t.width = this.el.outerWidth() - 2 + "px"), e(this.suggestionsContainer).css(t))
	}, enableKillerFn: function () {
		e(document).on("click.autocomplete", this.killerFn)
	}, disableKillerFn: function () {
		e(document).off("click.autocomplete", this.killerFn)
	}, killSuggestions: function () {
		var e = this;
		e.stopKillSuggestions(), e.intervalId = window.setInterval(function () {
			e.hide(), e.stopKillSuggestions()
		}, 50)
	}, stopKillSuggestions: function () {
		window.clearInterval(this.intervalId)
	}, isCursorAtEnd: function () {
		var e = this.el.val().length, t = this.element.selectionStart;
		return"number" == typeof t ? t === e : document.selection ? (t = document.selection.createRange(), t.moveStart("character", -e), e === t.text.length) : !0
	}, onKeyPress: function (e) {
		if (this.disabled || this.visible || 40 !== e.which || !this.currentValue) {
			if (!this.disabled && this.visible) {
				switch (e.which) {
					case 27:
						this.el.val(this.currentValue), this.hide();
						break;
					case 39:
						if (this.hint && this.options.onHint && this.isCursorAtEnd()) {
							this.selectHint();
							break
						}
						return;
					case 9:
						if (this.hint && this.options.onHint)return void this.selectHint();
					case 13:
						if (-1 === this.selectedIndex)return void this.hide();
						if (this.select(this.selectedIndex), 9 === e.which && !1 === this.options.tabDisabled)return;
						break;
					case 38:
						this.moveUp();
						break;
					case 40:
						this.moveDown();
						break;
					default:
						return
				}
				e.stopImmediatePropagation(), e.preventDefault()
			}
		} else this.suggest()
	}, onKeyUp: function (e) {
		var t = this;
		if (!t.disabled) {
			switch (e.which) {
				case 38:
				case 40:
					return
			}
			clearInterval(t.onChangeInterval), t.currentValue !== t.el.val() && (t.findBestHint(), 0 < t.options.deferRequestBy ? t.onChangeInterval = setInterval(function () {
				t.onValueChange()
			}, t.options.deferRequestBy) : t.onValueChange())
		}
	}, onValueChange: function () {
		var t = this.options, n = this.el.val(), r = this.getQuery(n);
		return this.selection && (this.selection = null, (t.onInvalidateSelection || e.noop).call(this.element)), clearInterval(this.onChangeInterval), this.currentValue = n, this.selectedIndex = -1, t.triggerSelectOnValidInput && (n = this.findSuggestionIndex(r), -1 !== n) ? void this.select(n) : void(r.length < t.minChars ? this.hide() : this.getSuggestions(r))
	}, findSuggestionIndex: function (t) {
		var n = -1, r = t.toLowerCase();
		return e.each(this.suggestions, function (e, t) {
			return t.value.toLowerCase() === r ? (n = e, !1) : void 0
		}), n
	}, getQuery: function (t) {
		var n = this.options.delimiter;
		return n ? (t = t.split(n), e.trim(t[t.length - 1])) : t
	}, getSuggestionsLocal: function (t) {
		var n = this.options, r = t.toLowerCase(), i = n.lookupFilter, o = parseInt(n.lookupLimit, 10), n = {suggestions: e.grep(n.lookup, function (e) {
			return i(e, t, r)
		})};
		return o && n.suggestions.length > o && (n.suggestions = n.suggestions.slice(0, o)), n
	}, getSuggestions: function (t) {
		var n, r, i, o = this, a = o.options, s = a.serviceUrl;
		a.params[a.paramName] = t, r = a.ignoreParams ? null : a.params, o.isLocal ? n = o.getSuggestionsLocal(t) : (e.isFunction(s) && (s = s.call(o.element, t)), i = s + "?" + e.param(r || {}), n = o.cachedResponse[i]), n && e.isArray(n.suggestions) ? (o.suggestions = n.suggestions, o.suggest()) : o.isBadQuery(t) || !1 === a.onSearchStart.call(o.element, a.params) || (o.currentRequest && o.currentRequest.abort(), o.currentRequest = e.ajax({url: s, data: r, type: a.type, dataType: a.dataType}).done(function (e) {
			o.currentRequest = null, o.processResponse(e, t, i), a.onSearchComplete.call(o.element, t)
		}).fail(function (e, n, r) {
			a.onSearchError.call(o.element, t, e, n, r)
		}))
	}, isBadQuery: function (e) {
		for (var t = this.badQueries, n = t.length; n--;)if (0 === e.indexOf(t[n]))return!0;
		return!1
	}, hide: function () {
		this.visible = !1, this.selectedIndex = -1, e(this.suggestionsContainer).hide(), this.signalHint(null)
	}, suggest: function () {
		if (0 === this.suggestions.length)this.hide(); else {
			var t, n = this.options, r = n.formatResult, i = this.getQuery(this.currentValue), o = this.classes.suggestion, a = this.classes.selected, s = e(this.suggestionsContainer), l = n.beforeRender, u = "";
			if (n.triggerSelectOnValidInput && (t = this.findSuggestionIndex(i), -1 !== t))return void this.select(t);
			e.each(this.suggestions, function (e, t) {
				u += '<div class="' + o + '" data-index="' + e + '">' + r(t, i) + "</div>"
			}), "auto" === n.width && (t = this.el.outerWidth() - 2, s.width(t > 0 ? t : 300)), s.html(u), n.autoSelectFirst && (this.selectedIndex = 0, s.children().first().addClass(a)), e.isFunction(l) && l.call(this.element, s), s.show(), this.visible = !0, this.findBestHint()
		}
	}, findBestHint: function () {
		var t = this.el.val().toLowerCase(), n = null;
		t && (e.each(this.suggestions, function (e, r) {
			var i = 0 === r.value.toLowerCase().indexOf(t);
			return i && (n = r), !i
		}), this.signalHint(n))
	}, signalHint: function (t) {
		var n = "";
		t && (n = this.currentValue + t.value.substr(this.currentValue.length)), this.hintValue !== n && (this.hintValue = n, this.hint = t, (this.options.onHint || e.noop)(n))
	}, verifySuggestionsFormat: function (t) {
		return t.length && "string" == typeof t[0] ? e.map(t, function (e) {
			return{value: e, data: null}
		}) : t
	}, processResponse: function (e, t, n) {
		var r = this.options;
		e = r.transformResult(e, t), e.suggestions = this.verifySuggestionsFormat(e.suggestions), r.noCache || (this.cachedResponse[n] = e, 0 === e.suggestions.length && this.badQueries.push(n)), t === this.getQuery(this.currentValue) && (this.suggestions = e.suggestions, this.suggest())
	}, activate: function (t) {
		var n = this.classes.selected, r = e(this.suggestionsContainer), i = r.children();
		return r.children("." + n).removeClass(n), this.selectedIndex = t, -1 !== this.selectedIndex && i.length > this.selectedIndex ? (t = i.get(this.selectedIndex), e(t).addClass(n), t) : null
	}, selectHint: function () {
		var t = e.inArray(this.hint, this.suggestions);
		this.select(t)
	}, select: function (e) {
		this.hide(), this.onSelect(e)
	}, moveUp: function () {
		-1 !== this.selectedIndex && (0 === this.selectedIndex ? (e(this.suggestionsContainer).children().first().removeClass(this.classes.selected), this.selectedIndex = -1, this.el.val(this.currentValue), this.findBestHint()) : this.adjustScroll(this.selectedIndex - 1))
	}, moveDown: function () {
		this.selectedIndex !== this.suggestions.length - 1 && this.adjustScroll(this.selectedIndex + 1)
	}, adjustScroll: function (t) {
		var n, r, i = this.activate(t);
		i && (i = i.offsetTop, n = e(this.suggestionsContainer).scrollTop(), r = n + this.options.maxHeight - 25, n > i ? e(this.suggestionsContainer).scrollTop(i) : i > r && e(this.suggestionsContainer).scrollTop(i - this.options.maxHeight + 25), this.el.val(this.getValue(this.suggestions[t].value)), this.signalHint(null))
	}, onSelect: function (t) {
		var n = this.options.onSelect;
		t = this.suggestions[t], this.currentValue = this.getValue(t.value), this.el.val(this.currentValue), this.signalHint(null), this.suggestions = [], this.selection = t, e.isFunction(n) && n.call(this.element, t)
	}, getValue: function (e) {
		var t, n = this.options.delimiter;
		return n ? (t = this.currentValue, n = t.split(n), 1 === n.length ? e : t.substr(0, t.length - n[n.length - 1].length) + e) : e
	}, dispose: function () {
		this.el.off(".autocomplete").removeData("autocomplete"), this.disableKillerFn(), e(window).off("resize.autocomplete", this.fixPositionCapture), e(this.suggestionsContainer).remove()
	}}, e.fn.autocomplete = function (n, r) {
		return 0 === arguments.length ? this.first().data("autocomplete") : this.each(function () {
			var i = e(this), o = i.data("autocomplete");
			"string" == typeof n ? o && "function" == typeof o[n] && o[n](r) : (o && o.dispose && o.dispose(), o = new t(this, n), i.data("autocomplete", o))
		})
	}
}), !function () {
	function e(e, t) {
		return t > e ? -1 : e > t ? 1 : e >= t ? 0 : 0 / 0
	}

	function t(e) {
		return null != e && !isNaN(e)
	}

	function n(e) {
		return{left: function (t, n, r, i) {
			for (arguments.length < 3 && (r = 0), arguments.length < 4 && (i = t.length); i > r;) {
				var o = r + i >>> 1;
				e(t[o], n) < 0 ? r = o + 1 : i = o
			}
			return r
		}, right: function (t, n, r, i) {
			for (arguments.length < 3 && (r = 0), arguments.length < 4 && (i = t.length); i > r;) {
				var o = r + i >>> 1;
				e(t[o], n) > 0 ? i = o : r = o + 1
			}
			return r
		}}
	}

	function r(e) {
		return e.length
	}

	function i(e) {
		for (var t = 1; e * t % 1;)t *= 10;
		return t
	}

	function o(e, t) {
		try {
			for (var n in t)Object.defineProperty(e.prototype, n, {value: t[n], enumerable: !1})
		} catch (r) {
			e.prototype = t
		}
	}

	function a() {
	}

	function s(e) {
		return as + e in this
	}

	function l(e) {
		return e = as + e, e in this && delete this[e]
	}

	function u() {
		var e = [];
		return this.forEach(function (t) {
			e.push(t)
		}), e
	}

	function c() {
		var e = 0;
		for (var t in this)t.charCodeAt(0) === ss && ++e;
		return e
	}

	function h() {
		for (var e in this)if (e.charCodeAt(0) === ss)return!1;
		return!0
	}

	function f() {
	}

	function d(e, t, n) {
		return function () {
			var r = n.apply(t, arguments);
			return r === t ? e : r
		}
	}

	function p(e, t) {
		if (t in e)return t;
		t = t.charAt(0).toUpperCase() + t.substring(1);
		for (var n = 0, r = ls.length; r > n; ++n) {
			var i = ls[n] + t;
			if (i in e)return i
		}
	}

	function m() {
	}

	function g() {
	}

	function E(e) {
		function t() {
			for (var t, r = n, i = -1, o = r.length; ++i < o;)(t = r[i].on) && t.apply(this, arguments);
			return e
		}

		var n = [], r = new a;
		return t.on = function (t, i) {
			var o, a = r.get(t);
			return arguments.length < 2 ? a && a.on : (a && (a.on = null, n = n.slice(0, o = n.indexOf(a)).concat(n.slice(o + 1)), r.remove(t)), i && n.push(r.set(t, {on: i})), e)
		}, t
	}

	function v() {
		Ga.event.preventDefault()
	}

	function y() {
		for (var e, t = Ga.event; e = t.sourceEvent;)t = e;
		return t
	}

	function T(e) {
		for (var t = new g, n = 0, r = arguments.length; ++n < r;)t[arguments[n]] = E(t);
		return t.of = function (n, r) {
			return function (i) {
				try {
					var o = i.sourceEvent = Ga.event;
					i.target = e, Ga.event = i, t[i.type].apply(n, r)
				} finally {
					Ga.event = o
				}
			}
		}, t
	}

	function x(e) {
		return cs(e, ms), e
	}

	function R(e) {
		return"function" == typeof e ? e : function () {
			return hs(e, this)
		}
	}

	function b(e) {
		return"function" == typeof e ? e : function () {
			return fs(e, this)
		}
	}

	function _(e, t) {
		function n() {
			this.removeAttribute(e)
		}

		function r() {
			this.removeAttributeNS(e.space, e.local)
		}

		function i() {
			this.setAttribute(e, t)
		}

		function o() {
			this.setAttributeNS(e.space, e.local, t)
		}

		function a() {
			var n = t.apply(this, arguments);
			null == n ? this.removeAttribute(e) : this.setAttribute(e, n)
		}

		function s() {
			var n = t.apply(this, arguments);
			null == n ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n)
		}

		return e = Ga.ns.qualify(e), null == t ? e.local ? r : n : "function" == typeof t ? e.local ? s : a : e.local ? o : i
	}

	function w(e) {
		return e.trim().replace(/\s+/g, " ")
	}

	function H(e) {
		return new RegExp("(?:^|\\s+)" + Ga.requote(e) + "(?:\\s+|$)", "g")
	}

	function M(e) {
		return(e + "").trim().split(/^|\s+/)
	}

	function S(e, t) {
		function n() {
			for (var n = -1; ++n < i;)e[n](this, t)
		}

		function r() {
			for (var n = -1, r = t.apply(this, arguments); ++n < i;)e[n](this, r)
		}

		e = M(e).map(C);
		var i = e.length;
		return"function" == typeof t ? r : n
	}

	function C(e) {
		var t = H(e);
		return function (n, r) {
			if (i = n.classList)return r ? i.add(e) : i.remove(e);
			var i = n.getAttribute("class") || "";
			r ? (t.lastIndex = 0, t.test(i) || n.setAttribute("class", w(i + " " + e))) : n.setAttribute("class", w(i.replace(t, " ")))
		}
	}

	function A(e, t, n) {
		function r() {
			this.style.removeProperty(e)
		}

		function i() {
			this.style.setProperty(e, t, n)
		}

		function o() {
			var r = t.apply(this, arguments);
			null == r ? this.style.removeProperty(e) : this.style.setProperty(e, r, n)
		}

		return null == t ? r : "function" == typeof t ? o : i
	}

	function L(e, t) {
		function n() {
			delete this[e]
		}

		function r() {
			this[e] = t
		}

		function i() {
			var n = t.apply(this, arguments);
			null == n ? delete this[e] : this[e] = n
		}

		return null == t ? n : "function" == typeof t ? i : r
	}

	function k(e) {
		return"function" == typeof e ? e : (e = Ga.ns.qualify(e)).local ? function () {
			return this.ownerDocument.createElementNS(e.space, e.local)
		} : function () {
			return this.ownerDocument.createElementNS(this.namespaceURI, e)
		}
	}

	function P(e) {
		return{__data__: e}
	}

	function D(e) {
		return function () {
			return ps(this, e)
		}
	}

	function F(t) {
		return arguments.length || (t = e), function (e, n) {
			return e && n ? t(e.__data__, n.__data__) : !e - !n
		}
	}

	function N(e, t) {
		for (var n = 0, r = e.length; r > n; n++)for (var i, o = e[n], a = 0, s = o.length; s > a; a++)(i = o[a]) && t(i, a, n);
		return e
	}

	function z(e) {
		return cs(e, Es), e
	}

	function U(e) {
		var t, n;
		return function (r, i, o) {
			var a, s = e[o].update, l = s.length;
			for (o != n && (n = o, t = 0), i >= t && (t = i + 1); !(a = s[t]) && ++t < l;);
			return a
		}
	}

	function V() {
		var e = this.__transition__;
		e && ++e.active
	}

	function B(e, t, n) {
		function r() {
			var t = this[a];
			t && (this.removeEventListener(e, t, t.$), delete this[a])
		}

		function i() {
			var i = l(t, qa(arguments));
			r.call(this), this.addEventListener(e, this[a] = i, i.$ = n), i._ = t
		}

		function o() {
			var t, n = new RegExp("^__on([^.]+)" + Ga.requote(e) + "$");
			for (var r in this)if (t = r.match(n)) {
				var i = this[r];
				this.removeEventListener(t[1], i, i.$), delete this[r]
			}
		}

		var a = "__on" + e, s = e.indexOf("."), l = O;
		s > 0 && (e = e.substring(0, s));
		var u = ys.get(e);
		return u && (e = u, l = I), s ? t ? i : r : t ? m : o
	}

	function O(e, t) {
		return function (n) {
			var r = Ga.event;
			Ga.event = n, t[0] = this.__data__;
			try {
				e.apply(this, t)
			} finally {
				Ga.event = r
			}
		}
	}

	function I(e, t) {
		var n = O(e, t);
		return function (e) {
			var t = this, r = e.relatedTarget;
			r && (r === t || 8 & r.compareDocumentPosition(t)) || n.call(t, e)
		}
	}

	function j() {
		var e = ".dragsuppress-" + ++xs, t = "click" + e, n = Ga.select(Za).on("touchmove" + e, v).on("dragstart" + e, v).on("selectstart" + e, v);
		if (Ts) {
			var r = Ka.style, i = r[Ts];
			r[Ts] = "none"
		}
		return function (o) {
			function a() {
				n.on(t, null)
			}

			n.on(e, null), Ts && (r[Ts] = i), o && (n.on(t, function () {
				v(), a()
			}, !0), setTimeout(a, 0))
		}
	}

	function W(e, t) {
		t.changedTouches && (t = t.changedTouches[0]);
		var n = e.ownerSVGElement || e;
		if (n.createSVGPoint) {
			var r = n.createSVGPoint();
			if (0 > Rs && (Za.scrollX || Za.scrollY)) {
				n = Ga.select("body").append("svg").style({position: "absolute", top: 0, left: 0, margin: 0, padding: 0, border: "none"}, "important");
				var i = n[0][0].getScreenCTM();
				Rs = !(i.f || i.e), n.remove()
			}
			return Rs ? (r.x = t.pageX, r.y = t.pageY) : (r.x = t.clientX, r.y = t.clientY), r = r.matrixTransform(e.getScreenCTM().inverse()), [r.x, r.y]
		}
		var o = e.getBoundingClientRect();
		return[t.clientX - o.left - e.clientLeft, t.clientY - o.top - e.clientTop]
	}

	function G() {
		return Ga.event.changedTouches[0].identifier
	}

	function X() {
		return Ga.event.target
	}

	function q() {
		return Za
	}

	function Y(e) {
		return e > 0 ? 1 : 0 > e ? -1 : 0
	}

	function K(e, t, n) {
		return(t[0] - e[0]) * (n[1] - e[1]) - (t[1] - e[1]) * (n[0] - e[0])
	}

	function Z(e) {
		return e > 1 ? 0 : -1 > e ? bs : Math.acos(e)
	}

	function Q(e) {
		return e > 1 ? ws : -1 > e ? -ws : Math.asin(e)
	}

	function $(e) {
		return((e = Math.exp(e)) - 1 / e) / 2
	}

	function J(e) {
		return((e = Math.exp(e)) + 1 / e) / 2
	}

	function et(e) {
		return((e = Math.exp(2 * e)) - 1) / (e + 1)
	}

	function tt(e) {
		return(e = Math.sin(e / 2)) * e
	}

	function nt() {
	}

	function rt(e, t, n) {
		return this instanceof rt ? (this.h = +e, this.s = +t, void(this.l = +n)) : arguments.length < 2 ? e instanceof rt ? new rt(e.h, e.s, e.l) : Et("" + e, vt, rt) : new rt(e, t, n)
	}

	function it(e, t, n) {
		function r(e) {
			return e > 360 ? e -= 360 : 0 > e && (e += 360), 60 > e ? o + (a - o) * e / 60 : 180 > e ? a : 240 > e ? o + (a - o) * (240 - e) / 60 : o
		}

		function i(e) {
			return Math.round(255 * r(e))
		}

		var o, a;
		return e = isNaN(e) ? 0 : (e %= 360) < 0 ? e + 360 : e, t = isNaN(t) ? 0 : 0 > t ? 0 : t > 1 ? 1 : t, n = 0 > n ? 0 : n > 1 ? 1 : n, a = .5 >= n ? n * (1 + t) : n + t - n * t, o = 2 * n - a, new dt(i(e + 120), i(e), i(e - 120))
	}

	function ot(e, t, n) {
		return this instanceof ot ? (this.h = +e, this.c = +t, void(this.l = +n)) : arguments.length < 2 ? e instanceof ot ? new ot(e.h, e.c, e.l) : e instanceof st ? ut(e.l, e.a, e.b) : ut((e = yt((e = Ga.rgb(e)).r, e.g, e.b)).l, e.a, e.b) : new ot(e, t, n)
	}

	function at(e, t, n) {
		return isNaN(e) && (e = 0), isNaN(t) && (t = 0), new st(n, Math.cos(e *= Ss) * t, Math.sin(e) * t)
	}

	function st(e, t, n) {
		return this instanceof st ? (this.l = +e, this.a = +t, void(this.b = +n)) : arguments.length < 2 ? e instanceof st ? new st(e.l, e.a, e.b) : e instanceof ot ? at(e.l, e.c, e.h) : yt((e = dt(e)).r, e.g, e.b) : new st(e, t, n)
	}

	function lt(e, t, n) {
		var r = (e + 16) / 116, i = r + t / 500, o = r - n / 200;
		return i = ct(i) * Vs, r = ct(r) * Bs, o = ct(o) * Os, new dt(ft(3.2404542 * i - 1.5371385 * r - .4985314 * o), ft(-.969266 * i + 1.8760108 * r + .041556 * o), ft(.0556434 * i - .2040259 * r + 1.0572252 * o))
	}

	function ut(e, t, n) {
		return e > 0 ? new ot(Math.atan2(n, t) * Cs, Math.sqrt(t * t + n * n), e) : new ot(0 / 0, 0 / 0, e)
	}

	function ct(e) {
		return e > .206893034 ? e * e * e : (e - 4 / 29) / 7.787037
	}

	function ht(e) {
		return e > .008856 ? Math.pow(e, 1 / 3) : 7.787037 * e + 4 / 29
	}

	function ft(e) {
		return Math.round(255 * (.00304 >= e ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - .055))
	}

	function dt(e, t, n) {
		return this instanceof dt ? (this.r = ~~e, this.g = ~~t, void(this.b = ~~n)) : arguments.length < 2 ? e instanceof dt ? new dt(e.r, e.g, e.b) : Et("" + e, dt, it) : new dt(e, t, n)
	}

	function pt(e) {
		return new dt(e >> 16, 255 & e >> 8, 255 & e)
	}

	function mt(e) {
		return pt(e) + ""
	}

	function gt(e) {
		return 16 > e ? "0" + Math.max(0, e).toString(16) : Math.min(255, e).toString(16)
	}

	function Et(e, t, n) {
		var r, i, o, a = 0, s = 0, l = 0;
		if (r = /([a-z]+)\((.*)\)/i.exec(e))switch (i = r[2].split(","), r[1]) {
			case"hsl":
				return n(parseFloat(i[0]), parseFloat(i[1]) / 100, parseFloat(i[2]) / 100);
			case"rgb":
				return t(xt(i[0]), xt(i[1]), xt(i[2]))
		}
		return(o = Ws.get(e)) ? t(o.r, o.g, o.b) : (null == e || "#" !== e.charAt(0) || isNaN(o = parseInt(e.substring(1), 16)) || (4 === e.length ? (a = (3840 & o) >> 4, a = a >> 4 | a, s = 240 & o, s = s >> 4 | s, l = 15 & o, l = l << 4 | l) : 7 === e.length && (a = (16711680 & o) >> 16, s = (65280 & o) >> 8, l = 255 & o)), t(a, s, l))
	}

	function vt(e, t, n) {
		var r, i, o = Math.min(e /= 255, t /= 255, n /= 255), a = Math.max(e, t, n), s = a - o, l = (a + o) / 2;
		return s ? (i = .5 > l ? s / (a + o) : s / (2 - a - o), r = e == a ? (t - n) / s + (n > t ? 6 : 0) : t == a ? (n - e) / s + 2 : (e - t) / s + 4, r *= 60) : (r = 0 / 0, i = l > 0 && 1 > l ? 0 : r), new rt(r, i, l)
	}

	function yt(e, t, n) {
		e = Tt(e), t = Tt(t), n = Tt(n);
		var r = ht((.4124564 * e + .3575761 * t + .1804375 * n) / Vs), i = ht((.2126729 * e + .7151522 * t + .072175 * n) / Bs), o = ht((.0193339 * e + .119192 * t + .9503041 * n) / Os);
		return st(116 * i - 16, 500 * (r - i), 200 * (i - o))
	}

	function Tt(e) {
		return(e /= 255) <= .04045 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4)
	}

	function xt(e) {
		var t = parseFloat(e);
		return"%" === e.charAt(e.length - 1) ? Math.round(2.55 * t) : t
	}

	function Rt(e) {
		return"function" == typeof e ? e : function () {
			return e
		}
	}

	function bt(e) {
		return e
	}

	function _t(e) {
		return function (t, n, r) {
			return 2 === arguments.length && "function" == typeof n && (r = n, n = null), wt(t, n, e, r)
		}
	}

	function wt(e, t, n, r) {
		function i() {
			var e, t = l.status;
			if (!t && l.responseText || t >= 200 && 300 > t || 304 === t) {
				try {
					e = n.call(o, l)
				} catch (r) {
					return void a.error.call(o, r)
				}
				a.load.call(o, e)
			} else a.error.call(o, l)
		}

		var o = {}, a = Ga.dispatch("beforesend", "progress", "load", "error"), s = {}, l = new XMLHttpRequest, u = null;
		return!Za.XDomainRequest || "withCredentials"in l || !/^(http(s)?:)?\/\//.test(e) || (l = new XDomainRequest), "onload"in l ? l.onload = l.onerror = i : l.onreadystatechange = function () {
			l.readyState > 3 && i()
		}, l.onprogress = function (e) {
			var t = Ga.event;
			Ga.event = e;
			try {
				a.progress.call(o, l)
			} finally {
				Ga.event = t
			}
		}, o.header = function (e, t) {
			return e = (e + "").toLowerCase(), arguments.length < 2 ? s[e] : (null == t ? delete s[e] : s[e] = t + "", o)
		}, o.mimeType = function (e) {
			return arguments.length ? (t = null == e ? null : e + "", o) : t
		}, o.responseType = function (e) {
			return arguments.length ? (u = e, o) : u
		}, o.response = function (e) {
			return n = e, o
		}, ["get", "post"].forEach(function (e) {
			o[e] = function () {
				return o.send.apply(o, [e].concat(qa(arguments)))
			}
		}), o.send = function (n, r, i) {
			if (2 === arguments.length && "function" == typeof r && (i = r, r = null), l.open(n, e, !0), null == t || "accept"in s || (s.accept = t + ",*/*"), l.setRequestHeader)for (var c in s)l.setRequestHeader(c, s[c]);
			return null != t && l.overrideMimeType && l.overrideMimeType(t), null != u && (l.responseType = u), null != i && o.on("error", i).on("load", function (e) {
				i(null, e)
			}), a.beforesend.call(o, l), l.send(null == r ? null : r), o
		}, o.abort = function () {
			return l.abort(), o
		}, Ga.rebind(o, a, "on"), null == r ? o : o.get(Ht(r))
	}

	function Ht(e) {
		return 1 === e.length ? function (t, n) {
			e(null == t ? n : null)
		} : e
	}

	function Mt() {
		var e = St(), t = Ct() - e;
		t > 24 ? (isFinite(t) && (clearTimeout(Ys), Ys = setTimeout(Mt, t)), qs = 0) : (qs = 1, Zs(Mt))
	}

	function St() {
		var e = Date.now();
		for (Ks = Gs; Ks;)e >= Ks.t && (Ks.f = Ks.c(e - Ks.t)), Ks = Ks.n;
		return e
	}

	function Ct() {
		for (var e, t = Gs, n = 1 / 0; t;)t.f ? t = e ? e.n = t.n : Gs = t.n : (t.t < n && (n = t.t), t = (e = t).n);
		return Xs = e, n
	}

	function At(e, t) {
		return t - (e ? Math.ceil(Math.log(e) / Math.LN10) : 1)
	}

	function Lt(e, t) {
		var n = Math.pow(10, 3 * os(8 - t));
		return{scale: t > 8 ? function (e) {
			return e / n
		} : function (e) {
			return e * n
		}, symbol: e}
	}

	function kt(e) {
		var t = e.decimal, n = e.thousands, r = e.grouping, i = e.currency, o = r ? function (e) {
			for (var t = e.length, i = [], o = 0, a = r[0]; t > 0 && a > 0;)i.push(e.substring(t -= a, t + a)), a = r[o = (o + 1) % r.length];
			return i.reverse().join(n)
		} : bt;
		return function (e) {
			var n = $s.exec(e), r = n[1] || " ", a = n[2] || ">", s = n[3] || "", l = n[4] || "", u = n[5], c = +n[6], h = n[7], f = n[8], d = n[9], p = 1, m = "", g = "", E = !1;
			switch (f && (f = +f.substring(1)), (u || "0" === r && "=" === a) && (u = r = "0", a = "=", h && (c -= Math.floor((c - 1) / 4))), d) {
				case"n":
					h = !0, d = "g";
					break;
				case"%":
					p = 100, g = "%", d = "f";
					break;
				case"p":
					p = 100, g = "%", d = "r";
					break;
				case"b":
				case"o":
				case"x":
				case"X":
					"#" === l && (m = "0" + d.toLowerCase());
				case"c":
				case"d":
					E = !0, f = 0;
					break;
				case"s":
					p = -1, d = "r"
			}
			"$" === l && (m = i[0], g = i[1]), "r" != d || f || (d = "g"), null != f && ("g" == d ? f = Math.max(1, Math.min(21, f)) : ("e" == d || "f" == d) && (f = Math.max(0, Math.min(20, f)))), d = Js.get(d) || Pt;
			var v = u && h;
			return function (e) {
				var n = g;
				if (E && e % 1)return"";
				var i = 0 > e || 0 === e && 0 > 1 / e ? (e = -e, "-") : s;
				if (0 > p) {
					var l = Ga.formatPrefix(e, f);
					e = l.scale(e), n = l.symbol + g
				} else e *= p;
				e = d(e, f);
				var y = e.lastIndexOf("."), T = 0 > y ? e : e.substring(0, y), x = 0 > y ? "" : t + e.substring(y + 1);
				!u && h && (T = o(T));
				var R = m.length + T.length + x.length + (v ? 0 : i.length), b = c > R ? new Array(R = c - R + 1).join(r) : "";
				return v && (T = o(b + T)), i += m, e = T + x, ("<" === a ? i + e + b : ">" === a ? b + i + e : "^" === a ? b.substring(0, R >>= 1) + i + e + b.substring(R) : i + (v ? e : b + e)) + n
			}
		}
	}

	function Pt(e) {
		return e + ""
	}

	function Dt() {
		this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0])
	}

	function Ft(e, t, n) {
		function r(t) {
			var n = e(t), r = o(n, 1);
			return r - t > t - n ? n : r
		}

		function i(n) {
			return t(n = e(new tl(n - 1)), 1), n
		}

		function o(e, n) {
			return t(e = new tl(+e), n), e
		}

		function a(e, r, o) {
			var a = i(e), s = [];
			if (o > 1)for (; r > a;)n(a) % o || s.push(new Date(+a)), t(a, 1); else for (; r > a;)s.push(new Date(+a)), t(a, 1);
			return s
		}

		function s(e, t, n) {
			try {
				tl = Dt;
				var r = new Dt;
				return r._ = e, a(r, t, n)
			} finally {
				tl = Date
			}
		}

		e.floor = e, e.round = r, e.ceil = i, e.offset = o, e.range = a;
		var l = e.utc = Nt(e);
		return l.floor = l, l.round = Nt(r), l.ceil = Nt(i), l.offset = Nt(o), l.range = s, e
	}

	function Nt(e) {
		return function (t, n) {
			try {
				tl = Dt;
				var r = new Dt;
				return r._ = t, e(r, n)._
			} finally {
				tl = Date
			}
		}
	}

	function zt(e) {
		function t(e) {
			function t(t) {
				for (var n, i, o, a = [], s = -1, l = 0; ++s < r;)37 === e.charCodeAt(s) && (a.push(e.substring(l, s)), null != (i = rl[n = e.charAt(++s)]) && (n = e.charAt(++s)), (o = S[n]) && (n = o(t, null == i ? "e" === n ? " " : "0" : i)), a.push(n), l = s + 1);
				return a.push(e.substring(l, s)), a.join("")
			}

			var r = e.length;
			return t.parse = function (t) {
				var r = {y: 1900, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0, Z: null}, i = n(r, e, t, 0);
				if (i != t.length)return null;
				"p"in r && (r.H = r.H % 12 + 12 * r.p);
				var o = null != r.Z && tl !== Dt, a = new (o ? Dt : tl);
				return"j"in r ? a.setFullYear(r.y, 0, r.j) : "w"in r && ("W"in r || "U"in r) ? (a.setFullYear(r.y, 0, 1), a.setFullYear(r.y, 0, "W"in r ? (r.w + 6) % 7 + 7 * r.W - (a.getDay() + 5) % 7 : r.w + 7 * r.U - (a.getDay() + 6) % 7)) : a.setFullYear(r.y, r.m, r.d), a.setHours(r.H + Math.floor(r.Z / 100), r.M + r.Z % 100, r.S, r.L), o ? a._ : a
			}, t.toString = function () {
				return e
			}, t
		}

		function n(e, t, n, r) {
			for (var i, o, a, s = 0, l = t.length, u = n.length; l > s;) {
				if (r >= u)return-1;
				if (i = t.charCodeAt(s++), 37 === i) {
					if (a = t.charAt(s++), o = C[a in rl ? t.charAt(s++) : a], !o || (r = o(e, n, r)) < 0)return-1
				} else if (i != n.charCodeAt(r++))return-1
			}
			return r
		}

		function r(e, t, n) {
			R.lastIndex = 0;
			var r = R.exec(t.substring(n));
			return r ? (e.w = b.get(r[0].toLowerCase()), n + r[0].length) : -1
		}

		function i(e, t, n) {
			T.lastIndex = 0;
			var r = T.exec(t.substring(n));
			return r ? (e.w = x.get(r[0].toLowerCase()), n + r[0].length) : -1
		}

		function o(e, t, n) {
			H.lastIndex = 0;
			var r = H.exec(t.substring(n));
			return r ? (e.m = M.get(r[0].toLowerCase()), n + r[0].length) : -1
		}

		function a(e, t, n) {
			_.lastIndex = 0;
			var r = _.exec(t.substring(n));
			return r ? (e.m = w.get(r[0].toLowerCase()), n + r[0].length) : -1
		}

		function s(e, t, r) {
			return n(e, S.c.toString(), t, r)
		}

		function l(e, t, r) {
			return n(e, S.x.toString(), t, r)
		}

		function u(e, t, r) {
			return n(e, S.X.toString(), t, r)
		}

		function c(e, t, n) {
			var r = y.get(t.substring(n, n += 2).toLowerCase());
			return null == r ? -1 : (e.p = r, n)
		}

		var h = e.dateTime, f = e.date, d = e.time, p = e.periods, m = e.days, g = e.shortDays, E = e.months, v = e.shortMonths;
		t.utc = function (e) {
			function n(e) {
				try {
					tl = Dt;
					var t = new tl;
					return t._ = e, r(t)
				} finally {
					tl = Date
				}
			}

			var r = t(e);
			return n.parse = function (e) {
				try {
					tl = Dt;
					var t = r.parse(e);
					return t && t._
				} finally {
					tl = Date
				}
			}, n.toString = r.toString, n
		}, t.multi = t.utc.multi = rn;
		var y = Ga.map(), T = Vt(m), x = Bt(m), R = Vt(g), b = Bt(g), _ = Vt(E), w = Bt(E), H = Vt(v), M = Bt(v);
		p.forEach(function (e, t) {
			y.set(e.toLowerCase(), t)
		});
		var S = {a: function (e) {
			return g[e.getDay()]
		}, A: function (e) {
			return m[e.getDay()]
		}, b: function (e) {
			return v[e.getMonth()]
		}, B: function (e) {
			return E[e.getMonth()]
		}, c: t(h), d: function (e, t) {
			return Ut(e.getDate(), t, 2)
		}, e: function (e, t) {
			return Ut(e.getDate(), t, 2)
		}, H: function (e, t) {
			return Ut(e.getHours(), t, 2)
		}, I: function (e, t) {
			return Ut(e.getHours() % 12 || 12, t, 2)
		}, j: function (e, t) {
			return Ut(1 + el.dayOfYear(e), t, 3)
		}, L: function (e, t) {
			return Ut(e.getMilliseconds(), t, 3)
		}, m: function (e, t) {
			return Ut(e.getMonth() + 1, t, 2)
		}, M: function (e, t) {
			return Ut(e.getMinutes(), t, 2)
		}, p: function (e) {
			return p[+(e.getHours() >= 12)]
		}, S: function (e, t) {
			return Ut(e.getSeconds(), t, 2)
		}, U: function (e, t) {
			return Ut(el.sundayOfYear(e), t, 2)
		}, w: function (e) {
			return e.getDay()
		}, W: function (e, t) {
			return Ut(el.mondayOfYear(e), t, 2)
		}, x: t(f), X: t(d), y: function (e, t) {
			return Ut(e.getFullYear() % 100, t, 2)
		}, Y: function (e, t) {
			return Ut(e.getFullYear() % 1e4, t, 4)
		}, Z: tn, "%": function () {
			return"%"
		}}, C = {a: r, A: i, b: o, B: a, c: s, d: Kt, e: Kt, H: Qt, I: Qt, j: Zt, L: en, m: Yt, M: $t, p: c, S: Jt, U: It, w: Ot, W: jt, x: l, X: u, y: Gt, Y: Wt, Z: Xt, "%": nn};
		return t
	}

	function Ut(e, t, n) {
		var r = 0 > e ? "-" : "", i = (r ? -e : e) + "", o = i.length;
		return r + (n > o ? new Array(n - o + 1).join(t) + i : i)
	}

	function Vt(e) {
		return new RegExp("^(?:" + e.map(Ga.requote).join("|") + ")", "i")
	}

	function Bt(e) {
		for (var t = new a, n = -1, r = e.length; ++n < r;)t.set(e[n].toLowerCase(), n);
		return t
	}

	function Ot(e, t, n) {
		il.lastIndex = 0;
		var r = il.exec(t.substring(n, n + 1));
		return r ? (e.w = +r[0], n + r[0].length) : -1
	}

	function It(e, t, n) {
		il.lastIndex = 0;
		var r = il.exec(t.substring(n));
		return r ? (e.U = +r[0], n + r[0].length) : -1
	}

	function jt(e, t, n) {
		il.lastIndex = 0;
		var r = il.exec(t.substring(n));
		return r ? (e.W = +r[0], n + r[0].length) : -1
	}

	function Wt(e, t, n) {
		il.lastIndex = 0;
		var r = il.exec(t.substring(n, n + 4));
		return r ? (e.y = +r[0], n + r[0].length) : -1
	}

	function Gt(e, t, n) {
		il.lastIndex = 0;
		var r = il.exec(t.substring(n, n + 2));
		return r ? (e.y = qt(+r[0]), n + r[0].length) : -1
	}

	function Xt(e, t, n) {
		return/^[+-]\d{4}$/.test(t = t.substring(n, n + 5)) ? (e.Z = -t, n + 5) : -1
	}

	function qt(e) {
		return e + (e > 68 ? 1900 : 2e3)
	}

	function Yt(e, t, n) {
		il.lastIndex = 0;
		var r = il.exec(t.substring(n, n + 2));
		return r ? (e.m = r[0] - 1, n + r[0].length) : -1
	}

	function Kt(e, t, n) {
		il.lastIndex = 0;
		var r = il.exec(t.substring(n, n + 2));
		return r ? (e.d = +r[0], n + r[0].length) : -1
	}

	function Zt(e, t, n) {
		il.lastIndex = 0;
		var r = il.exec(t.substring(n, n + 3));
		return r ? (e.j = +r[0], n + r[0].length) : -1
	}

	function Qt(e, t, n) {
		il.lastIndex = 0;
		var r = il.exec(t.substring(n, n + 2));
		return r ? (e.H = +r[0], n + r[0].length) : -1
	}

	function $t(e, t, n) {
		il.lastIndex = 0;
		var r = il.exec(t.substring(n, n + 2));
		return r ? (e.M = +r[0], n + r[0].length) : -1
	}

	function Jt(e, t, n) {
		il.lastIndex = 0;
		var r = il.exec(t.substring(n, n + 2));
		return r ? (e.S = +r[0], n + r[0].length) : -1
	}

	function en(e, t, n) {
		il.lastIndex = 0;
		var r = il.exec(t.substring(n, n + 3));
		return r ? (e.L = +r[0], n + r[0].length) : -1
	}

	function tn(e) {
		var t = e.getTimezoneOffset(), n = t > 0 ? "-" : "+", r = ~~(os(t) / 60), i = os(t) % 60;
		return n + Ut(r, "0", 2) + Ut(i, "0", 2)
	}

	function nn(e, t, n) {
		ol.lastIndex = 0;
		var r = ol.exec(t.substring(n, n + 1));
		return r ? n + r[0].length : -1
	}

	function rn(e) {
		for (var t = e.length, n = -1; ++n < t;)e[n][0] = this(e[n][0]);
		return function (t) {
			for (var n = 0, r = e[n]; !r[1](t);)r = e[++n];
			return r[0](t)
		}
	}

	function on() {
	}

	function an(e, t, n) {
		var r = n.s = e + t, i = r - e, o = r - i;
		n.t = e - o + (t - i)
	}

	function sn(e, t) {
		e && ul.hasOwnProperty(e.type) && ul[e.type](e, t)
	}

	function ln(e, t, n) {
		var r, i = -1, o = e.length - n;
		for (t.lineStart(); ++i < o;)r = e[i], t.point(r[0], r[1], r[2]);
		t.lineEnd()
	}

	function un(e, t) {
		var n = -1, r = e.length;
		for (t.polygonStart(); ++n < r;)ln(e[n], t, 1);
		t.polygonEnd()
	}

	function cn() {
		function e(e, t) {
			e *= Ss, t = t * Ss / 2 + bs / 4;
			var n = e - r, a = n >= 0 ? 1 : -1, s = a * n, l = Math.cos(t), u = Math.sin(t), c = o * u, h = i * l + c * Math.cos(s), f = c * a * Math.sin(s);
			hl.add(Math.atan2(f, h)), r = e, i = l, o = u
		}

		var t, n, r, i, o;
		fl.point = function (a, s) {
			fl.point = e, r = (t = a) * Ss, i = Math.cos(s = (n = s) * Ss / 2 + bs / 4), o = Math.sin(s)
		}, fl.lineEnd = function () {
			e(t, n)
		}
	}

	function hn(e) {
		var t = e[0], n = e[1], r = Math.cos(n);
		return[r * Math.cos(t), r * Math.sin(t), Math.sin(n)]
	}

	function fn(e, t) {
		return e[0] * t[0] + e[1] * t[1] + e[2] * t[2]
	}

	function dn(e, t) {
		return[e[1] * t[2] - e[2] * t[1], e[2] * t[0] - e[0] * t[2], e[0] * t[1] - e[1] * t[0]]
	}

	function pn(e, t) {
		e[0] += t[0], e[1] += t[1], e[2] += t[2]
	}

	function mn(e, t) {
		return[e[0] * t, e[1] * t, e[2] * t]
	}

	function gn(e) {
		var t = Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
		e[0] /= t, e[1] /= t, e[2] /= t
	}

	function En(e) {
		return[Math.atan2(e[1], e[0]), Q(e[2])]
	}

	function vn(e, t) {
		return os(e[0] - t[0]) < Hs && os(e[1] - t[1]) < Hs
	}

	function yn(e, t) {
		e *= Ss;
		var n = Math.cos(t *= Ss);
		Tn(n * Math.cos(e), n * Math.sin(e), Math.sin(t))
	}

	function Tn(e, t, n) {
		++dl, ml += (e - ml) / dl, gl += (t - gl) / dl, El += (n - El) / dl
	}

	function xn() {
		function e(e, i) {
			e *= Ss;
			var o = Math.cos(i *= Ss), a = o * Math.cos(e), s = o * Math.sin(e), l = Math.sin(i), u = Math.atan2(Math.sqrt((u = n * l - r * s) * u + (u = r * a - t * l) * u + (u = t * s - n * a) * u), t * a + n * s + r * l);
			pl += u, vl += u * (t + (t = a)), yl += u * (n + (n = s)), Tl += u * (r + (r = l)), Tn(t, n, r)
		}

		var t, n, r;
		_l.point = function (i, o) {
			i *= Ss;
			var a = Math.cos(o *= Ss);
			t = a * Math.cos(i), n = a * Math.sin(i), r = Math.sin(o), _l.point = e, Tn(t, n, r)
		}
	}

	function Rn() {
		_l.point = yn
	}

	function bn() {
		function e(e, t) {
			e *= Ss;
			var n = Math.cos(t *= Ss), a = n * Math.cos(e), s = n * Math.sin(e), l = Math.sin(t), u = i * l - o * s, c = o * a - r * l, h = r * s - i * a, f = Math.sqrt(u * u + c * c + h * h), d = r * a + i * s + o * l, p = f && -Z(d) / f, m = Math.atan2(f, d);
			xl += p * u, Rl += p * c, bl += p * h, pl += m, vl += m * (r + (r = a)), yl += m * (i + (i = s)), Tl += m * (o + (o = l)), Tn(r, i, o)
		}

		var t, n, r, i, o;
		_l.point = function (a, s) {
			t = a, n = s, _l.point = e, a *= Ss;
			var l = Math.cos(s *= Ss);
			r = l * Math.cos(a), i = l * Math.sin(a), o = Math.sin(s), Tn(r, i, o)
		}, _l.lineEnd = function () {
			e(t, n), _l.lineEnd = Rn, _l.point = yn
		}
	}

	function _n() {
		return!0
	}

	function wn(e, t, n, r, i) {
		var o = [], a = [];
		if (e.forEach(function (e) {
			if (!((t = e.length - 1) <= 0)) {
				var t, n = e[0], r = e[t];
				if (vn(n, r)) {
					i.lineStart();
					for (var s = 0; t > s; ++s)i.point((n = e[s])[0], n[1]);
					return void i.lineEnd()
				}
				var l = new Mn(n, e, null, !0), u = new Mn(n, null, l, !1);
				l.o = u, o.push(l), a.push(u), l = new Mn(r, e, null, !1), u = new Mn(r, null, l, !0), l.o = u, o.push(l), a.push(u)
			}
		}), a.sort(t), Hn(o), Hn(a), o.length) {
			for (var s = 0, l = n, u = a.length; u > s; ++s)a[s].e = l = !l;
			for (var c, h, f = o[0]; ;) {
				for (var d = f, p = !0; d.v;)if ((d = d.n) === f)return;
				c = d.z, i.lineStart();
				do {
					if (d.v = d.o.v = !0, d.e) {
						if (p)for (var s = 0, u = c.length; u > s; ++s)i.point((h = c[s])[0], h[1]); else r(d.x, d.n.x, 1, i);
						d = d.n
					} else {
						if (p) {
							c = d.p.z;
							for (var s = c.length - 1; s >= 0; --s)i.point((h = c[s])[0], h[1])
						} else r(d.x, d.p.x, -1, i);
						d = d.p
					}
					d = d.o, c = d.z, p = !p
				} while (!d.v);
				i.lineEnd()
			}
		}
	}

	function Hn(e) {
		if (t = e.length) {
			for (var t, n, r = 0, i = e[0]; ++r < t;)i.n = n = e[r], n.p = i, i = n;
			i.n = n = e[0], n.p = i
		}
	}

	function Mn(e, t, n, r) {
		this.x = e, this.z = t, this.o = n, this.e = r, this.v = !1, this.n = this.p = null
	}

	function Sn(e, t, n, r) {
		return function (i, o) {
			function a(t, n) {
				var r = i(t, n);
				e(t = r[0], n = r[1]) && o.point(t, n)
			}

			function s(e, t) {
				var n = i(e, t);
				g.point(n[0], n[1])
			}

			function l() {
				v.point = s, g.lineStart()
			}

			function u() {
				v.point = a, g.lineEnd()
			}

			function c(e, t) {
				m.push([e, t]);
				var n = i(e, t);
				T.point(n[0], n[1])
			}

			function h() {
				T.lineStart(), m = []
			}

			function f() {
				c(m[0][0], m[0][1]), T.lineEnd();
				var e, t = T.clean(), n = y.buffer(), r = n.length;
				if (m.pop(), p.push(m), m = null, r)if (1 & t) {
					e = n[0];
					var i, r = e.length - 1, a = -1;
					if (r > 0) {
						for (x || (o.polygonStart(), x = !0), o.lineStart(); ++a < r;)o.point((i = e[a])[0], i[1]);
						o.lineEnd()
					}
				} else r > 1 && 2 & t && n.push(n.pop().concat(n.shift())), d.push(n.filter(Cn))
			}

			var d, p, m, g = t(o), E = i.invert(r[0], r[1]), v = {point: a, lineStart: l, lineEnd: u, polygonStart: function () {
				v.point = c, v.lineStart = h, v.lineEnd = f, d = [], p = []
			}, polygonEnd: function () {
				v.point = a, v.lineStart = l, v.lineEnd = u, d = Ga.merge(d);
				var e = kn(E, p);
				d.length ? (x || (o.polygonStart(), x = !0), wn(d, Ln, e, n, o)) : e && (x || (o.polygonStart(), x = !0), o.lineStart(), n(null, null, 1, o), o.lineEnd()), x && (o.polygonEnd(), x = !1), d = p = null
			}, sphere: function () {
				o.polygonStart(), o.lineStart(), n(null, null, 1, o), o.lineEnd(), o.polygonEnd()
			}}, y = An(), T = t(y), x = !1;
			return v
		}
	}

	function Cn(e) {
		return e.length > 1
	}

	function An() {
		var e, t = [];
		return{lineStart: function () {
			t.push(e = [])
		}, point: function (t, n) {
			e.push([t, n])
		}, lineEnd: m, buffer: function () {
			var n = t;
			return t = [], e = null, n
		}, rejoin: function () {
			t.length > 1 && t.push(t.pop().concat(t.shift()))
		}}
	}

	function Ln(e, t) {
		return((e = e.x)[0] < 0 ? e[1] - ws - Hs : ws - e[1]) - ((t = t.x)[0] < 0 ? t[1] - ws - Hs : ws - t[1])
	}

	function kn(e, t) {
		var n = e[0], r = e[1], i = [Math.sin(n), -Math.cos(n), 0], o = 0, a = 0;
		hl.reset();
		for (var s = 0, l = t.length; l > s; ++s) {
			var u = t[s], c = u.length;
			if (c)for (var h = u[0], f = h[0], d = h[1] / 2 + bs / 4, p = Math.sin(d), m = Math.cos(d), g = 1; ;) {
				g === c && (g = 0), e = u[g];
				var E = e[0], v = e[1] / 2 + bs / 4, y = Math.sin(v), T = Math.cos(v), x = E - f, R = x >= 0 ? 1 : -1, b = R * x, _ = b > bs, w = p * y;
				if (hl.add(Math.atan2(w * R * Math.sin(b), m * T + w * Math.cos(b))), o += _ ? x + R * _s : x, _ ^ f >= n ^ E >= n) {
					var H = dn(hn(h), hn(e));
					gn(H);
					var M = dn(i, H);
					gn(M);
					var S = (_ ^ x >= 0 ? -1 : 1) * Q(M[2]);
					(r > S || r === S && (H[0] || H[1])) && (a += _ ^ x >= 0 ? 1 : -1)
				}
				if (!g++)break;
				f = E, p = y, m = T, h = e
			}
		}
		return(-Hs > o || Hs > o && 0 > hl) ^ 1 & a
	}

	function Pn(e) {
		var t, n = 0 / 0, r = 0 / 0, i = 0 / 0;
		return{lineStart: function () {
			e.lineStart(), t = 1
		}, point: function (o, a) {
			var s = o > 0 ? bs : -bs, l = os(o - n);
			os(l - bs) < Hs ? (e.point(n, r = (r + a) / 2 > 0 ? ws : -ws), e.point(i, r), e.lineEnd(), e.lineStart(), e.point(s, r), e.point(o, r), t = 0) : i !== s && l >= bs && (os(n - i) < Hs && (n -= i * Hs), os(o - s) < Hs && (o -= s * Hs), r = Dn(n, r, o, a), e.point(i, r), e.lineEnd(), e.lineStart(), e.point(s, r), t = 0), e.point(n = o, r = a), i = s
		}, lineEnd: function () {
			e.lineEnd(), n = r = 0 / 0
		}, clean: function () {
			return 2 - t
		}}
	}

	function Dn(e, t, n, r) {
		var i, o, a = Math.sin(e - n);
		return os(a) > Hs ? Math.atan((Math.sin(t) * (o = Math.cos(r)) * Math.sin(n) - Math.sin(r) * (i = Math.cos(t)) * Math.sin(e)) / (i * o * a)) : (t + r) / 2
	}

	function Fn(e, t, n, r) {
		var i;
		if (null == e)i = n * ws, r.point(-bs, i), r.point(0, i), r.point(bs, i), r.point(bs, 0), r.point(bs, -i), r.point(0, -i), r.point(-bs, -i), r.point(-bs, 0), r.point(-bs, i); else if (os(e[0] - t[0]) > Hs) {
			var o = e[0] < t[0] ? bs : -bs;
			i = n * o / 2, r.point(-o, i), r.point(0, i), r.point(o, i)
		} else r.point(t[0], t[1])
	}

	function Nn(e) {
		function t(e, t) {
			return Math.cos(e) * Math.cos(t) > o
		}

		function n(e) {
			var n, o, l, u, c;
			return{lineStart: function () {
				u = l = !1, c = 1
			}, point: function (h, f) {
				var d, p = [h, f], m = t(h, f), g = a ? m ? 0 : i(h, f) : m ? i(h + (0 > h ? bs : -bs), f) : 0;
				if (!n && (u = l = m) && e.lineStart(), m !== l && (d = r(n, p), (vn(n, d) || vn(p, d)) && (p[0] += Hs, p[1] += Hs, m = t(p[0], p[1]))), m !== l)c = 0, m ? (e.lineStart(), d = r(p, n), e.point(d[0], d[1])) : (d = r(n, p), e.point(d[0], d[1]), e.lineEnd()), n = d; else if (s && n && a ^ m) {
					var E;
					g & o || !(E = r(p, n, !0)) || (c = 0, a ? (e.lineStart(), e.point(E[0][0], E[0][1]), e.point(E[1][0], E[1][1]), e.lineEnd()) : (e.point(E[1][0], E[1][1]), e.lineEnd(), e.lineStart(), e.point(E[0][0], E[0][1])))
				}
				!m || n && vn(n, p) || e.point(p[0], p[1]), n = p, l = m, o = g
			}, lineEnd: function () {
				l && e.lineEnd(), n = null
			}, clean: function () {
				return c | (u && l) << 1
			}}
		}

		function r(e, t, n) {
			var r = hn(e), i = hn(t), a = [1, 0, 0], s = dn(r, i), l = fn(s, s), u = s[0], c = l - u * u;
			if (!c)return!n && e;
			var h = o * l / c, f = -o * u / c, d = dn(a, s), p = mn(a, h), m = mn(s, f);
			pn(p, m);
			var g = d, E = fn(p, g), v = fn(g, g), y = E * E - v * (fn(p, p) - 1);
			if (!(0 > y)) {
				var T = Math.sqrt(y), x = mn(g, (-E - T) / v);
				if (pn(x, p), x = En(x), !n)return x;
				var R, b = e[0], _ = t[0], w = e[1], H = t[1];
				b > _ && (R = b, b = _, _ = R);
				var M = _ - b, S = os(M - bs) < Hs, C = S || Hs > M;
				if (!S && w > H && (R = w, w = H, H = R), C ? S ? w + H > 0 ^ x[1] < (os(x[0] - b) < Hs ? w : H) : w <= x[1] && x[1] <= H : M > bs ^ (b <= x[0] && x[0] <= _)) {
					var A = mn(g, (-E + T) / v);
					return pn(A, p), [x, En(A)]
				}
			}
		}

		function i(t, n) {
			var r = a ? e : bs - e, i = 0;
			return-r > t ? i |= 1 : t > r && (i |= 2), -r > n ? i |= 4 : n > r && (i |= 8), i
		}

		var o = Math.cos(e), a = o > 0, s = os(o) > Hs, l = cr(e, 6 * Ss);
		return Sn(t, n, l, a ? [0, -e] : [-bs, e - bs])
	}

	function zn(e, t, n, r) {
		return function (i) {
			var o, a = i.a, s = i.b, l = a.x, u = a.y, c = s.x, h = s.y, f = 0, d = 1, p = c - l, m = h - u;
			if (o = e - l, p || !(o > 0)) {
				if (o /= p, 0 > p) {
					if (f > o)return;
					d > o && (d = o)
				} else if (p > 0) {
					if (o > d)return;
					o > f && (f = o)
				}
				if (o = n - l, p || !(0 > o)) {
					if (o /= p, 0 > p) {
						if (o > d)return;
						o > f && (f = o)
					} else if (p > 0) {
						if (f > o)return;
						d > o && (d = o)
					}
					if (o = t - u, m || !(o > 0)) {
						if (o /= m, 0 > m) {
							if (f > o)return;
							d > o && (d = o)
						} else if (m > 0) {
							if (o > d)return;
							o > f && (f = o)
						}
						if (o = r - u, m || !(0 > o)) {
							if (o /= m, 0 > m) {
								if (o > d)return;
								o > f && (f = o)
							} else if (m > 0) {
								if (f > o)return;
								d > o && (d = o)
							}
							return f > 0 && (i.a = {x: l + f * p, y: u + f * m}), 1 > d && (i.b = {x: l + d * p, y: u + d * m}), i
						}
					}
				}
			}
		}
	}

	function Un(e, t, n, r) {
		function i(r, i) {
			return os(r[0] - e) < Hs ? i > 0 ? 0 : 3 : os(r[0] - n) < Hs ? i > 0 ? 2 : 1 : os(r[1] - t) < Hs ? i > 0 ? 1 : 0 : i > 0 ? 3 : 2
		}

		function o(e, t) {
			return a(e.x, t.x)
		}

		function a(e, t) {
			var n = i(e, 1), r = i(t, 1);
			return n !== r ? n - r : 0 === n ? t[1] - e[1] : 1 === n ? e[0] - t[0] : 2 === n ? e[1] - t[1] : t[0] - e[0]
		}

		return function (s) {
			function l(e) {
				for (var t = 0, n = g.length, r = e[1], i = 0; n > i; ++i)for (var o, a = 1, s = g[i], l = s.length, u = s[0]; l > a; ++a)o = s[a], u[1] <= r ? o[1] > r && K(u, o, e) > 0 && ++t : o[1] <= r && K(u, o, e) < 0 && --t, u = o;
				return 0 !== t
			}

			function u(o, s, l, u) {
				var c = 0, h = 0;
				if (null == o || (c = i(o, l)) !== (h = i(s, l)) || a(o, s) < 0 ^ l > 0) {
					do u.point(0 === c || 3 === c ? e : n, c > 1 ? r : t); while ((c = (c + l + 4) % 4) !== h)
				} else u.point(s[0], s[1])
			}

			function c(i, o) {
				return i >= e && n >= i && o >= t && r >= o
			}

			function h(e, t) {
				c(e, t) && s.point(e, t)
			}

			function f() {
				C.point = p, g && g.push(E = []), _ = !0, b = !1, x = R = 0 / 0
			}

			function d() {
				m && (p(v, y), T && b && M.rejoin(), m.push(M.buffer())), C.point = h, b && s.lineEnd()
			}

			function p(e, t) {
				e = Math.max(-Hl, Math.min(Hl, e)), t = Math.max(-Hl, Math.min(Hl, t));
				var n = c(e, t);
				if (g && E.push([e, t]), _)v = e, y = t, T = n, _ = !1, n && (s.lineStart(), s.point(e, t)); else if (n && b)s.point(e, t); else {
					var r = {a: {x: x, y: R}, b: {x: e, y: t}};
					S(r) ? (b || (s.lineStart(), s.point(r.a.x, r.a.y)), s.point(r.b.x, r.b.y), n || s.lineEnd(), w = !1) : n && (s.lineStart(), s.point(e, t), w = !1)
				}
				x = e, R = t, b = n
			}

			var m, g, E, v, y, T, x, R, b, _, w, H = s, M = An(), S = zn(e, t, n, r), C = {point: h, lineStart: f, lineEnd: d, polygonStart: function () {
				s = M, m = [], g = [], w = !0
			}, polygonEnd: function () {
				s = H, m = Ga.merge(m);
				var t = l([e, r]), n = w && t, i = m.length;
				(n || i) && (s.polygonStart(), n && (s.lineStart(), u(null, null, 1, s), s.lineEnd()), i && wn(m, o, t, u, s), s.polygonEnd()), m = g = E = null
			}};
			return C
		}
	}

	function Vn(e, t) {
		function n(n, r) {
			return n = e(n, r), t(n[0], n[1])
		}

		return e.invert && t.invert && (n.invert = function (n, r) {
			return n = t.invert(n, r), n && e.invert(n[0], n[1])
		}), n
	}

	function Bn(e) {
		var t = 0, n = bs / 3, r = nr(e), i = r(t, n);
		return i.parallels = function (e) {
			return arguments.length ? r(t = e[0] * bs / 180, n = e[1] * bs / 180) : [180 * (t / bs), 180 * (n / bs)]
		}, i
	}

	function On(e, t) {
		function n(e, t) {
			var n = Math.sqrt(o - 2 * i * Math.sin(t)) / i;
			return[n * Math.sin(e *= i), a - n * Math.cos(e)]
		}

		var r = Math.sin(e), i = (r + Math.sin(t)) / 2, o = 1 + r * (2 * i - r), a = Math.sqrt(o) / i;
		return n.invert = function (e, t) {
			var n = a - t;
			return[Math.atan2(e, n) / i, Q((o - (e * e + n * n) * i * i) / (2 * i))]
		}, n
	}

	function In() {
		function e(e, t) {
			Sl += i * e - r * t, r = e, i = t
		}

		var t, n, r, i;
		Pl.point = function (o, a) {
			Pl.point = e, t = r = o, n = i = a
		}, Pl.lineEnd = function () {
			e(t, n)
		}
	}

	function jn(e, t) {
		Cl > e && (Cl = e), e > Ll && (Ll = e), Al > t && (Al = t), t > kl && (kl = t)
	}

	function Wn() {
		function e(e, t) {
			a.push("M", e, ",", t, o)
		}

		function t(e, t) {
			a.push("M", e, ",", t), s.point = n
		}

		function n(e, t) {
			a.push("L", e, ",", t)
		}

		function r() {
			s.point = e
		}

		function i() {
			a.push("Z")
		}

		var o = Gn(4.5), a = [], s = {point: e, lineStart: function () {
			s.point = t
		}, lineEnd: r, polygonStart: function () {
			s.lineEnd = i
		}, polygonEnd: function () {
			s.lineEnd = r, s.point = e
		}, pointRadius: function (e) {
			return o = Gn(e), s
		}, result: function () {
			if (a.length) {
				var e = a.join("");
				return a = [], e
			}
		}};
		return s
	}

	function Gn(e) {
		return"m0," + e + "a" + e + "," + e + " 0 1,1 0," + -2 * e + "a" + e + "," + e + " 0 1,1 0," + 2 * e + "z"
	}

	function Xn(e, t) {
		ml += e, gl += t, ++El
	}

	function qn() {
		function e(e, r) {
			var i = e - t, o = r - n, a = Math.sqrt(i * i + o * o);
			vl += a * (t + e) / 2, yl += a * (n + r) / 2, Tl += a, Xn(t = e, n = r)
		}

		var t, n;
		Fl.point = function (r, i) {
			Fl.point = e, Xn(t = r, n = i)
		}
	}

	function Yn() {
		Fl.point = Xn
	}

	function Kn() {
		function e(e, t) {
			var n = e - r, o = t - i, a = Math.sqrt(n * n + o * o);
			vl += a * (r + e) / 2, yl += a * (i + t) / 2, Tl += a, a = i * e - r * t, xl += a * (r + e), Rl += a * (i + t), bl += 3 * a, Xn(r = e, i = t)
		}

		var t, n, r, i;
		Fl.point = function (o, a) {
			Fl.point = e, Xn(t = r = o, n = i = a)
		}, Fl.lineEnd = function () {
			e(t, n)
		}
	}

	function Zn(e) {
		function t(t, n) {
			e.moveTo(t, n), e.arc(t, n, a, 0, _s)
		}

		function n(t, n) {
			e.moveTo(t, n), s.point = r
		}

		function r(t, n) {
			e.lineTo(t, n)
		}

		function i() {
			s.point = t
		}

		function o() {
			e.closePath()
		}

		var a = 4.5, s = {point: t, lineStart: function () {
			s.point = n
		}, lineEnd: i, polygonStart: function () {
			s.lineEnd = o
		}, polygonEnd: function () {
			s.lineEnd = i, s.point = t
		}, pointRadius: function (e) {
			return a = e, s
		}, result: m};
		return s
	}

	function Qn(e) {
		function t(e) {
			return(s ? r : n)(e)
		}

		function n(t) {
			return er(t, function (n, r) {
				n = e(n, r), t.point(n[0], n[1])
			})
		}

		function r(t) {
			function n(n, r) {
				n = e(n, r), t.point(n[0], n[1])
			}

			function r() {
				y = 0 / 0, _.point = o, t.lineStart()
			}

			function o(n, r) {
				var o = hn([n, r]), a = e(n, r);
				i(y, T, v, x, R, b, y = a[0], T = a[1], v = n, x = o[0], R = o[1], b = o[2], s, t), t.point(y, T)
			}

			function a() {
				_.point = n, t.lineEnd()
			}

			function l() {
				r(), _.point = u, _.lineEnd = c
			}

			function u(e, t) {
				o(h = e, f = t), d = y, p = T, m = x, g = R, E = b, _.point = o
			}

			function c() {
				i(y, T, v, x, R, b, d, p, h, m, g, E, s, t), _.lineEnd = a, a()
			}

			var h, f, d, p, m, g, E, v, y, T, x, R, b, _ = {point: n, lineStart: r, lineEnd: a, polygonStart: function () {
				t.polygonStart(), _.lineStart = l
			}, polygonEnd: function () {
				t.polygonEnd(), _.lineStart = r
			}};
			return _
		}

		function i(t, n, r, s, l, u, c, h, f, d, p, m, g, E) {
			var v = c - t, y = h - n, T = v * v + y * y;
			if (T > 4 * o && g--) {
				var x = s + d, R = l + p, b = u + m, _ = Math.sqrt(x * x + R * R + b * b), w = Math.asin(b /= _), H = os(os(b) - 1) < Hs || os(r - f) < Hs ? (r + f) / 2 : Math.atan2(R, x), M = e(H, w), S = M[0], C = M[1], A = S - t, L = C - n, k = y * A - v * L;
				(k * k / T > o || os((v * A + y * L) / T - .5) > .3 || a > s * d + l * p + u * m) && (i(t, n, r, s, l, u, S, C, H, x /= _, R /= _, b, g, E), E.point(S, C), i(S, C, H, x, R, b, c, h, f, d, p, m, g, E))
			}
		}

		var o = .5, a = Math.cos(30 * Ss), s = 16;
		return t.precision = function (e) {
			return arguments.length ? (s = (o = e * e) > 0 && 16, t) : Math.sqrt(o)
		}, t
	}

	function $n(e) {
		var t = Qn(function (t, n) {
			return e([t * Cs, n * Cs])
		});
		return function (e) {
			return rr(t(e))
		}
	}

	function Jn(e) {
		this.stream = e
	}

	function er(e, t) {
		return{point: t, sphere: function () {
			e.sphere()
		}, lineStart: function () {
			e.lineStart()
		}, lineEnd: function () {
			e.lineEnd()
		}, polygonStart: function () {
			e.polygonStart()
		}, polygonEnd: function () {
			e.polygonEnd()
		}}
	}

	function tr(e) {
		return nr(function () {
			return e
		})()
	}

	function nr(e) {
		function t(e) {
			return e = s(e[0] * Ss, e[1] * Ss), [e[0] * f + l, u - e[1] * f]
		}

		function n(e) {
			return e = s.invert((e[0] - l) / f, (u - e[1]) / f), e && [e[0] * Cs, e[1] * Cs]
		}

		function r() {
			s = Vn(a = ar(E, v, y), o);
			var e = o(m, g);
			return l = d - e[0] * f, u = p + e[1] * f, i()
		}

		function i() {
			return c && (c.valid = !1, c = null), t
		}

		var o, a, s, l, u, c, h = Qn(function (e, t) {
			return e = o(e, t), [e[0] * f + l, u - e[1] * f]
		}), f = 150, d = 480, p = 250, m = 0, g = 0, E = 0, v = 0, y = 0, T = wl, x = bt, R = null, b = null;
		return t.stream = function (e) {
			return c && (c.valid = !1), c = rr(T(a, h(x(e)))), c.valid = !0, c
		}, t.clipAngle = function (e) {
			return arguments.length ? (T = null == e ? (R = e, wl) : Nn((R = +e) * Ss), i()) : R
		}, t.clipExtent = function (e) {
			return arguments.length ? (b = e, x = e ? Un(e[0][0], e[0][1], e[1][0], e[1][1]) : bt, i()) : b
		}, t.scale = function (e) {
			return arguments.length ? (f = +e, r()) : f
		}, t.translate = function (e) {
			return arguments.length ? (d = +e[0], p = +e[1], r()) : [d, p]
		}, t.center = function (e) {
			return arguments.length ? (m = e[0] % 360 * Ss, g = e[1] % 360 * Ss, r()) : [m * Cs, g * Cs]
		}, t.rotate = function (e) {
			return arguments.length ? (E = e[0] % 360 * Ss, v = e[1] % 360 * Ss, y = e.length > 2 ? e[2] % 360 * Ss : 0, r()) : [E * Cs, v * Cs, y * Cs]
		}, Ga.rebind(t, h, "precision"), function () {
			return o = e.apply(this, arguments), t.invert = o.invert && n, r()
		}
	}

	function rr(e) {
		return er(e, function (t, n) {
			e.point(t * Ss, n * Ss)
		})
	}

	function ir(e, t) {
		return[e, t]
	}

	function or(e, t) {
		return[e > bs ? e - _s : -bs > e ? e + _s : e, t]
	}

	function ar(e, t, n) {
		return e ? t || n ? Vn(lr(e), ur(t, n)) : lr(e) : t || n ? ur(t, n) : or
	}

	function sr(e) {
		return function (t, n) {
			return t += e, [t > bs ? t - _s : -bs > t ? t + _s : t, n]
		}
	}

	function lr(e) {
		var t = sr(e);
		return t.invert = sr(-e), t
	}

	function ur(e, t) {
		function n(e, t) {
			var n = Math.cos(t), s = Math.cos(e) * n, l = Math.sin(e) * n, u = Math.sin(t), c = u * r + s * i;
			return[Math.atan2(l * o - c * a, s * r - u * i), Q(c * o + l * a)]
		}

		var r = Math.cos(e), i = Math.sin(e), o = Math.cos(t), a = Math.sin(t);
		return n.invert = function (e, t) {
			var n = Math.cos(t), s = Math.cos(e) * n, l = Math.sin(e) * n, u = Math.sin(t), c = u * o - l * a;
			return[Math.atan2(l * o + u * a, s * r + c * i), Q(c * r - s * i)]
		}, n
	}

	function cr(e, t) {
		var n = Math.cos(e), r = Math.sin(e);
		return function (i, o, a, s) {
			var l = a * t;
			null != i ? (i = hr(n, i), o = hr(n, o), (a > 0 ? o > i : i > o) && (i += a * _s)) : (i = e + a * _s, o = e - .5 * l);
			for (var u, c = i; a > 0 ? c > o : o > c; c -= l)s.point((u = En([n, -r * Math.cos(c), -r * Math.sin(c)]))[0], u[1])
		}
	}

	function hr(e, t) {
		var n = hn(t);
		n[0] -= e, gn(n);
		var r = Z(-n[1]);
		return((-n[2] < 0 ? -r : r) + 2 * Math.PI - Hs) % (2 * Math.PI)
	}

	function fr(e, t, n) {
		var r = Ga.range(e, t - Hs, n).concat(t);
		return function (e) {
			return r.map(function (t) {
				return[e, t]
			})
		}
	}

	function dr(e, t, n) {
		var r = Ga.range(e, t - Hs, n).concat(t);
		return function (e) {
			return r.map(function (t) {
				return[t, e]
			})
		}
	}

	function pr(e) {
		return e.source
	}

	function mr(e) {
		return e.target
	}

	function gr(e, t, n, r) {
		var i = Math.cos(t), o = Math.sin(t), a = Math.cos(r), s = Math.sin(r), l = i * Math.cos(e), u = i * Math.sin(e), c = a * Math.cos(n), h = a * Math.sin(n), f = 2 * Math.asin(Math.sqrt(tt(r - t) + i * a * tt(n - e))), d = 1 / Math.sin(f), p = f ? function (e) {
			var t = Math.sin(e *= f) * d, n = Math.sin(f - e) * d, r = n * l + t * c, i = n * u + t * h, a = n * o + t * s;
			return[Math.atan2(i, r) * Cs, Math.atan2(a, Math.sqrt(r * r + i * i)) * Cs]
		} : function () {
			return[e * Cs, t * Cs]
		};
		return p.distance = f, p
	}

	function Er() {
		function e(e, i) {
			var o = Math.sin(i *= Ss), a = Math.cos(i), s = os((e *= Ss) - t), l = Math.cos(s);
			Nl += Math.atan2(Math.sqrt((s = a * Math.sin(s)) * s + (s = r * o - n * a * l) * s), n * o + r * a * l), t = e, n = o, r = a
		}

		var t, n, r;
		zl.point = function (i, o) {
			t = i * Ss, n = Math.sin(o *= Ss), r = Math.cos(o), zl.point = e
		}, zl.lineEnd = function () {
			zl.point = zl.lineEnd = m
		}
	}

	function vr(e, t) {
		function n(t, n) {
			var r = Math.cos(t), i = Math.cos(n), o = e(r * i);
			return[o * i * Math.sin(t), o * Math.sin(n)]
		}

		return n.invert = function (e, n) {
			var r = Math.sqrt(e * e + n * n), i = t(r), o = Math.sin(i), a = Math.cos(i);
			return[Math.atan2(e * o, r * a), Math.asin(r && n * o / r)]
		}, n
	}

	function yr(e, t) {
		function n(e, t) {
			a > 0 ? -ws + Hs > t && (t = -ws + Hs) : t > ws - Hs && (t = ws - Hs);
			var n = a / Math.pow(i(t), o);
			return[n * Math.sin(o * e), a - n * Math.cos(o * e)]
		}

		var r = Math.cos(e), i = function (e) {
			return Math.tan(bs / 4 + e / 2)
		}, o = e === t ? Math.sin(e) : Math.log(r / Math.cos(t)) / Math.log(i(t) / i(e)), a = r * Math.pow(i(e), o) / o;
		return o ? (n.invert = function (e, t) {
			var n = a - t, r = Y(o) * Math.sqrt(e * e + n * n);
			return[Math.atan2(e, n) / o, 2 * Math.atan(Math.pow(a / r, 1 / o)) - ws]
		}, n) : xr
	}

	function Tr(e, t) {
		function n(e, t) {
			var n = o - t;
			return[n * Math.sin(i * e), o - n * Math.cos(i * e)]
		}

		var r = Math.cos(e), i = e === t ? Math.sin(e) : (r - Math.cos(t)) / (t - e), o = r / i + e;
		return os(i) < Hs ? ir : (n.invert = function (e, t) {
			var n = o - t;
			return[Math.atan2(e, n) / i, o - Y(i) * Math.sqrt(e * e + n * n)]
		}, n)
	}

	function xr(e, t) {
		return[e, Math.log(Math.tan(bs / 4 + t / 2))]
	}

	function Rr(e) {
		var t, n = tr(e), r = n.scale, i = n.translate, o = n.clipExtent;
		return n.scale = function () {
			var e = r.apply(n, arguments);
			return e === n ? t ? n.clipExtent(null) : n : e
		}, n.translate = function () {
			var e = i.apply(n, arguments);
			return e === n ? t ? n.clipExtent(null) : n : e
		}, n.clipExtent = function (e) {
			var a = o.apply(n, arguments);
			if (a === n) {
				if (t = null == e) {
					var s = bs * r(), l = i();
					o([
						[l[0] - s, l[1] - s],
						[l[0] + s, l[1] + s]
					])
				}
			} else t && (a = null);
			return a
		}, n.clipExtent(null)
	}

	function br(e, t) {
		return[Math.log(Math.tan(bs / 4 + t / 2)), -e]
	}

	function _r(e) {
		return e[0]
	}

	function wr(e) {
		return e[1]
	}

	function Hr(e) {
		for (var t = e.length, n = [0, 1], r = 2, i = 2; t > i; i++) {
			for (; r > 1 && K(e[n[r - 2]], e[n[r - 1]], e[i]) <= 0;)--r;
			n[r++] = i
		}
		return n.slice(0, r)
	}

	function Mr(e, t) {
		return e[0] - t[0] || e[1] - t[1]
	}

	function Sr(e, t, n) {
		return(n[0] - t[0]) * (e[1] - t[1]) < (n[1] - t[1]) * (e[0] - t[0])
	}

	function Cr(e, t, n, r) {
		var i = e[0], o = n[0], a = t[0] - i, s = r[0] - o, l = e[1], u = n[1], c = t[1] - l, h = r[1] - u, f = (s * (l - u) - h * (i - o)) / (h * a - s * c);
		return[i + f * a, l + f * c]
	}

	function Ar(e) {
		var t = e[0], n = e[e.length - 1];
		return!(t[0] - n[0] || t[1] - n[1])
	}

	function Lr() {
		$r(this), this.edge = this.site = this.circle = null
	}

	function kr(e) {
		var t = Kl.pop() || new Lr;
		return t.site = e, t
	}

	function Pr(e) {
		jr(e), Xl.remove(e), Kl.push(e), $r(e)
	}

	function Dr(e) {
		var t = e.circle, n = t.x, r = t.cy, i = {x: n, y: r}, o = e.P, a = e.N, s = [e];
		Pr(e);
		for (var l = o; l.circle && os(n - l.circle.x) < Hs && os(r - l.circle.cy) < Hs;)o = l.P, s.unshift(l), Pr(l), l = o;
		s.unshift(l), jr(l);
		for (var u = a; u.circle && os(n - u.circle.x) < Hs && os(r - u.circle.cy) < Hs;)a = u.N, s.push(u), Pr(u), u = a;
		s.push(u), jr(u);
		var c, h = s.length;
		for (c = 1; h > c; ++c)u = s[c], l = s[c - 1], Kr(u.edge, l.site, u.site, i);
		l = s[0], u = s[h - 1], u.edge = qr(l.site, u.site, null, i), Ir(l), Ir(u)
	}

	function Fr(e) {
		for (var t, n, r, i, o = e.x, a = e.y, s = Xl._; s;)if (r = Nr(s, a) - o, r > Hs)s = s.L; else {
			if (i = o - zr(s, a), !(i > Hs)) {
				r > -Hs ? (t = s.P, n = s) : i > -Hs ? (t = s, n = s.N) : t = n = s;
				break
			}
			if (!s.R) {
				t = s;
				break
			}
			s = s.R
		}
		var l = kr(e);
		if (Xl.insert(t, l), t || n) {
			if (t === n)return jr(t), n = kr(t.site), Xl.insert(l, n), l.edge = n.edge = qr(t.site, l.site), Ir(t), void Ir(n);
			if (!n)return void(l.edge = qr(t.site, l.site));
			jr(t), jr(n);
			var u = t.site, c = u.x, h = u.y, f = e.x - c, d = e.y - h, p = n.site, m = p.x - c, g = p.y - h, E = 2 * (f * g - d * m), v = f * f + d * d, y = m * m + g * g, T = {x: (g * v - d * y) / E + c, y: (f * y - m * v) / E + h};
			Kr(n.edge, u, p, T), l.edge = qr(u, e, null, T), n.edge = qr(e, p, null, T), Ir(t), Ir(n)
		}
	}

	function Nr(e, t) {
		var n = e.site, r = n.x, i = n.y, o = i - t;
		if (!o)return r;
		var a = e.P;
		if (!a)return-1 / 0;
		n = a.site;
		var s = n.x, l = n.y, u = l - t;
		if (!u)return s;
		var c = s - r, h = 1 / o - 1 / u, f = c / u;
		return h ? (-f + Math.sqrt(f * f - 2 * h * (c * c / (-2 * u) - l + u / 2 + i - o / 2))) / h + r : (r + s) / 2
	}

	function zr(e, t) {
		var n = e.N;
		if (n)return Nr(n, t);
		var r = e.site;
		return r.y === t ? r.x : 1 / 0
	}

	function Ur(e) {
		this.site = e, this.edges = []
	}

	function Vr(e) {
		for (var t, n, r, i, o, a, s, l, u, c, h = e[0][0], f = e[1][0], d = e[0][1], p = e[1][1], m = Gl, g = m.length; g--;)if (o = m[g], o && o.prepare())for (s = o.edges, l = s.length, a = 0; l > a;)c = s[a].end(), r = c.x, i = c.y, u = s[++a % l].start(), t = u.x, n = u.y, (os(r - t) > Hs || os(i - n) > Hs) && (s.splice(a, 0, new Zr(Yr(o.site, c, os(r - h) < Hs && p - i > Hs ? {x: h, y: os(t - h) < Hs ? n : p} : os(i - p) < Hs && f - r > Hs ? {x: os(n - p) < Hs ? t : f, y: p} : os(r - f) < Hs && i - d > Hs ? {x: f, y: os(t - f) < Hs ? n : d} : os(i - d) < Hs && r - h > Hs ? {x: os(n - d) < Hs ? t : h, y: d} : null), o.site, null)), ++l)
	}

	function Br(e, t) {
		return t.angle - e.angle
	}

	function Or() {
		$r(this), this.x = this.y = this.arc = this.site = this.cy = null
	}

	function Ir(e) {
		var t = e.P, n = e.N;
		if (t && n) {
			var r = t.site, i = e.site, o = n.site;
			if (r !== o) {
				var a = i.x, s = i.y, l = r.x - a, u = r.y - s, c = o.x - a, h = o.y - s, f = 2 * (l * h - u * c);
				if (!(f >= -Ms)) {
					var d = l * l + u * u, p = c * c + h * h, m = (h * d - u * p) / f, g = (l * p - c * d) / f, h = g + s, E = Zl.pop() || new Or;
					E.arc = e, E.site = i, E.x = m + a, E.y = h + Math.sqrt(m * m + g * g), E.cy = h, e.circle = E;
					for (var v = null, y = Yl._; y;)if (E.y < y.y || E.y === y.y && E.x <= y.x) {
						if (!y.L) {
							v = y.P;
							break
						}
						y = y.L
					} else {
						if (!y.R) {
							v = y;
							break
						}
						y = y.R
					}
					Yl.insert(v, E), v || (ql = E)
				}
			}
		}
	}

	function jr(e) {
		var t = e.circle;
		t && (t.P || (ql = t.N), Yl.remove(t), Zl.push(t), $r(t), e.circle = null)
	}

	function Wr(e) {
		for (var t, n = Wl, r = zn(e[0][0], e[0][1], e[1][0], e[1][1]), i = n.length; i--;)t = n[i], (!Gr(t, e) || !r(t) || os(t.a.x - t.b.x) < Hs && os(t.a.y - t.b.y) < Hs) && (t.a = t.b = null, n.splice(i, 1))
	}

	function Gr(e, t) {
		var n = e.b;
		if (n)return!0;
		var r, i, o = e.a, a = t[0][0], s = t[1][0], l = t[0][1], u = t[1][1], c = e.l, h = e.r, f = c.x, d = c.y, p = h.x, m = h.y, g = (f + p) / 2, E = (d + m) / 2;
		if (m === d) {
			if (a > g || g >= s)return;
			if (f > p) {
				if (o) {
					if (o.y >= u)return
				} else o = {x: g, y: l};
				n = {x: g, y: u}
			} else {
				if (o) {
					if (o.y < l)return
				} else o = {x: g, y: u};
				n = {x: g, y: l}
			}
		} else if (r = (f - p) / (m - d), i = E - r * g, -1 > r || r > 1)if (f > p) {
			if (o) {
				if (o.y >= u)return
			} else o = {x: (l - i) / r, y: l};
			n = {x: (u - i) / r, y: u}
		} else {
			if (o) {
				if (o.y < l)return
			} else o = {x: (u - i) / r, y: u};
			n = {x: (l - i) / r, y: l}
		} else if (m > d) {
			if (o) {
				if (o.x >= s)return
			} else o = {x: a, y: r * a + i};
			n = {x: s, y: r * s + i}
		} else {
			if (o) {
				if (o.x < a)return
			} else o = {x: s, y: r * s + i};
			n = {x: a, y: r * a + i}
		}
		return e.a = o, e.b = n, !0
	}

	function Xr(e, t) {
		this.l = e, this.r = t, this.a = this.b = null
	}

	function qr(e, t, n, r) {
		var i = new Xr(e, t);
		return Wl.push(i), n && Kr(i, e, t, n), r && Kr(i, t, e, r), Gl[e.i].edges.push(new Zr(i, e, t)), Gl[t.i].edges.push(new Zr(i, t, e)), i
	}

	function Yr(e, t, n) {
		var r = new Xr(e, null);
		return r.a = t, r.b = n, Wl.push(r), r
	}

	function Kr(e, t, n, r) {
		e.a || e.b ? e.l === n ? e.b = r : e.a = r : (e.a = r, e.l = t, e.r = n)
	}

	function Zr(e, t, n) {
		var r = e.a, i = e.b;
		this.edge = e, this.site = t, this.angle = n ? Math.atan2(n.y - t.y, n.x - t.x) : e.l === t ? Math.atan2(i.x - r.x, r.y - i.y) : Math.atan2(r.x - i.x, i.y - r.y)
	}

	function Qr() {
		this._ = null
	}

	function $r(e) {
		e.U = e.C = e.L = e.R = e.P = e.N = null
	}

	function Jr(e, t) {
		var n = t, r = t.R, i = n.U;
		i ? i.L === n ? i.L = r : i.R = r : e._ = r, r.U = i, n.U = r, n.R = r.L, n.R && (n.R.U = n), r.L = n
	}

	function ei(e, t) {
		var n = t, r = t.L, i = n.U;
		i ? i.L === n ? i.L = r : i.R = r : e._ = r, r.U = i, n.U = r, n.L = r.R, n.L && (n.L.U = n), r.R = n
	}

	function ti(e) {
		for (; e.L;)e = e.L;
		return e
	}

	function ni(e, t) {
		var n, r, i, o = e.sort(ri).pop();
		for (Wl = [], Gl = new Array(e.length), Xl = new Qr, Yl = new Qr; ;)if (i = ql, o && (!i || o.y < i.y || o.y === i.y && o.x < i.x))(o.x !== n || o.y !== r) && (Gl[o.i] = new Ur(o), Fr(o), n = o.x, r = o.y), o = e.pop(); else {
			if (!i)break;
			Dr(i.arc)
		}
		t && (Wr(t), Vr(t));
		var a = {cells: Gl, edges: Wl};
		return Xl = Yl = Wl = Gl = null, a
	}

	function ri(e, t) {
		return t.y - e.y || t.x - e.x
	}

	function ii(e, t, n) {
		return(e.x - n.x) * (t.y - e.y) - (e.x - t.x) * (n.y - e.y)
	}

	function oi(e) {
		return e.x
	}

	function ai(e) {
		return e.y
	}

	function si() {
		return{leaf: !0, nodes: [], point: null, x: null, y: null}
	}

	function li(e, t, n, r, i, o) {
		if (!e(t, n, r, i, o)) {
			var a = .5 * (n + i), s = .5 * (r + o), l = t.nodes;
			l[0] && li(e, l[0], n, r, a, s), l[1] && li(e, l[1], a, r, i, s), l[2] && li(e, l[2], n, s, a, o), l[3] && li(e, l[3], a, s, i, o)
		}
	}

	function ui(e, t) {
		e = Ga.rgb(e), t = Ga.rgb(t);
		var n = e.r, r = e.g, i = e.b, o = t.r - n, a = t.g - r, s = t.b - i;
		return function (e) {
			return"#" + gt(Math.round(n + o * e)) + gt(Math.round(r + a * e)) + gt(Math.round(i + s * e))
		}
	}

	function ci(e, t) {
		var n, r = {}, i = {};
		for (n in e)n in t ? r[n] = di(e[n], t[n]) : i[n] = e[n];
		for (n in t)n in e || (i[n] = t[n]);
		return function (e) {
			for (n in r)i[n] = r[n](e);
			return i
		}
	}

	function hi(e, t) {
		return t -= e = +e, function (n) {
			return e + t * n
		}
	}

	function fi(e, t) {
		var n, r, i, o = $l.lastIndex = Jl.lastIndex = 0, a = -1, s = [], l = [];
		for (e += "", t += ""; (n = $l.exec(e)) && (r = Jl.exec(t));)(i = r.index) > o && (i = t.substring(o, i), s[a] ? s[a] += i : s[++a] = i), (n = n[0]) === (r = r[0]) ? s[a] ? s[a] += r : s[++a] = r : (s[++a] = null, l.push({i: a, x: hi(n, r)})), o = Jl.lastIndex;
		return o < t.length && (i = t.substring(o), s[a] ? s[a] += i : s[++a] = i), s.length < 2 ? l[0] ? (t = l[0].x, function (e) {
			return t(e) + ""
		}) : function () {
			return t
		} : (t = l.length, function (e) {
			for (var n, r = 0; t > r; ++r)s[(n = l[r]).i] = n.x(e);
			return s.join("")
		})
	}

	function di(e, t) {
		for (var n, r = Ga.interpolators.length; --r >= 0 && !(n = Ga.interpolators[r](e, t)););
		return n
	}

	function pi(e, t) {
		var n, r = [], i = [], o = e.length, a = t.length, s = Math.min(e.length, t.length);
		for (n = 0; s > n; ++n)r.push(di(e[n], t[n]));
		for (; o > n; ++n)i[n] = e[n];
		for (; a > n; ++n)i[n] = t[n];
		return function (e) {
			for (n = 0; s > n; ++n)i[n] = r[n](e);
			return i
		}
	}

	function mi(e) {
		return function (t) {
			return 0 >= t ? 0 : t >= 1 ? 1 : e(t)
		}
	}

	function gi(e) {
		return function (t) {
			return 1 - e(1 - t)
		}
	}

	function Ei(e) {
		return function (t) {
			return.5 * (.5 > t ? e(2 * t) : 2 - e(2 - 2 * t))
		}
	}

	function vi(e) {
		return e * e
	}

	function yi(e) {
		return e * e * e
	}

	function Ti(e) {
		if (0 >= e)return 0;
		if (e >= 1)return 1;
		var t = e * e, n = t * e;
		return 4 * (.5 > e ? n : 3 * (e - t) + n - .75)
	}

	function xi(e) {
		return function (t) {
			return Math.pow(t, e)
		}
	}

	function Ri(e) {
		return 1 - Math.cos(e * ws)
	}

	function bi(e) {
		return Math.pow(2, 10 * (e - 1))
	}

	function _i(e) {
		return 1 - Math.sqrt(1 - e * e)
	}

	function wi(e, t) {
		var n;
		return arguments.length < 2 && (t = .45), arguments.length ? n = t / _s * Math.asin(1 / e) : (e = 1, n = t / 4), function (r) {
			return 1 + e * Math.pow(2, -10 * r) * Math.sin((r - n) * _s / t)
		}
	}

	function Hi(e) {
		return e || (e = 1.70158), function (t) {
			return t * t * ((e + 1) * t - e)
		}
	}

	function Mi(e) {
		return 1 / 2.75 > e ? 7.5625 * e * e : 2 / 2.75 > e ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : 2.5 / 2.75 > e ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
	}

	function Si(e, t) {
		e = Ga.hcl(e), t = Ga.hcl(t);
		var n = e.h, r = e.c, i = e.l, o = t.h - n, a = t.c - r, s = t.l - i;
		return isNaN(a) && (a = 0, r = isNaN(r) ? t.c : r), isNaN(o) ? (o = 0, n = isNaN(n) ? t.h : n) : o > 180 ? o -= 360 : -180 > o && (o += 360), function (e) {
			return at(n + o * e, r + a * e, i + s * e) + ""
		}
	}

	function Ci(e, t) {
		e = Ga.hsl(e), t = Ga.hsl(t);
		var n = e.h, r = e.s, i = e.l, o = t.h - n, a = t.s - r, s = t.l - i;
		return isNaN(a) && (a = 0, r = isNaN(r) ? t.s : r), isNaN(o) ? (o = 0, n = isNaN(n) ? t.h : n) : o > 180 ? o -= 360 : -180 > o && (o += 360), function (e) {
			return it(n + o * e, r + a * e, i + s * e) + ""
		}
	}

	function Ai(e, t) {
		e = Ga.lab(e), t = Ga.lab(t);
		var n = e.l, r = e.a, i = e.b, o = t.l - n, a = t.a - r, s = t.b - i;
		return function (e) {
			return lt(n + o * e, r + a * e, i + s * e) + ""
		}
	}

	function Li(e, t) {
		return t -= e, function (n) {
			return Math.round(e + t * n)
		}
	}

	function ki(e) {
		var t = [e.a, e.b], n = [e.c, e.d], r = Di(t), i = Pi(t, n), o = Di(Fi(n, t, -i)) || 0;
		t[0] * n[1] < n[0] * t[1] && (t[0] *= -1, t[1] *= -1, r *= -1, i *= -1), this.rotate = (r ? Math.atan2(t[1], t[0]) : Math.atan2(-n[0], n[1])) * Cs, this.translate = [e.e, e.f], this.scale = [r, o], this.skew = o ? Math.atan2(i, o) * Cs : 0
	}

	function Pi(e, t) {
		return e[0] * t[0] + e[1] * t[1]
	}

	function Di(e) {
		var t = Math.sqrt(Pi(e, e));
		return t && (e[0] /= t, e[1] /= t), t
	}

	function Fi(e, t, n) {
		return e[0] += n * t[0], e[1] += n * t[1], e
	}

	function Ni(e, t) {
		var n, r = [], i = [], o = Ga.transform(e), a = Ga.transform(t), s = o.translate, l = a.translate, u = o.rotate, c = a.rotate, h = o.skew, f = a.skew, d = o.scale, p = a.scale;
		return s[0] != l[0] || s[1] != l[1] ? (r.push("translate(", null, ",", null, ")"), i.push({i: 1, x: hi(s[0], l[0])}, {i: 3, x: hi(s[1], l[1])})) : r.push(l[0] || l[1] ? "translate(" + l + ")" : ""), u != c ? (u - c > 180 ? c += 360 : c - u > 180 && (u += 360), i.push({i: r.push(r.pop() + "rotate(", null, ")") - 2, x: hi(u, c)})) : c && r.push(r.pop() + "rotate(" + c + ")"), h != f ? i.push({i: r.push(r.pop() + "skewX(", null, ")") - 2, x: hi(h, f)}) : f && r.push(r.pop() + "skewX(" + f + ")"), d[0] != p[0] || d[1] != p[1] ? (n = r.push(r.pop() + "scale(", null, ",", null, ")"), i.push({i: n - 4, x: hi(d[0], p[0])}, {i: n - 2, x: hi(d[1], p[1])})) : (1 != p[0] || 1 != p[1]) && r.push(r.pop() + "scale(" + p + ")"), n = i.length, function (e) {
			for (var t, o = -1; ++o < n;)r[(t = i[o]).i] = t.x(e);
			return r.join("")
		}
	}

	function zi(e, t) {
		return t = t - (e = +e) ? 1 / (t - e) : 0, function (n) {
			return(n - e) * t
		}
	}

	function Ui(e, t) {
		return t = t - (e = +e) ? 1 / (t - e) : 0, function (n) {
			return Math.max(0, Math.min(1, (n - e) * t))
		}
	}

	function Vi(e) {
		for (var t = e.source, n = e.target, r = Oi(t, n), i = [t]; t !== r;)t = t.parent, i.push(t);
		for (var o = i.length; n !== r;)i.splice(o, 0, n), n = n.parent;
		return i
	}

	function Bi(e) {
		for (var t = [], n = e.parent; null != n;)t.push(e), e = n, n = n.parent;
		return t.push(e), t
	}

	function Oi(e, t) {
		if (e === t)return e;
		for (var n = Bi(e), r = Bi(t), i = n.pop(), o = r.pop(), a = null; i === o;)a = i, i = n.pop(), o = r.pop();
		return a
	}

	function Ii(e) {
		e.fixed |= 2
	}

	function ji(e) {
		e.fixed &= -7
	}

	function Wi(e) {
		e.fixed |= 4, e.px = e.x, e.py = e.y
	}

	function Gi(e) {
		e.fixed &= -5
	}

	function Xi(e, t, n) {
		var r = 0, i = 0;
		if (e.charge = 0, !e.leaf)for (var o, a = e.nodes, s = a.length, l = -1; ++l < s;)o = a[l], null != o && (Xi(o, t, n), e.charge += o.charge, r += o.charge * o.cx, i += o.charge * o.cy);
		if (e.point) {
			e.leaf || (e.point.x += Math.random() - .5, e.point.y += Math.random() - .5);
			var u = t * n[e.point.index];
			e.charge += e.pointCharge = u, r += u * e.point.x, i += u * e.point.y
		}
		e.cx = r / e.charge, e.cy = i / e.charge
	}

	function qi(e, t) {
		return Ga.rebind(e, t, "sort", "children", "value"), e.nodes = e, e.links = Ji, e
	}

	function Yi(e, t) {
		for (var n = [e]; null != (e = n.pop());)if (t(e), (i = e.children) && (r = i.length))for (var r, i; --r >= 0;)n.push(i[r])
	}

	function Ki(e, t) {
		for (var n = [e], r = []; null != (e = n.pop());)if (r.push(e), (o = e.children) && (i = o.length))for (var i, o, a = -1; ++a < i;)n.push(o[a]);
		for (; null != (e = r.pop());)t(e)
	}

	function Zi(e) {
		return e.children
	}

	function Qi(e) {
		return e.value
	}

	function $i(e, t) {
		return t.value - e.value
	}

	function Ji(e) {
		return Ga.merge(e.map(function (e) {
			return(e.children || []).map(function (t) {
				return{source: e, target: t}
			})
		}))
	}

	function eo(e) {
		return e.x
	}

	function to(e) {
		return e.y
	}

	function no(e, t, n) {
		e.y0 = t, e.y = n
	}

	function ro(e) {
		return Ga.range(e.length)
	}

	function io(e) {
		for (var t = -1, n = e[0].length, r = []; ++t < n;)r[t] = 0;
		return r
	}

	function oo(e) {
		for (var t, n = 1, r = 0, i = e[0][1], o = e.length; o > n; ++n)(t = e[n][1]) > i && (r = n, i = t);
		return r
	}

	function ao(e) {
		return e.reduce(so, 0)
	}

	function so(e, t) {
		return e + t[1]
	}

	function lo(e, t) {
		return uo(e, Math.ceil(Math.log(t.length) / Math.LN2 + 1))
	}

	function uo(e, t) {
		for (var n = -1, r = +e[0], i = (e[1] - r) / t, o = []; ++n <= t;)o[n] = i * n + r;
		return o
	}

	function co(e) {
		return[Ga.min(e), Ga.max(e)]
	}

	function ho(e, t) {
		return e.value - t.value
	}

	function fo(e, t) {
		var n = e._pack_next;
		e._pack_next = t, t._pack_prev = e, t._pack_next = n, n._pack_prev = t
	}

	function po(e, t) {
		e._pack_next = t, t._pack_prev = e
	}

	function mo(e, t) {
		var n = t.x - e.x, r = t.y - e.y, i = e.r + t.r;
		return.999 * i * i > n * n + r * r
	}

	function go(e) {
		function t(e) {
			c = Math.min(e.x - e.r, c), h = Math.max(e.x + e.r, h), f = Math.min(e.y - e.r, f), d = Math.max(e.y + e.r, d)
		}

		if ((n = e.children) && (u = n.length)) {
			var n, r, i, o, a, s, l, u, c = 1 / 0, h = -1 / 0, f = 1 / 0, d = -1 / 0;
			if (n.forEach(Eo), r = n[0], r.x = -r.r, r.y = 0, t(r), u > 1 && (i = n[1], i.x = i.r, i.y = 0, t(i), u > 2))for (o = n[2], To(r, i, o), t(o), fo(r, o), r._pack_prev = o, fo(o, i), i = r._pack_next, a = 3; u > a; a++) {
				To(r, i, o = n[a]);
				var p = 0, m = 1, g = 1;
				for (s = i._pack_next; s !== i; s = s._pack_next, m++)if (mo(s, o)) {
					p = 1;
					break
				}
				if (1 == p)for (l = r._pack_prev; l !== s._pack_prev && !mo(l, o); l = l._pack_prev, g++);
				p ? (g > m || m == g && i.r < r.r ? po(r, i = s) : po(r = l, i), a--) : (fo(r, o), i = o, t(o))
			}
			var E = (c + h) / 2, v = (f + d) / 2, y = 0;
			for (a = 0; u > a; a++)o = n[a], o.x -= E, o.y -= v, y = Math.max(y, o.r + Math.sqrt(o.x * o.x + o.y * o.y));
			e.r = y, n.forEach(vo)
		}
	}

	function Eo(e) {
		e._pack_next = e._pack_prev = e
	}

	function vo(e) {
		delete e._pack_next, delete e._pack_prev
	}

	function yo(e, t, n, r) {
		var i = e.children;
		if (e.x = t += r * e.x, e.y = n += r * e.y, e.r *= r, i)for (var o = -1, a = i.length; ++o < a;)yo(i[o], t, n, r)
	}

	function To(e, t, n) {
		var r = e.r + n.r, i = t.x - e.x, o = t.y - e.y;
		if (r && (i || o)) {
			var a = t.r + n.r, s = i * i + o * o;
			a *= a, r *= r;
			var l = .5 + (r - a) / (2 * s), u = Math.sqrt(Math.max(0, 2 * a * (r + s) - (r -= s) * r - a * a)) / (2 * s);
			n.x = e.x + l * i + u * o, n.y = e.y + l * o - u * i
		} else n.x = e.x + r, n.y = e.y
	}

	function xo(e, t) {
		return e.parent == t.parent ? 1 : 2
	}

	function Ro(e) {
		var t = e.children;
		return t.length ? t[0] : e.t
	}

	function bo(e) {
		var t, n = e.children;
		return(t = n.length) ? n[t - 1] : e.t
	}

	function _o(e, t, n) {
		var r = n / (t.i - e.i);
		t.c -= r, t.s += n, e.c += r, t.z += n, t.m += n
	}

	function wo(e) {
		for (var t, n = 0, r = 0, i = e.children, o = i.length; --o >= 0;)t = i[o], t.z += n, t.m += n, n += t.s + (r += t.c)
	}

	function Ho(e, t, n) {
		return e.a.parent === t.parent ? e.a : n
	}

	function Mo(e) {
		return 1 + Ga.max(e, function (e) {
			return e.y
		})
	}

	function So(e) {
		return e.reduce(function (e, t) {
			return e + t.x
		}, 0) / e.length
	}

	function Co(e) {
		var t = e.children;
		return t && t.length ? Co(t[0]) : e
	}

	function Ao(e) {
		var t, n = e.children;
		return n && (t = n.length) ? Ao(n[t - 1]) : e
	}

	function Lo(e) {
		return{x: e.x, y: e.y, dx: e.dx, dy: e.dy}
	}

	function ko(e, t) {
		var n = e.x + t[3], r = e.y + t[0], i = e.dx - t[1] - t[3], o = e.dy - t[0] - t[2];
		return 0 > i && (n += i / 2, i = 0), 0 > o && (r += o / 2, o = 0), {x: n, y: r, dx: i, dy: o}
	}

	function Po(e) {
		var t = e[0], n = e[e.length - 1];
		return n > t ? [t, n] : [n, t]
	}

	function Do(e) {
		return e.rangeExtent ? e.rangeExtent() : Po(e.range())
	}

	function Fo(e, t, n, r) {
		var i = n(e[0], e[1]), o = r(t[0], t[1]);
		return function (e) {
			return o(i(e))
		}
	}

	function No(e, t) {
		var n, r = 0, i = e.length - 1, o = e[r], a = e[i];
		return o > a && (n = r, r = i, i = n, n = o, o = a, a = n), e[r] = t.floor(o), e[i] = t.ceil(a), e
	}

	function zo(e) {
		return e ? {floor: function (t) {
			return Math.floor(t / e) * e
		}, ceil: function (t) {
			return Math.ceil(t / e) * e
		}} : cu
	}

	function Uo(e, t, n, r) {
		var i = [], o = [], a = 0, s = Math.min(e.length, t.length) - 1;
		for (e[s] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++a <= s;)i.push(n(e[a - 1], e[a])), o.push(r(t[a - 1], t[a]));
		return function (t) {
			var n = Ga.bisect(e, t, 1, s) - 1;
			return o[n](i[n](t))
		}
	}

	function Vo(e, t, n, r) {
		function i() {
			var i = Math.min(e.length, t.length) > 2 ? Uo : Fo, l = r ? Ui : zi;
			return a = i(e, t, l, n), s = i(t, e, l, di), o
		}

		function o(e) {
			return a(e)
		}

		var a, s;
		return o.invert = function (e) {
			return s(e)
		}, o.domain = function (t) {
			return arguments.length ? (e = t.map(Number), i()) : e
		}, o.range = function (e) {
			return arguments.length ? (t = e, i()) : t
		}, o.rangeRound = function (e) {
			return o.range(e).interpolate(Li)
		}, o.clamp = function (e) {
			return arguments.length ? (r = e, i()) : r
		}, o.interpolate = function (e) {
			return arguments.length ? (n = e, i()) : n
		}, o.ticks = function (t) {
			return jo(e, t)
		}, o.tickFormat = function (t, n) {
			return Wo(e, t, n)
		}, o.nice = function (t) {
			return Oo(e, t), i()
		}, o.copy = function () {
			return Vo(e, t, n, r)
		}, i()
	}

	function Bo(e, t) {
		return Ga.rebind(e, t, "range", "rangeRound", "interpolate", "clamp")
	}

	function Oo(e, t) {
		return No(e, zo(Io(e, t)[2]))
	}

	function Io(e, t) {
		null == t && (t = 10);
		var n = Po(e), r = n[1] - n[0], i = Math.pow(10, Math.floor(Math.log(r / t) / Math.LN10)), o = t / r * i;
		return.15 >= o ? i *= 10 : .35 >= o ? i *= 5 : .75 >= o && (i *= 2), n[0] = Math.ceil(n[0] / i) * i, n[1] = Math.floor(n[1] / i) * i + .5 * i, n[2] = i, n
	}

	function jo(e, t) {
		return Ga.range.apply(Ga, Io(e, t))
	}

	function Wo(e, t, n) {
		var r = Io(e, t);
		if (n) {
			var i = $s.exec(n);
			if (i.shift(), "s" === i[8]) {
				var o = Ga.formatPrefix(Math.max(os(r[0]), os(r[1])));
				return i[7] || (i[7] = "." + Go(o.scale(r[2]))), i[8] = "f", n = Ga.format(i.join("")), function (e) {
					return n(o.scale(e)) + o.symbol
				}
			}
			i[7] || (i[7] = "." + Xo(i[8], r)), n = i.join("")
		} else n = ",." + Go(r[2]) + "f";
		return Ga.format(n)
	}

	function Go(e) {
		return-Math.floor(Math.log(e) / Math.LN10 + .01)
	}

	function Xo(e, t) {
		var n = Go(t[2]);
		return e in hu ? Math.abs(n - Go(Math.max(os(t[0]), os(t[1])))) + +("e" !== e) : n - 2 * ("%" === e)
	}

	function qo(e, t, n, r) {
		function i(e) {
			return(n ? Math.log(0 > e ? 0 : e) : -Math.log(e > 0 ? 0 : -e)) / Math.log(t)
		}

		function o(e) {
			return n ? Math.pow(t, e) : -Math.pow(t, -e)
		}

		function a(t) {
			return e(i(t))
		}

		return a.invert = function (t) {
			return o(e.invert(t))
		}, a.domain = function (t) {
			return arguments.length ? (n = t[0] >= 0, e.domain((r = t.map(Number)).map(i)), a) : r
		}, a.base = function (n) {
			return arguments.length ? (t = +n, e.domain(r.map(i)), a) : t
		}, a.nice = function () {
			var t = No(r.map(i), n ? Math : du);
			return e.domain(t), r = t.map(o), a
		}, a.ticks = function () {
			var e = Po(r), a = [], s = e[0], l = e[1], u = Math.floor(i(s)), c = Math.ceil(i(l)), h = t % 1 ? 2 : t;
			if (isFinite(c - u)) {
				if (n) {
					for (; c > u; u++)for (var f = 1; h > f; f++)a.push(o(u) * f);
					a.push(o(u))
				} else for (a.push(o(u)); u++ < c;)for (var f = h - 1; f > 0; f--)a.push(o(u) * f);
				for (u = 0; a[u] < s; u++);
				for (c = a.length; a[c - 1] > l; c--);
				a = a.slice(u, c)
			}
			return a
		}, a.tickFormat = function (e, t) {
			if (!arguments.length)return fu;
			arguments.length < 2 ? t = fu : "function" != typeof t && (t = Ga.format(t));
			var r, s = Math.max(.1, e / a.ticks().length), l = n ? (r = 1e-12, Math.ceil) : (r = -1e-12, Math.floor);
			return function (e) {
				return e / o(l(i(e) + r)) <= s ? t(e) : ""
			}
		}, a.copy = function () {
			return qo(e.copy(), t, n, r)
		}, Bo(a, e)
	}

	function Yo(e, t, n) {
		function r(t) {
			return e(i(t))
		}

		var i = Ko(t), o = Ko(1 / t);
		return r.invert = function (t) {
			return o(e.invert(t))
		}, r.domain = function (t) {
			return arguments.length ? (e.domain((n = t.map(Number)).map(i)), r) : n
		}, r.ticks = function (e) {
			return jo(n, e)
		}, r.tickFormat = function (e, t) {
			return Wo(n, e, t)
		}, r.nice = function (e) {
			return r.domain(Oo(n, e))
		}, r.exponent = function (a) {
			return arguments.length ? (i = Ko(t = a), o = Ko(1 / t), e.domain(n.map(i)), r) : t
		}, r.copy = function () {
			return Yo(e.copy(), t, n)
		}, Bo(r, e)
	}

	function Ko(e) {
		return function (t) {
			return 0 > t ? -Math.pow(-t, e) : Math.pow(t, e)
		}
	}

	function Zo(e, t) {
		function n(n) {
			return o[((i.get(n) || ("range" === t.t ? i.set(n, e.push(n)) : 0 / 0)) - 1) % o.length]
		}

		function r(t, n) {
			return Ga.range(e.length).map(function (e) {
				return t + n * e
			})
		}

		var i, o, s;
		return n.domain = function (r) {
			if (!arguments.length)return e;
			e = [], i = new a;
			for (var o, s = -1, l = r.length; ++s < l;)i.has(o = r[s]) || i.set(o, e.push(o));
			return n[t.t].apply(n, t.a)
		}, n.range = function (e) {
			return arguments.length ? (o = e, s = 0, t = {t: "range", a: arguments}, n) : o
		}, n.rangePoints = function (i, a) {
			arguments.length < 2 && (a = 0);
			var l = i[0], u = i[1], c = (u - l) / (Math.max(1, e.length - 1) + a);
			return o = r(e.length < 2 ? (l + u) / 2 : l + c * a / 2, c), s = 0, t = {t: "rangePoints", a: arguments}, n
		}, n.rangeBands = function (i, a, l) {
			arguments.length < 2 && (a = 0), arguments.length < 3 && (l = a);
			var u = i[1] < i[0], c = i[u - 0], h = i[1 - u], f = (h - c) / (e.length - a + 2 * l);
			return o = r(c + f * l, f), u && o.reverse(), s = f * (1 - a), t = {t: "rangeBands", a: arguments}, n
		}, n.rangeRoundBands = function (i, a, l) {
			arguments.length < 2 && (a = 0), arguments.length < 3 && (l = a);
			var u = i[1] < i[0], c = i[u - 0], h = i[1 - u], f = Math.floor((h - c) / (e.length - a + 2 * l)), d = h - c - (e.length - a) * f;
			return o = r(c + Math.round(d / 2), f), u && o.reverse(), s = Math.round(f * (1 - a)), t = {t: "rangeRoundBands", a: arguments}, n
		}, n.rangeBand = function () {
			return s
		}, n.rangeExtent = function () {
			return Po(t.a[0])
		}, n.copy = function () {
			return Zo(e, t)
		}, n.domain(e)
	}

	function Qo(n, r) {
		function i() {
			var e = 0, t = r.length;
			for (a = []; ++e < t;)a[e - 1] = Ga.quantile(n, e / t);
			return o
		}

		function o(e) {
			return isNaN(e = +e) ? void 0 : r[Ga.bisect(a, e)]
		}

		var a;
		return o.domain = function (r) {
			return arguments.length ? (n = r.filter(t).sort(e), i()) : n
		}, o.range = function (e) {
			return arguments.length ? (r = e, i()) : r
		}, o.quantiles = function () {
			return a
		}, o.invertExtent = function (e) {
			return e = r.indexOf(e), 0 > e ? [0 / 0, 0 / 0] : [e > 0 ? a[e - 1] : n[0], e < a.length ? a[e] : n[n.length - 1]]
		}, o.copy = function () {
			return Qo(n, r)
		}, i()
	}

	function $o(e, t, n) {
		function r(t) {
			return n[Math.max(0, Math.min(a, Math.floor(o * (t - e))))]
		}

		function i() {
			return o = n.length / (t - e), a = n.length - 1, r
		}

		var o, a;
		return r.domain = function (n) {
			return arguments.length ? (e = +n[0], t = +n[n.length - 1], i()) : [e, t]
		}, r.range = function (e) {
			return arguments.length ? (n = e, i()) : n
		}, r.invertExtent = function (t) {
			return t = n.indexOf(t), t = 0 > t ? 0 / 0 : t / o + e, [t, t + 1 / o]
		}, r.copy = function () {
			return $o(e, t, n)
		}, i()
	}

	function Jo(e, t) {
		function n(n) {
			return n >= n ? t[Ga.bisect(e, n)] : void 0
		}

		return n.domain = function (t) {
			return arguments.length ? (e = t, n) : e
		}, n.range = function (e) {
			return arguments.length ? (t = e, n) : t
		}, n.invertExtent = function (n) {
			return n = t.indexOf(n), [e[n - 1], e[n]]
		}, n.copy = function () {
			return Jo(e, t)
		}, n
	}

	function ea(e) {
		function t(e) {
			return+e
		}

		return t.invert = t, t.domain = t.range = function (n) {
			return arguments.length ? (e = n.map(t), t) : e
		}, t.ticks = function (t) {
			return jo(e, t)
		}, t.tickFormat = function (t, n) {
			return Wo(e, t, n)
		}, t.copy = function () {
			return ea(e)
		}, t
	}

	function ta(e) {
		return e.innerRadius
	}

	function na(e) {
		return e.outerRadius
	}

	function ra(e) {
		return e.startAngle
	}

	function ia(e) {
		return e.endAngle
	}

	function oa(e) {
		function t(t) {
			function a() {
				u.push("M", o(e(c), s))
			}

			for (var l, u = [], c = [], h = -1, f = t.length, d = Rt(n), p = Rt(r); ++h < f;)i.call(this, l = t[h], h) ? c.push([+d.call(this, l, h), +p.call(this, l, h)]) : c.length && (a(), c = []);
			return c.length && a(), u.length ? u.join("") : null
		}

		var n = _r, r = wr, i = _n, o = aa, a = o.key, s = .7;
		return t.x = function (e) {
			return arguments.length ? (n = e, t) : n
		}, t.y = function (e) {
			return arguments.length ? (r = e, t) : r
		}, t.defined = function (e) {
			return arguments.length ? (i = e, t) : i
		}, t.interpolate = function (e) {
			return arguments.length ? (a = "function" == typeof e ? o = e : (o = Tu.get(e) || aa).key, t) : a
		}, t.tension = function (e) {
			return arguments.length ? (s = e, t) : s
		}, t
	}

	function aa(e) {
		return e.join("L")
	}

	function sa(e) {
		return aa(e) + "Z"
	}

	function la(e) {
		for (var t = 0, n = e.length, r = e[0], i = [r[0], ",", r[1]]; ++t < n;)i.push("H", (r[0] + (r = e[t])[0]) / 2, "V", r[1]);
		return n > 1 && i.push("H", r[0]), i.join("")
	}

	function ua(e) {
		for (var t = 0, n = e.length, r = e[0], i = [r[0], ",", r[1]]; ++t < n;)i.push("V", (r = e[t])[1], "H", r[0]);
		return i.join("")
	}

	function ca(e) {
		for (var t = 0, n = e.length, r = e[0], i = [r[0], ",", r[1]]; ++t < n;)i.push("H", (r = e[t])[0], "V", r[1]);
		return i.join("")
	}

	function ha(e, t) {
		return e.length < 4 ? aa(e) : e[1] + pa(e.slice(1, e.length - 1), ma(e, t))
	}

	function fa(e, t) {
		return e.length < 3 ? aa(e) : e[0] + pa((e.push(e[0]), e), ma([e[e.length - 2]].concat(e, [e[1]]), t))
	}

	function da(e, t) {
		return e.length < 3 ? aa(e) : e[0] + pa(e, ma(e, t))
	}

	function pa(e, t) {
		if (t.length < 1 || e.length != t.length && e.length != t.length + 2)return aa(e);
		var n = e.length != t.length, r = "", i = e[0], o = e[1], a = t[0], s = a, l = 1;
		if (n && (r += "Q" + (o[0] - 2 * a[0] / 3) + "," + (o[1] - 2 * a[1] / 3) + "," + o[0] + "," + o[1], i = e[1], l = 2), t.length > 1) {
			s = t[1], o = e[l], l++, r += "C" + (i[0] + a[0]) + "," + (i[1] + a[1]) + "," + (o[0] - s[0]) + "," + (o[1] - s[1]) + "," + o[0] + "," + o[1];
			for (var u = 2; u < t.length; u++, l++)o = e[l], s = t[u], r += "S" + (o[0] - s[0]) + "," + (o[1] - s[1]) + "," + o[0] + "," + o[1]
		}
		if (n) {
			var c = e[l];
			r += "Q" + (o[0] + 2 * s[0] / 3) + "," + (o[1] + 2 * s[1] / 3) + "," + c[0] + "," + c[1]
		}
		return r
	}

	function ma(e, t) {
		for (var n, r = [], i = (1 - t) / 2, o = e[0], a = e[1], s = 1, l = e.length; ++s < l;)n = o, o = a, a = e[s], r.push([i * (a[0] - n[0]), i * (a[1] - n[1])]);
		return r
	}

	function ga(e) {
		if (e.length < 3)return aa(e);
		var t = 1, n = e.length, r = e[0], i = r[0], o = r[1], a = [i, i, i, (r = e[1])[0]], s = [o, o, o, r[1]], l = [i, ",", o, "L", Ta(bu, a), ",", Ta(bu, s)];
		for (e.push(e[n - 1]); ++t <= n;)r = e[t], a.shift(), a.push(r[0]), s.shift(), s.push(r[1]), xa(l, a, s);
		return e.pop(), l.push("L", r), l.join("")
	}

	function Ea(e) {
		if (e.length < 4)return aa(e);
		for (var t, n = [], r = -1, i = e.length, o = [0], a = [0]; ++r < 3;)t = e[r], o.push(t[0]), a.push(t[1]);
		for (n.push(Ta(bu, o) + "," + Ta(bu, a)), --r; ++r < i;)t = e[r], o.shift(), o.push(t[0]), a.shift(), a.push(t[1]), xa(n, o, a);
		return n.join("")
	}

	function va(e) {
		for (var t, n, r = -1, i = e.length, o = i + 4, a = [], s = []; ++r < 4;)n = e[r % i], a.push(n[0]), s.push(n[1]);
		for (t = [Ta(bu, a), ",", Ta(bu, s)], --r; ++r < o;)n = e[r % i], a.shift(), a.push(n[0]), s.shift(), s.push(n[1]), xa(t, a, s);
		return t.join("")
	}

	function ya(e, t) {
		var n = e.length - 1;
		if (n)for (var r, i, o = e[0][0], a = e[0][1], s = e[n][0] - o, l = e[n][1] - a, u = -1; ++u <= n;)r = e[u], i = u / n, r[0] = t * r[0] + (1 - t) * (o + i * s), r[1] = t * r[1] + (1 - t) * (a + i * l);
		return ga(e)
	}

	function Ta(e, t) {
		return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3]
	}

	function xa(e, t, n) {
		e.push("C", Ta(xu, t), ",", Ta(xu, n), ",", Ta(Ru, t), ",", Ta(Ru, n), ",", Ta(bu, t), ",", Ta(bu, n))
	}

	function Ra(e, t) {
		return(t[1] - e[1]) / (t[0] - e[0])
	}

	function ba(e) {
		for (var t = 0, n = e.length - 1, r = [], i = e[0], o = e[1], a = r[0] = Ra(i, o); ++t < n;)r[t] = (a + (a = Ra(i = o, o = e[t + 1]))) / 2;
		return r[t] = a, r
	}

	function _a(e) {
		for (var t, n, r, i, o = [], a = ba(e), s = -1, l = e.length - 1; ++s < l;)t = Ra(e[s], e[s + 1]), os(t) < Hs ? a[s] = a[s + 1] = 0 : (n = a[s] / t, r = a[s + 1] / t, i = n * n + r * r, i > 9 && (i = 3 * t / Math.sqrt(i), a[s] = i * n, a[s + 1] = i * r));
		for (s = -1; ++s <= l;)i = (e[Math.min(l, s + 1)][0] - e[Math.max(0, s - 1)][0]) / (6 * (1 + a[s] * a[s])), o.push([i || 0, a[s] * i || 0]);
		return o
	}

	function wa(e) {
		return e.length < 3 ? aa(e) : e[0] + pa(e, _a(e))
	}

	function Ha(e) {
		for (var t, n, r, i = -1, o = e.length; ++i < o;)t = e[i], n = t[0], r = t[1] + vu, t[0] = n * Math.cos(r), t[1] = n * Math.sin(r);
		return e
	}

	function Ma(e) {
		function t(t) {
			function l() {
				m.push("M", s(e(E), h), c, u(e(g.reverse()), h), "Z")
			}

			for (var f, d, p, m = [], g = [], E = [], v = -1, y = t.length, T = Rt(n), x = Rt(i), R = n === r ? function () {
				return d
			} : Rt(r), b = i === o ? function () {
				return p
			} : Rt(o); ++v < y;)a.call(this, f = t[v], v) ? (g.push([d = +T.call(this, f, v), p = +x.call(this, f, v)]), E.push([+R.call(this, f, v), +b.call(this, f, v)])) : g.length && (l(), g = [], E = []);
			return g.length && l(), m.length ? m.join("") : null
		}

		var n = _r, r = _r, i = 0, o = wr, a = _n, s = aa, l = s.key, u = s, c = "L", h = .7;
		return t.x = function (e) {
			return arguments.length ? (n = r = e, t) : r
		}, t.x0 = function (e) {
			return arguments.length ? (n = e, t) : n
		}, t.x1 = function (e) {
			return arguments.length ? (r = e, t) : r
		}, t.y = function (e) {
			return arguments.length ? (i = o = e, t) : o
		}, t.y0 = function (e) {
			return arguments.length ? (i = e, t) : i
		}, t.y1 = function (e) {
			return arguments.length ? (o = e, t) : o
		}, t.defined = function (e) {
			return arguments.length ? (a = e, t) : a
		}, t.interpolate = function (e) {
			return arguments.length ? (l = "function" == typeof e ? s = e : (s = Tu.get(e) || aa).key, u = s.reverse || s, c = s.closed ? "M" : "L", t) : l
		}, t.tension = function (e) {
			return arguments.length ? (h = e, t) : h
		}, t
	}

	function Sa(e) {
		return e.radius
	}

	function Ca(e) {
		return[e.x, e.y]
	}

	function Aa(e) {
		return function () {
			var t = e.apply(this, arguments), n = t[0], r = t[1] + vu;
			return[n * Math.cos(r), n * Math.sin(r)]
		}
	}

	function La() {
		return 64
	}

	function ka() {
		return"circle"
	}

	function Pa(e) {
		var t = Math.sqrt(e / bs);
		return"M0," + t + "A" + t + "," + t + " 0 1,1 0," + -t + "A" + t + "," + t + " 0 1,1 0," + t + "Z"
	}

	function Da(e, t) {
		return cs(e, Cu), e.id = t, e
	}

	function Fa(e, t, n, r) {
		var i = e.id;
		return N(e, "function" == typeof n ? function (e, o, a) {
			e.__transition__[i].tween.set(t, r(n.call(e, e.__data__, o, a)))
		} : (n = r(n), function (e) {
			e.__transition__[i].tween.set(t, n)
		}))
	}

	function Na(e) {
		return null == e && (e = ""), function () {
			this.textContent = e
		}
	}

	function za(e, t, n, r) {
		var i = e.__transition__ || (e.__transition__ = {active: 0, count: 0}), o = i[n];
		if (!o) {
			var s = r.time;
			o = i[n] = {tween: new a, time: s, ease: r.ease, delay: r.delay, duration: r.duration}, ++i.count, Ga.timer(function (r) {
				function a(r) {
					return i.active > n ? u() : (i.active = n, o.event && o.event.start.call(e, c, t), o.tween.forEach(function (n, r) {
						(r = r.call(e, c, t)) && m.push(r)
					}), void Ga.timer(function () {
						return p.c = l(r || 1) ? _n : l, 1
					}, 0, s))
				}

				function l(r) {
					if (i.active !== n)return u();
					for (var a = r / d, s = h(a), l = m.length; l > 0;)m[--l].call(e, s);
					return a >= 1 ? (o.event && o.event.end.call(e, c, t), u()) : void 0
				}

				function u() {
					return--i.count ? delete i[n] : delete e.__transition__, 1
				}

				var c = e.__data__, h = o.ease, f = o.delay, d = o.duration, p = Ks, m = [];
				return p.t = f + s, r >= f ? a(r - f) : void(p.c = a)
			}, 0, s)
		}
	}

	function Ua(e, t) {
		e.attr("transform", function (e) {
			return"translate(" + t(e) + ",0)"
		})
	}

	function Va(e, t) {
		e.attr("transform", function (e) {
			return"translate(0," + t(e) + ")"
		})
	}

	function Ba(e) {
		return e.toISOString()
	}

	function Oa(e, t, n) {
		function r(t) {
			return e(t)
		}

		function i(e, n) {
			var r = e[1] - e[0], i = r / n, o = Ga.bisect(Uu, i);
			return o == Uu.length ? [t.year, Io(e.map(function (e) {
				return e / 31536e6
			}), n)[2]] : o ? t[i / Uu[o - 1] < Uu[o] / i ? o - 1 : o] : [Ou, Io(e, n)[2]]
		}

		return r.invert = function (t) {
			return Ia(e.invert(t))
		}, r.domain = function (t) {
			return arguments.length ? (e.domain(t), r) : e.domain().map(Ia)
		}, r.nice = function (e, t) {
			function n(n) {
				return!isNaN(n) && !e.range(n, Ia(+n + 1), t).length
			}

			var o = r.domain(), a = Po(o), s = null == e ? i(a, 10) : "number" == typeof e && i(a, e);
			return s && (e = s[0], t = s[1]), r.domain(No(o, t > 1 ? {floor: function (t) {
				for (; n(t = e.floor(t));)t = Ia(t - 1);
				return t
			}, ceil: function (t) {
				for (; n(t = e.ceil(t));)t = Ia(+t + 1);
				return t
			}} : e))
		}, r.ticks = function (e, t) {
			var n = Po(r.domain()), o = null == e ? i(n, 10) : "number" == typeof e ? i(n, e) : !e.range && [
				{range: e},
				t
			];
			return o && (e = o[0], t = o[1]), e.range(n[0], Ia(+n[1] + 1), 1 > t ? 1 : t)
		}, r.tickFormat = function () {
			return n
		}, r.copy = function () {
			return Oa(e.copy(), t, n)
		}, Bo(r, e)
	}

	function Ia(e) {
		return new Date(e)
	}

	function ja(e) {
		return JSON.parse(e.responseText)
	}

	function Wa(e) {
		var t = Ya.createRange();
		return t.selectNode(Ya.body), t.createContextualFragment(e.responseText)
	}

	var Ga = {version: "3.4.11"};
	Date.now || (Date.now = function () {
		return+new Date
	});
	var Xa = [].slice, qa = function (e) {
		return Xa.call(e)
	}, Ya = document, Ka = Ya.documentElement, Za = window;
	try {
		qa(Ka.childNodes)[0].nodeType
	} catch (Qa) {
		qa = function (e) {
			for (var t = e.length, n = new Array(t); t--;)n[t] = e[t];
			return n
		}
	}
	try {
		Ya.createElement("div").style.setProperty("opacity", 0, "")
	} catch ($a) {
		var Ja = Za.Element.prototype, es = Ja.setAttribute, ts = Ja.setAttributeNS, ns = Za.CSSStyleDeclaration.prototype, rs = ns.setProperty;
		Ja.setAttribute = function (e, t) {
			es.call(this, e, t + "")
		}, Ja.setAttributeNS = function (e, t, n) {
			ts.call(this, e, t, n + "")
		}, ns.setProperty = function (e, t, n) {
			rs.call(this, e, t + "", n)
		}
	}
	Ga.ascending = e, Ga.descending = function (e, t) {
		return e > t ? -1 : t > e ? 1 : t >= e ? 0 : 0 / 0
	}, Ga.min = function (e, t) {
		var n, r, i = -1, o = e.length;
		if (1 === arguments.length) {
			for (; ++i < o && !(null != (n = e[i]) && n >= n);)n = void 0;
			for (; ++i < o;)null != (r = e[i]) && n > r && (n = r)
		} else {
			for (; ++i < o && !(null != (n = t.call(e, e[i], i)) && n >= n);)n = void 0;
			for (; ++i < o;)null != (r = t.call(e, e[i], i)) && n > r && (n = r)
		}
		return n
	}, Ga.max = function (e, t) {
		var n, r, i = -1, o = e.length;
		if (1 === arguments.length) {
			for (; ++i < o && !(null != (n = e[i]) && n >= n);)n = void 0;
			for (; ++i < o;)null != (r = e[i]) && r > n && (n = r)
		} else {
			for (; ++i < o && !(null != (n = t.call(e, e[i], i)) && n >= n);)n = void 0;
			for (; ++i < o;)null != (r = t.call(e, e[i], i)) && r > n && (n = r)
		}
		return n
	}, Ga.extent = function (e, t) {
		var n, r, i, o = -1, a = e.length;
		if (1 === arguments.length) {
			for (; ++o < a && !(null != (n = i = e[o]) && n >= n);)n = i = void 0;
			for (; ++o < a;)null != (r = e[o]) && (n > r && (n = r), r > i && (i = r))
		} else {
			for (; ++o < a && !(null != (n = i = t.call(e, e[o], o)) && n >= n);)n = void 0;
			for (; ++o < a;)null != (r = t.call(e, e[o], o)) && (n > r && (n = r), r > i && (i = r))
		}
		return[n, i]
	}, Ga.sum = function (e, t) {
		var n, r = 0, i = e.length, o = -1;
		if (1 === arguments.length)for (; ++o < i;)isNaN(n = +e[o]) || (r += n); else for (; ++o < i;)isNaN(n = +t.call(e, e[o], o)) || (r += n);
		return r
	}, Ga.mean = function (e, n) {
		var r, i = 0, o = e.length, a = -1, s = o;
		if (1 === arguments.length)for (; ++a < o;)t(r = e[a]) ? i += r : --s; else for (; ++a < o;)t(r = n.call(e, e[a], a)) ? i += r : --s;
		return s ? i / s : void 0
	}, Ga.quantile = function (e, t) {
		var n = (e.length - 1) * t + 1, r = Math.floor(n), i = +e[r - 1], o = n - r;
		return o ? i + o * (e[r] - i) : i
	}, Ga.median = function (n, r) {
		return arguments.length > 1 && (n = n.map(r)), n = n.filter(t), n.length ? Ga.quantile(n.sort(e), .5) : void 0
	};
	var is = n(e);
	Ga.bisectLeft = is.left, Ga.bisect = Ga.bisectRight = is.right, Ga.bisector = function (t) {
		return n(1 === t.length ? function (n, r) {
			return e(t(n), r)
		} : t)
	}, Ga.shuffle = function (e) {
		for (var t, n, r = e.length; r;)n = 0 | Math.random() * r--, t = e[r], e[r] = e[n], e[n] = t;
		return e
	}, Ga.permute = function (e, t) {
		for (var n = t.length, r = new Array(n); n--;)r[n] = e[t[n]];
		return r
	}, Ga.pairs = function (e) {
		for (var t, n = 0, r = e.length - 1, i = e[0], o = new Array(0 > r ? 0 : r); r > n;)o[n] = [t = i, i = e[++n]];
		return o
	}, Ga.zip = function () {
		if (!(i = arguments.length))return[];
		for (var e = -1, t = Ga.min(arguments, r), n = new Array(t); ++e < t;)for (var i, o = -1, a = n[e] = new Array(i); ++o < i;)a[o] = arguments[o][e];
		return n
	}, Ga.transpose = function (e) {
		return Ga.zip.apply(Ga, e)
	}, Ga.keys = function (e) {
		var t = [];
		for (var n in e)t.push(n);
		return t
	}, Ga.values = function (e) {
		var t = [];
		for (var n in e)t.push(e[n]);
		return t
	}, Ga.entries = function (e) {
		var t = [];
		for (var n in e)t.push({key: n, value: e[n]});
		return t
	}, Ga.merge = function (e) {
		for (var t, n, r, i = e.length, o = -1, a = 0; ++o < i;)a += e[o].length;
		for (n = new Array(a); --i >= 0;)for (r = e[i], t = r.length; --t >= 0;)n[--a] = r[t];
		return n
	};
	var os = Math.abs;
	Ga.range = function (e, t, n) {
		if (arguments.length < 3 && (n = 1, arguments.length < 2 && (t = e, e = 0)), 1 / 0 === (t - e) / n)throw new Error("infinite range");
		var r, o = [], a = i(os(n)), s = -1;
		if (e *= a, t *= a, n *= a, 0 > n)for (; (r = e + n * ++s) > t;)o.push(r / a); else for (; (r = e + n * ++s) < t;)o.push(r / a);
		return o
	}, Ga.map = function (e) {
		var t = new a;
		if (e instanceof a)e.forEach(function (e, n) {
			t.set(e, n)
		}); else for (var n in e)t.set(n, e[n]);
		return t
	}, o(a, {has: s, get: function (e) {
		return this[as + e]
	}, set: function (e, t) {
		return this[as + e] = t
	}, remove: l, keys: u, values: function () {
		var e = [];
		return this.forEach(function (t, n) {
			e.push(n)
		}), e
	}, entries: function () {
		var e = [];
		return this.forEach(function (t, n) {
			e.push({key: t, value: n})
		}), e
	}, size: c, empty: h, forEach: function (e) {
		for (var t in this)t.charCodeAt(0) === ss && e.call(this, t.substring(1), this[t])
	}});
	var as = "\x00", ss = as.charCodeAt(0);
	Ga.nest = function () {
		function e(t, s, l) {
			if (l >= o.length)return r ? r.call(i, s) : n ? s.sort(n) : s;
			for (var u, c, h, f, d = -1, p = s.length, m = o[l++], g = new a; ++d < p;)(f = g.get(u = m(c = s[d]))) ? f.push(c) : g.set(u, [c]);
			return t ? (c = t(), h = function (n, r) {
				c.set(n, e(t, r, l))
			}) : (c = {}, h = function (n, r) {
				c[n] = e(t, r, l)
			}), g.forEach(h), c
		}

		function t(e, n) {
			if (n >= o.length)return e;
			var r = [], i = s[n++];
			return e.forEach(function (e, i) {
				r.push({key: e, values: t(i, n)})
			}), i ? r.sort(function (e, t) {
				return i(e.key, t.key)
			}) : r
		}

		var n, r, i = {}, o = [], s = [];
		return i.map = function (t, n) {
			return e(n, t, 0)
		}, i.entries = function (n) {
			return t(e(Ga.map, n, 0), 0)
		}, i.key = function (e) {
			return o.push(e), i
		}, i.sortKeys = function (e) {
			return s[o.length - 1] = e, i
		}, i.sortValues = function (e) {
			return n = e, i
		}, i.rollup = function (e) {
			return r = e, i
		}, i
	}, Ga.set = function (e) {
		var t = new f;
		if (e)for (var n = 0, r = e.length; r > n; ++n)t.add(e[n]);
		return t
	}, o(f, {has: s, add: function (e) {
		return this[as + e] = !0, e
	}, remove: function (e) {
		return e = as + e, e in this && delete this[e]
	}, values: u, size: c, empty: h, forEach: function (e) {
		for (var t in this)t.charCodeAt(0) === ss && e.call(this, t.substring(1))
	}}), Ga.behavior = {}, Ga.rebind = function (e, t) {
		for (var n, r = 1, i = arguments.length; ++r < i;)e[n = arguments[r]] = d(e, t, t[n]);
		return e
	};
	var ls = ["webkit", "ms", "moz", "Moz", "o", "O"];
	Ga.dispatch = function () {
		for (var e = new g, t = -1, n = arguments.length; ++t < n;)e[arguments[t]] = E(e);
		return e
	}, g.prototype.on = function (e, t) {
		var n = e.indexOf("."), r = "";
		if (n >= 0 && (r = e.substring(n + 1), e = e.substring(0, n)), e)return arguments.length < 2 ? this[e].on(r) : this[e].on(r, t);
		if (2 === arguments.length) {
			if (null == t)for (e in this)this.hasOwnProperty(e) && this[e].on(r, null);
			return this
		}
	}, Ga.event = null, Ga.requote = function (e) {
		return e.replace(us, "\\$&")
	};
	var us = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g, cs = {}.__proto__ ? function (e, t) {
		e.__proto__ = t
	} : function (e, t) {
		for (var n in t)e[n] = t[n]
	}, hs = function (e, t) {
		return t.querySelector(e)
	}, fs = function (e, t) {
		return t.querySelectorAll(e)
	}, ds = Ka.matches || Ka[p(Ka, "matchesSelector")], ps = function (e, t) {
		return ds.call(e, t)
	};
	"function" == typeof Sizzle && (hs = function (e, t) {
		return Sizzle(e, t)[0] || null
	}, fs = Sizzle, ps = Sizzle.matchesSelector), Ga.selection = function () {
		return vs
	};
	var ms = Ga.selection.prototype = [];
	ms.select = function (e) {
		var t, n, r, i, o = [];
		e = R(e);
		for (var a = -1, s = this.length; ++a < s;) {
			o.push(t = []), t.parentNode = (r = this[a]).parentNode;
			for (var l = -1, u = r.length; ++l < u;)(i = r[l]) ? (t.push(n = e.call(i, i.__data__, l, a)), n && "__data__"in i && (n.__data__ = i.__data__)) : t.push(null)
		}
		return x(o)
	}, ms.selectAll = function (e) {
		var t, n, r = [];
		e = b(e);
		for (var i = -1, o = this.length; ++i < o;)for (var a = this[i], s = -1, l = a.length; ++s < l;)(n = a[s]) && (r.push(t = qa(e.call(n, n.__data__, s, i))), t.parentNode = n);
		return x(r)
	};
	var gs = {svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/"};
	Ga.ns = {prefix: gs, qualify: function (e) {
		var t = e.indexOf(":"), n = e;
		return t >= 0 && (n = e.substring(0, t), e = e.substring(t + 1)), gs.hasOwnProperty(n) ? {space: gs[n], local: e} : e
	}}, ms.attr = function (e, t) {
		if (arguments.length < 2) {
			if ("string" == typeof e) {
				var n = this.node();
				return e = Ga.ns.qualify(e), e.local ? n.getAttributeNS(e.space, e.local) : n.getAttribute(e)
			}
			for (t in e)this.each(_(t, e[t]));
			return this
		}
		return this.each(_(e, t))
	}, ms.classed = function (e, t) {
		if (arguments.length < 2) {
			if ("string" == typeof e) {
				var n = this.node(), r = (e = M(e)).length, i = -1;
				if (t = n.classList) {
					for (; ++i < r;)if (!t.contains(e[i]))return!1
				} else for (t = n.getAttribute("class"); ++i < r;)if (!H(e[i]).test(t))return!1;
				return!0
			}
			for (t in e)this.each(S(t, e[t]));
			return this
		}
		return this.each(S(e, t))
	}, ms.style = function (e, t, n) {
		var r = arguments.length;
		if (3 > r) {
			if ("string" != typeof e) {
				2 > r && (t = "");
				for (n in e)this.each(A(n, e[n], t));
				return this
			}
			if (2 > r)return Za.getComputedStyle(this.node(), null).getPropertyValue(e);
			n = ""
		}
		return this.each(A(e, t, n))
	}, ms.property = function (e, t) {
		if (arguments.length < 2) {
			if ("string" == typeof e)return this.node()[e];
			for (t in e)this.each(L(t, e[t]));
			return this
		}
		return this.each(L(e, t))
	}, ms.text = function (e) {
		return arguments.length ? this.each("function" == typeof e ? function () {
			var t = e.apply(this, arguments);
			this.textContent = null == t ? "" : t
		} : null == e ? function () {
			this.textContent = ""
		} : function () {
			this.textContent = e
		}) : this.node().textContent
	}, ms.html = function (e) {
		return arguments.length ? this.each("function" == typeof e ? function () {
			var t = e.apply(this, arguments);
			this.innerHTML = null == t ? "" : t
		} : null == e ? function () {
			this.innerHTML = ""
		} : function () {
			this.innerHTML = e
		}) : this.node().innerHTML
	}, ms.append = function (e) {
		return e = k(e), this.select(function () {
			return this.appendChild(e.apply(this, arguments))
		})
	}, ms.insert = function (e, t) {
		return e = k(e), t = R(t), this.select(function () {
			return this.insertBefore(e.apply(this, arguments), t.apply(this, arguments) || null)
		})
	}, ms.remove = function () {
		return this.each(function () {
			var e = this.parentNode;
			e && e.removeChild(this)
		})
	}, ms.data = function (e, t) {
		function n(e, n) {
			var r, i, o, s = e.length, h = n.length, f = Math.min(s, h), d = new Array(h), p = new Array(h), m = new Array(s);
			if (t) {
				var g, E = new a, v = new a, y = [];
				for (r = -1; ++r < s;)g = t.call(i = e[r], i.__data__, r), E.has(g) ? m[r] = i : E.set(g, i), y.push(g);
				for (r = -1; ++r < h;)g = t.call(n, o = n[r], r), (i = E.get(g)) ? (d[r] = i, i.__data__ = o) : v.has(g) || (p[r] = P(o)), v.set(g, o), E.remove(g);
				for (r = -1; ++r < s;)E.has(y[r]) && (m[r] = e[r])
			} else {
				for (r = -1; ++r < f;)i = e[r], o = n[r], i ? (i.__data__ = o, d[r] = i) : p[r] = P(o);
				for (; h > r; ++r)p[r] = P(n[r]);
				for (; s > r; ++r)m[r] = e[r]
			}
			p.update = d, p.parentNode = d.parentNode = m.parentNode = e.parentNode, l.push(p), u.push(d), c.push(m)
		}

		var r, i, o = -1, s = this.length;
		if (!arguments.length) {
			for (e = new Array(s = (r = this[0]).length); ++o < s;)(i = r[o]) && (e[o] = i.__data__);
			return e
		}
		var l = z([]), u = x([]), c = x([]);
		if ("function" == typeof e)for (; ++o < s;)n(r = this[o], e.call(r, r.parentNode.__data__, o)); else for (; ++o < s;)n(r = this[o], e);
		return u.enter = function () {
			return l
		}, u.exit = function () {
			return c
		}, u
	}, ms.datum = function (e) {
		return arguments.length ? this.property("__data__", e) : this.property("__data__")
	}, ms.filter = function (e) {
		var t, n, r, i = [];
		"function" != typeof e && (e = D(e));
		for (var o = 0, a = this.length; a > o; o++) {
			i.push(t = []), t.parentNode = (n = this[o]).parentNode;
			for (var s = 0, l = n.length; l > s; s++)(r = n[s]) && e.call(r, r.__data__, s, o) && t.push(r)
		}
		return x(i)
	}, ms.order = function () {
		for (var e = -1, t = this.length; ++e < t;)for (var n, r = this[e], i = r.length - 1, o = r[i]; --i >= 0;)(n = r[i]) && (o && o !== n.nextSibling && o.parentNode.insertBefore(n, o), o = n);
		return this
	}, ms.sort = function (e) {
		e = F.apply(this, arguments);
		for (var t = -1, n = this.length; ++t < n;)this[t].sort(e);
		return this.order()
	}, ms.each = function (e) {
		return N(this, function (t, n, r) {
			e.call(t, t.__data__, n, r)
		})
	}, ms.call = function (e) {
		var t = qa(arguments);
		return e.apply(t[0] = this, t), this
	}, ms.empty = function () {
		return!this.node()
	}, ms.node = function () {
		for (var e = 0, t = this.length; t > e; e++)for (var n = this[e], r = 0, i = n.length; i > r; r++) {
			var o = n[r];
			if (o)return o
		}
		return null
	}, ms.size = function () {
		var e = 0;
		return this.each(function () {
			++e
		}), e
	};
	var Es = [];
	Ga.selection.enter = z, Ga.selection.enter.prototype = Es, Es.append = ms.append, Es.empty = ms.empty, Es.node = ms.node, Es.call = ms.call, Es.size = ms.size, Es.select = function (e) {
		for (var t, n, r, i, o, a = [], s = -1, l = this.length; ++s < l;) {
			r = (i = this[s]).update, a.push(t = []), t.parentNode = i.parentNode;
			for (var u = -1, c = i.length; ++u < c;)(o = i[u]) ? (t.push(r[u] = n = e.call(i.parentNode, o.__data__, u, s)), n.__data__ = o.__data__) : t.push(null)
		}
		return x(a)
	}, Es.insert = function (e, t) {
		return arguments.length < 2 && (t = U(this)), ms.insert.call(this, e, t)
	}, ms.transition = function () {
		for (var e, t, n = wu || ++Au, r = [], i = Hu || {time: Date.now(), ease: Ti, delay: 0, duration: 250}, o = -1, a = this.length; ++o < a;) {
			r.push(e = []);
			for (var s = this[o], l = -1, u = s.length; ++l < u;)(t = s[l]) && za(t, l, n, i), e.push(t)
		}
		return Da(r, n)
	}, ms.interrupt = function () {
		return this.each(V)
	}, Ga.select = function (e) {
		var t = ["string" == typeof e ? hs(e, Ya) : e];
		return t.parentNode = Ka, x([t])
	}, Ga.selectAll = function (e) {
		var t = qa("string" == typeof e ? fs(e, Ya) : e);
		return t.parentNode = Ka, x([t])
	};
	var vs = Ga.select(Ka);
	ms.on = function (e, t, n) {
		var r = arguments.length;
		if (3 > r) {
			if ("string" != typeof e) {
				2 > r && (t = !1);
				for (n in e)this.each(B(n, e[n], t));
				return this
			}
			if (2 > r)return(r = this.node()["__on" + e]) && r._;
			n = !1
		}
		return this.each(B(e, t, n))
	};
	var ys = Ga.map({mouseenter: "mouseover", mouseleave: "mouseout"});
	ys.forEach(function (e) {
		"on" + e in Ya && ys.remove(e)
	});
	var Ts = "onselectstart"in Ya ? null : p(Ka.style, "userSelect"), xs = 0;
	Ga.mouse = function (e) {
		return W(e, y())
	};
	var Rs = /WebKit/.test(Za.navigator.userAgent) ? -1 : 0;
	Ga.touches = function (e, t) {
		return arguments.length < 2 && (t = y().touches), t ? qa(t).map(function (t) {
			var n = W(e, t);
			return n.identifier = t.identifier, n
		}) : []
	}, Ga.behavior.drag = function () {
		function e() {
			this.on("mousedown.drag", i).on("touchstart.drag", o)
		}

		function t(e, t, i, o, a) {
			return function () {
				function s() {
					var e, n, r = t(f, m);
					r && (e = r[0] - y[0], n = r[1] - y[1], p |= e | n, y = r, d({type: "drag", x: r[0] + u[0], y: r[1] + u[1], dx: e, dy: n}))
				}

				function l() {
					t(f, m) && (E.on(o + g, null).on(a + g, null), v(p && Ga.event.target === h), d({type: "dragend"}))
				}

				var u, c = this, h = Ga.event.target, f = c.parentNode, d = n.of(c, arguments), p = 0, m = e(), g = ".drag" + (null == m ? "" : "-" + m), E = Ga.select(i()).on(o + g, s).on(a + g, l), v = j(), y = t(f, m);
				r ? (u = r.apply(c, arguments), u = [u.x - y[0], u.y - y[1]]) : u = [0, 0], d({type: "dragstart"})
			}
		}

		var n = T(e, "drag", "dragstart", "dragend"), r = null, i = t(m, Ga.mouse, q, "mousemove", "mouseup"), o = t(G, Ga.touch, X, "touchmove", "touchend");
		return e.origin = function (t) {
			return arguments.length ? (r = t, e) : r
		}, Ga.rebind(e, n, "on")
	};
	var bs = Math.PI, _s = 2 * bs, ws = bs / 2, Hs = 1e-6, Ms = Hs * Hs, Ss = bs / 180, Cs = 180 / bs, As = Math.SQRT2, Ls = 2, ks = 4;
	Ga.interpolateZoom = function (e, t) {
		function n(e) {
			var t = e * v;
			if (E) {
				var n = J(m), a = o / (Ls * f) * (n * et(As * t + m) - $(m));
				return[r + a * u, i + a * c, o * n / J(As * t + m)]
			}
			return[r + e * u, i + e * c, o * Math.exp(As * t)]
		}

		var r = e[0], i = e[1], o = e[2], a = t[0], s = t[1], l = t[2], u = a - r, c = s - i, h = u * u + c * c, f = Math.sqrt(h), d = (l * l - o * o + ks * h) / (2 * o * Ls * f), p = (l * l - o * o - ks * h) / (2 * l * Ls * f), m = Math.log(Math.sqrt(d * d + 1) - d), g = Math.log(Math.sqrt(p * p + 1) - p), E = g - m, v = (E || Math.log(l / o)) / As;
		return n.duration = 1e3 * v, n
	}, Ga.behavior.zoom = function () {
		function e(e) {
			e.on(M, u).on(Fs + ".zoom", h).on("dblclick.zoom", f).on(A, c)
		}

		function t(e) {
			return[(e[0] - _.x) / _.k, (e[1] - _.y) / _.k]
		}

		function n(e) {
			return[e[0] * _.k + _.x, e[1] * _.k + _.y]
		}

		function r(e) {
			_.k = Math.max(H[0], Math.min(H[1], e))
		}

		function i(e, t) {
			t = n(t), _.x += e[0] - t[0], _.y += e[1] - t[1]
		}

		function o() {
			x && x.domain(y.range().map(function (e) {
				return(e - _.x) / _.k
			}).map(y.invert)), b && b.domain(R.range().map(function (e) {
				return(e - _.y) / _.k
			}).map(R.invert))
		}

		function a(e) {
			e({type: "zoomstart"})
		}

		function s(e) {
			o(), e({type: "zoom", scale: _.k, translate: [_.x, _.y]})
		}

		function l(e) {
			e({type: "zoomend"})
		}

		function u() {
			function e() {
				c = 1, i(Ga.mouse(r), f), s(u)
			}

			function n() {
				h.on(S, null).on(C, null), d(c && Ga.event.target === o), l(u)
			}

			var r = this, o = Ga.event.target, u = L.of(r, arguments), c = 0, h = Ga.select(Za).on(S, e).on(C, n), f = t(Ga.mouse(r)), d = j();
			V.call(r), a(u)
		}

		function c() {
			function e() {
				var e = Ga.touches(d);
				return f = _.k, e.forEach(function (e) {
					e.identifier in m && (m[e.identifier] = t(e))
				}), e
			}

			function n() {
				var t = Ga.event.target;
				Ga.select(t).on(T, o).on(x, h), R.push(t);
				for (var n = Ga.event.changedTouches, a = 0, l = n.length; l > a; ++a)m[n[a].identifier] = null;
				var u = e(), c = Date.now();
				if (1 === u.length) {
					if (500 > c - E) {
						var f = u[0], d = m[f.identifier];
						r(2 * _.k), i(f, d), v(), s(p)
					}
					E = c
				} else if (u.length > 1) {
					var f = u[0], y = u[1], b = f[0] - y[0], w = f[1] - y[1];
					g = b * b + w * w
				}
			}

			function o() {
				for (var e, t, n, o, a = Ga.touches(d), l = 0, u = a.length; u > l; ++l, o = null)if (n = a[l], o = m[n.identifier]) {
					if (t)break;
					e = n, t = o
				}
				if (o) {
					var c = (c = n[0] - e[0]) * c + (c = n[1] - e[1]) * c, h = g && Math.sqrt(c / g);
					e = [(e[0] + n[0]) / 2, (e[1] + n[1]) / 2], t = [(t[0] + o[0]) / 2, (t[1] + o[1]) / 2], r(h * f)
				}
				E = null, i(e, t), s(p)
			}

			function h() {
				if (Ga.event.touches.length) {
					for (var t = Ga.event.changedTouches, n = 0, r = t.length; r > n; ++n)delete m[t[n].identifier];
					for (var i in m)return void e()
				}
				Ga.selectAll(R).on(y, null), b.on(M, u).on(A, c), w(), l(p)
			}

			var f, d = this, p = L.of(d, arguments), m = {}, g = 0, y = ".zoom-" + Ga.event.changedTouches[0].identifier, T = "touchmove" + y, x = "touchend" + y, R = [], b = Ga.select(d).on(M, null).on(A, n), w = j();
			V.call(d), n(), a(p)
		}

		function h() {
			var e = L.of(this, arguments);
			g ? clearTimeout(g) : (d = t(p = m || Ga.mouse(this)), V.call(this), a(e)), g = setTimeout(function () {
				g = null, l(e)
			}, 50), v(), r(Math.pow(2, .002 * Ps()) * _.k), i(p, d), s(e)
		}

		function f() {
			var e = L.of(this, arguments), n = Ga.mouse(this), o = t(n), u = Math.log(_.k) / Math.LN2;
			a(e), r(Math.pow(2, Ga.event.shiftKey ? Math.ceil(u) - 1 : Math.floor(u) + 1)), i(n, o), s(e), l(e)
		}

		var d, p, m, g, E, y, x, R, b, _ = {x: 0, y: 0, k: 1}, w = [960, 500], H = Ds, M = "mousedown.zoom", S = "mousemove.zoom", C = "mouseup.zoom", A = "touchstart.zoom", L = T(e, "zoomstart", "zoom", "zoomend");
		return e.event = function (e) {
			e.each(function () {
				var e = L.of(this, arguments), t = _;
				wu ? Ga.select(this).transition().each("start.zoom",function () {
					_ = this.__chart__ || {x: 0, y: 0, k: 1}, a(e)
				}).tween("zoom:zoom",function () {
					var n = w[0], r = w[1], i = n / 2, o = r / 2, a = Ga.interpolateZoom([(i - _.x) / _.k, (o - _.y) / _.k, n / _.k], [(i - t.x) / t.k, (o - t.y) / t.k, n / t.k]);
					return function (t) {
						var r = a(t), l = n / r[2];
						this.__chart__ = _ = {x: i - r[0] * l, y: o - r[1] * l, k: l}, s(e)
					}
				}).each("end.zoom", function () {
					l(e)
				}) : (this.__chart__ = _, a(e), s(e), l(e))
			})
		}, e.translate = function (t) {
			return arguments.length ? (_ = {x: +t[0], y: +t[1], k: _.k}, o(), e) : [_.x, _.y]
		}, e.scale = function (t) {
			return arguments.length ? (_ = {x: _.x, y: _.y, k: +t}, o(), e) : _.k
		}, e.scaleExtent = function (t) {
			return arguments.length ? (H = null == t ? Ds : [+t[0], +t[1]], e) : H
		}, e.center = function (t) {
			return arguments.length ? (m = t && [+t[0], +t[1]], e) : m
		}, e.size = function (t) {
			return arguments.length ? (w = t && [+t[0], +t[1]], e) : w
		}, e.x = function (t) {
			return arguments.length ? (x = t, y = t.copy(), _ = {x: 0, y: 0, k: 1}, e) : x
		}, e.y = function (t) {
			return arguments.length ? (b = t, R = t.copy(), _ = {x: 0, y: 0, k: 1}, e) : b
		}, Ga.rebind(e, L, "on")
	};
	var Ps, Ds = [0, 1 / 0], Fs = "onwheel"in Ya ? (Ps = function () {
		return-Ga.event.deltaY * (Ga.event.deltaMode ? 120 : 1)
	}, "wheel") : "onmousewheel"in Ya ? (Ps = function () {
		return Ga.event.wheelDelta
	}, "mousewheel") : (Ps = function () {
		return-Ga.event.detail
	}, "MozMousePixelScroll");
	Ga.color = nt, nt.prototype.toString = function () {
		return this.rgb() + ""
	}, Ga.hsl = rt;
	var Ns = rt.prototype = new nt;
	Ns.brighter = function (e) {
		return e = Math.pow(.7, arguments.length ? e : 1), new rt(this.h, this.s, this.l / e)
	}, Ns.darker = function (e) {
		return e = Math.pow(.7, arguments.length ? e : 1), new rt(this.h, this.s, e * this.l)
	}, Ns.rgb = function () {
		return it(this.h, this.s, this.l)
	}, Ga.hcl = ot;
	var zs = ot.prototype = new nt;
	zs.brighter = function (e) {
		return new ot(this.h, this.c, Math.min(100, this.l + Us * (arguments.length ? e : 1)))
	}, zs.darker = function (e) {
		return new ot(this.h, this.c, Math.max(0, this.l - Us * (arguments.length ? e : 1)))
	}, zs.rgb = function () {
		return at(this.h, this.c, this.l).rgb()
	}, Ga.lab = st;
	var Us = 18, Vs = .95047, Bs = 1, Os = 1.08883, Is = st.prototype = new nt;
	Is.brighter = function (e) {
		return new st(Math.min(100, this.l + Us * (arguments.length ? e : 1)), this.a, this.b)
	}, Is.darker = function (e) {
		return new st(Math.max(0, this.l - Us * (arguments.length ? e : 1)), this.a, this.b)
	}, Is.rgb = function () {
		return lt(this.l, this.a, this.b)
	}, Ga.rgb = dt;
	var js = dt.prototype = new nt;
	js.brighter = function (e) {
		e = Math.pow(.7, arguments.length ? e : 1);
		var t = this.r, n = this.g, r = this.b, i = 30;
		return t || n || r ? (t && i > t && (t = i), n && i > n && (n = i), r && i > r && (r = i), new dt(Math.min(255, t / e), Math.min(255, n / e), Math.min(255, r / e))) : new dt(i, i, i)
	}, js.darker = function (e) {
		return e = Math.pow(.7, arguments.length ? e : 1), new dt(e * this.r, e * this.g, e * this.b)
	}, js.hsl = function () {
		return vt(this.r, this.g, this.b)
	}, js.toString = function () {
		return"#" + gt(this.r) + gt(this.g) + gt(this.b)
	};
	var Ws = Ga.map({aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074});
	Ws.forEach(function (e, t) {
		Ws.set(e, pt(t))
	}), Ga.functor = Rt, Ga.xhr = _t(bt), Ga.dsv = function (e, t) {
		function n(e, n, o) {
			arguments.length < 3 && (o = n, n = null);
			var a = wt(e, t, null == n ? r : i(n), o);
			return a.row = function (e) {
				return arguments.length ? a.response(null == (n = e) ? r : i(e)) : n
			}, a
		}

		function r(e) {
			return n.parse(e.responseText)
		}

		function i(e) {
			return function (t) {
				return n.parse(t.responseText, e)
			}
		}

		function o(t) {
			return t.map(a).join(e)
		}

		function a(e) {
			return s.test(e) ? '"' + e.replace(/\"/g, '""') + '"' : e
		}

		var s = new RegExp('["' + e + "\n]"), l = e.charCodeAt(0);
		return n.parse = function (e, t) {
			var r;
			return n.parseRows(e, function (e, n) {
				if (r)return r(e, n - 1);
				var i = new Function("d", "return {" + e.map(function (e, t) {
					return JSON.stringify(e) + ": d[" + t + "]"
				}).join(",") + "}");
				r = t ? function (e, n) {
					return t(i(e), n)
				} : i
			})
		}, n.parseRows = function (e, t) {
			function n() {
				if (c >= u)return a;
				if (i)return i = !1, o;
				var t = c;
				if (34 === e.charCodeAt(t)) {
					for (var n = t; n++ < u;)if (34 === e.charCodeAt(n)) {
						if (34 !== e.charCodeAt(n + 1))break;
						++n
					}
					c = n + 2;
					var r = e.charCodeAt(n + 1);
					return 13 === r ? (i = !0, 10 === e.charCodeAt(n + 2) && ++c) : 10 === r && (i = !0), e.substring(t + 1, n).replace(/""/g, '"')
				}
				for (; u > c;) {
					var r = e.charCodeAt(c++), s = 1;
					if (10 === r)i = !0; else if (13 === r)i = !0, 10 === e.charCodeAt(c) && (++c, ++s); else if (r !== l)continue;
					return e.substring(t, c - s)
				}
				return e.substring(t)
			}

			for (var r, i, o = {}, a = {}, s = [], u = e.length, c = 0, h = 0; (r = n()) !== a;) {
				for (var f = []; r !== o && r !== a;)f.push(r), r = n();
				(!t || (f = t(f, h++))) && s.push(f)
			}
			return s
		}, n.format = function (t) {
			if (Array.isArray(t[0]))return n.formatRows(t);
			var r = new f, i = [];
			return t.forEach(function (e) {
				for (var t in e)r.has(t) || i.push(r.add(t))
			}), [i.map(a).join(e)].concat(t.map(function (t) {
				return i.map(function (e) {
					return a(t[e])
				}).join(e)
			})).join("\n")
		}, n.formatRows = function (e) {
			return e.map(o).join("\n")
		}, n
	}, Ga.csv = Ga.dsv(",", "text/csv"), Ga.tsv = Ga.dsv("	", "text/tab-separated-values"), Ga.touch = function (e, t, n) {
		if (arguments.length < 3 && (n = t, t = y().changedTouches), t)for (var r, i = 0, o = t.length; o > i; ++i)if ((r = t[i]).identifier === n)return W(e, r)
	};
	var Gs, Xs, qs, Ys, Ks, Zs = Za[p(Za, "requestAnimationFrame")] || function (e) {
		setTimeout(e, 17)
	};
	Ga.timer = function (e, t, n) {
		var r = arguments.length;
		2 > r && (t = 0), 3 > r && (n = Date.now());
		var i = n + t, o = {c: e, t: i, f: !1, n: null};
		Xs ? Xs.n = o : Gs = o, Xs = o, qs || (Ys = clearTimeout(Ys), qs = 1, Zs(Mt))
	}, Ga.timer.flush = function () {
		St(), Ct()
	}, Ga.round = function (e, t) {
		return t ? Math.round(e * (t = Math.pow(10, t))) / t : Math.round(e)
	};
	var Qs = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"].map(Lt);
	Ga.formatPrefix = function (e, t) {
		var n = 0;
		return e && (0 > e && (e *= -1), t && (e = Ga.round(e, At(e, t))), n = 1 + Math.floor(1e-12 + Math.log(e) / Math.LN10), n = Math.max(-24, Math.min(24, 3 * Math.floor((n - 1) / 3)))), Qs[8 + n / 3]
	};
	var $s = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i, Js = Ga.map({b: function (e) {
		return e.toString(2)
	}, c: function (e) {
		return String.fromCharCode(e)
	}, o: function (e) {
		return e.toString(8)
	}, x: function (e) {
		return e.toString(16)
	}, X: function (e) {
		return e.toString(16).toUpperCase()
	}, g: function (e, t) {
		return e.toPrecision(t)
	}, e: function (e, t) {
		return e.toExponential(t)
	}, f: function (e, t) {
		return e.toFixed(t)
	}, r: function (e, t) {
		return(e = Ga.round(e, At(e, t))).toFixed(Math.max(0, Math.min(20, At(e * (1 + 1e-15), t))))
	}}), el = Ga.time = {}, tl = Date;
	Dt.prototype = {getDate: function () {
		return this._.getUTCDate()
	}, getDay: function () {
		return this._.getUTCDay()
	}, getFullYear: function () {
		return this._.getUTCFullYear()
	}, getHours: function () {
		return this._.getUTCHours()
	}, getMilliseconds: function () {
		return this._.getUTCMilliseconds()
	}, getMinutes: function () {
		return this._.getUTCMinutes()
	}, getMonth: function () {
		return this._.getUTCMonth()
	}, getSeconds: function () {
		return this._.getUTCSeconds()
	}, getTime: function () {
		return this._.getTime()
	}, getTimezoneOffset: function () {
		return 0
	}, valueOf: function () {
		return this._.valueOf()
	}, setDate: function () {
		nl.setUTCDate.apply(this._, arguments)
	}, setDay: function () {
		nl.setUTCDay.apply(this._, arguments)
	}, setFullYear: function () {
		nl.setUTCFullYear.apply(this._, arguments)
	}, setHours: function () {
		nl.setUTCHours.apply(this._, arguments)
	}, setMilliseconds: function () {
		nl.setUTCMilliseconds.apply(this._, arguments)
	}, setMinutes: function () {
		nl.setUTCMinutes.apply(this._, arguments)
	}, setMonth: function () {
		nl.setUTCMonth.apply(this._, arguments)
	}, setSeconds: function () {
		nl.setUTCSeconds.apply(this._, arguments)
	}, setTime: function () {
		nl.setTime.apply(this._, arguments)
	}};
	var nl = Date.prototype;
	el.year = Ft(function (e) {
		return e = el.day(e), e.setMonth(0, 1), e
	}, function (e, t) {
		e.setFullYear(e.getFullYear() + t)
	}, function (e) {
		return e.getFullYear()
	}), el.years = el.year.range, el.years.utc = el.year.utc.range, el.day = Ft(function (e) {
		var t = new tl(2e3, 0);
		return t.setFullYear(e.getFullYear(), e.getMonth(), e.getDate()), t
	}, function (e, t) {
		e.setDate(e.getDate() + t)
	}, function (e) {
		return e.getDate() - 1
	}), el.days = el.day.range, el.days.utc = el.day.utc.range, el.dayOfYear = function (e) {
		var t = el.year(e);
		return Math.floor((e - t - 6e4 * (e.getTimezoneOffset() - t.getTimezoneOffset())) / 864e5)
	}, ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"].forEach(function (e, t) {
		t = 7 - t;
		var n = el[e] = Ft(function (e) {
			return(e = el.day(e)).setDate(e.getDate() - (e.getDay() + t) % 7), e
		}, function (e, t) {
			e.setDate(e.getDate() + 7 * Math.floor(t))
		}, function (e) {
			var n = el.year(e).getDay();
			return Math.floor((el.dayOfYear(e) + (n + t) % 7) / 7) - (n !== t)
		});
		el[e + "s"] = n.range, el[e + "s"].utc = n.utc.range, el[e + "OfYear"] = function (e) {
			var n = el.year(e).getDay();
			return Math.floor((el.dayOfYear(e) + (n + t) % 7) / 7)
		}
	}), el.week = el.sunday, el.weeks = el.sunday.range, el.weeks.utc = el.sunday.utc.range, el.weekOfYear = el.sundayOfYear;
	var rl = {"-": "", _: " ", 0: "0"}, il = /^\s*\d+/, ol = /^%/;
	Ga.locale = function (e) {
		return{numberFormat: kt(e), timeFormat: zt(e)}
	};
	var al = Ga.locale({decimal: ".", thousands: ",", grouping: [3], currency: ["$", ""], dateTime: "%a %b %e %X %Y", date: "%m/%d/%Y", time: "%H:%M:%S", periods: ["AM", "PM"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]});
	Ga.format = al.numberFormat, Ga.geo = {}, on.prototype = {s: 0, t: 0, add: function (e) {
		an(e, this.t, sl), an(sl.s, this.s, this), this.s ? this.t += sl.t : this.s = sl.t
	}, reset: function () {
		this.s = this.t = 0
	}, valueOf: function () {
		return this.s
	}};
	var sl = new on;
	Ga.geo.stream = function (e, t) {
		e && ll.hasOwnProperty(e.type) ? ll[e.type](e, t) : sn(e, t)
	};
	var ll = {Feature: function (e, t) {
		sn(e.geometry, t)
	}, FeatureCollection: function (e, t) {
		for (var n = e.features, r = -1, i = n.length; ++r < i;)sn(n[r].geometry, t)
	}}, ul = {Sphere: function (e, t) {
		t.sphere()
	}, Point: function (e, t) {
		e = e.coordinates, t.point(e[0], e[1], e[2])
	}, MultiPoint: function (e, t) {
		for (var n = e.coordinates, r = -1, i = n.length; ++r < i;)e = n[r], t.point(e[0], e[1], e[2])
	}, LineString: function (e, t) {
		ln(e.coordinates, t, 0)
	}, MultiLineString: function (e, t) {
		for (var n = e.coordinates, r = -1, i = n.length; ++r < i;)ln(n[r], t, 0)
	}, Polygon: function (e, t) {
		un(e.coordinates, t)
	}, MultiPolygon: function (e, t) {
		for (var n = e.coordinates, r = -1, i = n.length; ++r < i;)un(n[r], t)
	}, GeometryCollection: function (e, t) {
		for (var n = e.geometries, r = -1, i = n.length; ++r < i;)sn(n[r], t)
	}};
	Ga.geo.area = function (e) {
		return cl = 0, Ga.geo.stream(e, fl), cl
	};
	var cl, hl = new on, fl = {sphere: function () {
		cl += 4 * bs
	}, point: m, lineStart: m, lineEnd: m, polygonStart: function () {
		hl.reset(), fl.lineStart = cn
	}, polygonEnd: function () {
		var e = 2 * hl;
		cl += 0 > e ? 4 * bs + e : e, fl.lineStart = fl.lineEnd = fl.point = m
	}};
	Ga.geo.bounds = function () {
		function e(e, t) {
			y.push(T = [c = e, f = e]), h > t && (h = t), t > d && (d = t)
		}

		function t(t, n) {
			var r = hn([t * Ss, n * Ss]);
			if (E) {
				var i = dn(E, r), o = [i[1], -i[0], 0], a = dn(o, i);
				gn(a), a = En(a);
				var l = t - p, u = l > 0 ? 1 : -1, m = a[0] * Cs * u, g = os(l) > 180;
				if (g ^ (m > u * p && u * t > m)) {
					var v = a[1] * Cs;
					v > d && (d = v)
				} else if (m = (m + 360) % 360 - 180, g ^ (m > u * p && u * t > m)) {
					var v = -a[1] * Cs;
					h > v && (h = v)
				} else h > n && (h = n), n > d && (d = n);
				g ? p > t ? s(c, t) > s(c, f) && (f = t) : s(t, f) > s(c, f) && (c = t) : f >= c ? (c > t && (c = t), t > f && (f = t)) : t > p ? s(c, t) > s(c, f) && (f = t) : s(t, f) > s(c, f) && (c = t)
			} else e(t, n);
			E = r, p = t
		}

		function n() {
			x.point = t
		}

		function r() {
			T[0] = c, T[1] = f, x.point = e, E = null
		}

		function i(e, n) {
			if (E) {
				var r = e - p;
				v += os(r) > 180 ? r + (r > 0 ? 360 : -360) : r
			} else m = e, g = n;
			fl.point(e, n), t(e, n)
		}

		function o() {
			fl.lineStart()
		}

		function a() {
			i(m, g), fl.lineEnd(), os(v) > Hs && (c = -(f = 180)), T[0] = c, T[1] = f, E = null
		}

		function s(e, t) {
			return(t -= e) < 0 ? t + 360 : t
		}

		function l(e, t) {
			return e[0] - t[0]
		}

		function u(e, t) {
			return t[0] <= t[1] ? t[0] <= e && e <= t[1] : e < t[0] || t[1] < e
		}

		var c, h, f, d, p, m, g, E, v, y, T, x = {point: e, lineStart: n, lineEnd: r, polygonStart: function () {
			x.point = i, x.lineStart = o, x.lineEnd = a, v = 0, fl.polygonStart()
		}, polygonEnd: function () {
			fl.polygonEnd(), x.point = e, x.lineStart = n, x.lineEnd = r, 0 > hl ? (c = -(f = 180), h = -(d = 90)) : v > Hs ? d = 90 : -Hs > v && (h = -90), T[0] = c, T[1] = f
		}};
		return function (e) {
			d = f = -(c = h = 1 / 0), y = [], Ga.geo.stream(e, x);
			var t = y.length;
			if (t) {
				y.sort(l);
				for (var n, r = 1, i = y[0], o = [i]; t > r; ++r)n = y[r], u(n[0], i) || u(n[1], i) ? (s(i[0], n[1]) > s(i[0], i[1]) && (i[1] = n[1]), s(n[0], i[1]) > s(i[0], i[1]) && (i[0] = n[0])) : o.push(i = n);
				for (var a, n, p = -1 / 0, t = o.length - 1, r = 0, i = o[t]; t >= r; i = n, ++r)n = o[r], (a = s(i[1], n[0])) > p && (p = a, c = n[0], f = i[1])
			}
			return y = T = null, 1 / 0 === c || 1 / 0 === h ? [
				[0 / 0, 0 / 0],
				[0 / 0, 0 / 0]
			] : [
				[c, h],
				[f, d]
			]
		}
	}(), Ga.geo.centroid = function (e) {
		dl = pl = ml = gl = El = vl = yl = Tl = xl = Rl = bl = 0, Ga.geo.stream(e, _l);
		var t = xl, n = Rl, r = bl, i = t * t + n * n + r * r;
		return Ms > i && (t = vl, n = yl, r = Tl, Hs > pl && (t = ml, n = gl, r = El), i = t * t + n * n + r * r, Ms > i) ? [0 / 0, 0 / 0] : [Math.atan2(n, t) * Cs, Q(r / Math.sqrt(i)) * Cs]
	};
	var dl, pl, ml, gl, El, vl, yl, Tl, xl, Rl, bl, _l = {sphere: m, point: yn, lineStart: xn, lineEnd: Rn, polygonStart: function () {
		_l.lineStart = bn
	}, polygonEnd: function () {
		_l.lineStart = xn
	}}, wl = Sn(_n, Pn, Fn, [-bs, -bs / 2]), Hl = 1e9;
	Ga.geo.clipExtent = function () {
		var e, t, n, r, i, o, a = {stream: function (e) {
			return i && (i.valid = !1), i = o(e), i.valid = !0, i
		}, extent: function (s) {
			return arguments.length ? (o = Un(e = +s[0][0], t = +s[0][1], n = +s[1][0], r = +s[1][1]), i && (i.valid = !1, i = null), a) : [
				[e, t],
				[n, r]
			]
		}};
		return a.extent([
			[0, 0],
			[960, 500]
		])
	}, (Ga.geo.conicEqualArea = function () {
		return Bn(On)
	}).raw = On, Ga.geo.albers = function () {
		return Ga.geo.conicEqualArea().rotate([96, 0]).center([-.6, 38.7]).parallels([29.5, 45.5]).scale(1070)
	}, Ga.geo.albersUsa = function () {
		function e(e) {
			var o = e[0], a = e[1];
			return t = null, n(o, a), t || (r(o, a), t) || i(o, a), t
		}

		var t, n, r, i, o = Ga.geo.albers(), a = Ga.geo.conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), s = Ga.geo.conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), l = {point: function (e, n) {
			t = [e, n]
		}};
		return e.invert = function (e) {
			var t = o.scale(), n = o.translate(), r = (e[0] - n[0]) / t, i = (e[1] - n[1]) / t;
			return(i >= .12 && .234 > i && r >= -.425 && -.214 > r ? a : i >= .166 && .234 > i && r >= -.214 && -.115 > r ? s : o).invert(e)
		}, e.stream = function (e) {
			var t = o.stream(e), n = a.stream(e), r = s.stream(e);
			return{point: function (e, i) {
				t.point(e, i), n.point(e, i), r.point(e, i)
			}, sphere: function () {
				t.sphere(), n.sphere(), r.sphere()
			}, lineStart: function () {
				t.lineStart(), n.lineStart(), r.lineStart()
			}, lineEnd: function () {
				t.lineEnd(), n.lineEnd(), r.lineEnd()
			}, polygonStart: function () {
				t.polygonStart(), n.polygonStart(), r.polygonStart()
			}, polygonEnd: function () {
				t.polygonEnd(), n.polygonEnd(), r.polygonEnd()
			}}
		}, e.precision = function (t) {
			return arguments.length ? (o.precision(t), a.precision(t), s.precision(t), e) : o.precision()
		}, e.scale = function (t) {
			return arguments.length ? (o.scale(t), a.scale(.35 * t), s.scale(t), e.translate(o.translate())) : o.scale()
		}, e.translate = function (t) {
			if (!arguments.length)return o.translate();
			var u = o.scale(), c = +t[0], h = +t[1];
			return n = o.translate(t).clipExtent([
				[c - .455 * u, h - .238 * u],
				[c + .455 * u, h + .238 * u]
			]).stream(l).point, r = a.translate([c - .307 * u, h + .201 * u]).clipExtent([
				[c - .425 * u + Hs, h + .12 * u + Hs],
				[c - .214 * u - Hs, h + .234 * u - Hs]
			]).stream(l).point, i = s.translate([c - .205 * u, h + .212 * u]).clipExtent([
				[c - .214 * u + Hs, h + .166 * u + Hs],
				[c - .115 * u - Hs, h + .234 * u - Hs]
			]).stream(l).point, e
		}, e.scale(1070)
	};
	var Ml, Sl, Cl, Al, Ll, kl, Pl = {point: m, lineStart: m, lineEnd: m, polygonStart: function () {
		Sl = 0, Pl.lineStart = In
	}, polygonEnd: function () {
		Pl.lineStart = Pl.lineEnd = Pl.point = m, Ml += os(Sl / 2)
	}}, Dl = {point: jn, lineStart: m, lineEnd: m, polygonStart: m, polygonEnd: m}, Fl = {point: Xn, lineStart: qn, lineEnd: Yn, polygonStart: function () {
		Fl.lineStart = Kn
	}, polygonEnd: function () {
		Fl.point = Xn, Fl.lineStart = qn, Fl.lineEnd = Yn
	}};
	Ga.geo.path = function () {
		function e(e) {
			return e && ("function" == typeof s && o.pointRadius(+s.apply(this, arguments)), a && a.valid || (a = i(o)), Ga.geo.stream(e, a)), o.result()
		}

		function t() {
			return a = null, e
		}

		var n, r, i, o, a, s = 4.5;
		return e.area = function (e) {
			return Ml = 0, Ga.geo.stream(e, i(Pl)), Ml
		}, e.centroid = function (e) {
			return ml = gl = El = vl = yl = Tl = xl = Rl = bl = 0, Ga.geo.stream(e, i(Fl)), bl ? [xl / bl, Rl / bl] : Tl ? [vl / Tl, yl / Tl] : El ? [ml / El, gl / El] : [0 / 0, 0 / 0]
		}, e.bounds = function (e) {
			return Ll = kl = -(Cl = Al = 1 / 0), Ga.geo.stream(e, i(Dl)), [
				[Cl, Al],
				[Ll, kl]
			]
		}, e.projection = function (e) {
			return arguments.length ? (i = (n = e) ? e.stream || $n(e) : bt, t()) : n
		}, e.context = function (e) {
			return arguments.length ? (o = null == (r = e) ? new Wn : new Zn(e), "function" != typeof s && o.pointRadius(s), t()) : r
		}, e.pointRadius = function (t) {
			return arguments.length ? (s = "function" == typeof t ? t : (o.pointRadius(+t), +t), e) : s
		}, e.projection(Ga.geo.albersUsa()).context(null)
	}, Ga.geo.transform = function (e) {
		return{stream: function (t) {
			var n = new Jn(t);
			for (var r in e)n[r] = e[r];
			return n
		}}
	}, Jn.prototype = {point: function (e, t) {
		this.stream.point(e, t)
	}, sphere: function () {
		this.stream.sphere()
	}, lineStart: function () {
		this.stream.lineStart()
	}, lineEnd: function () {
		this.stream.lineEnd()
	}, polygonStart: function () {
		this.stream.polygonStart()
	}, polygonEnd: function () {
		this.stream.polygonEnd()
	}}, Ga.geo.projection = tr, Ga.geo.projectionMutator = nr, (Ga.geo.equirectangular = function () {
		return tr(ir)
	}).raw = ir.invert = ir, Ga.geo.rotation = function (e) {
		function t(t) {
			return t = e(t[0] * Ss, t[1] * Ss), t[0] *= Cs, t[1] *= Cs, t
		}

		return e = ar(e[0] % 360 * Ss, e[1] * Ss, e.length > 2 ? e[2] * Ss : 0), t.invert = function (t) {
			return t = e.invert(t[0] * Ss, t[1] * Ss), t[0] *= Cs, t[1] *= Cs, t
		}, t
	}, or.invert = ir, Ga.geo.circle = function () {
		function e() {
			var e = "function" == typeof r ? r.apply(this, arguments) : r, t = ar(-e[0] * Ss, -e[1] * Ss, 0).invert, i = [];
			return n(null, null, 1, {point: function (e, n) {
				i.push(e = t(e, n)), e[0] *= Cs, e[1] *= Cs
			}}), {type: "Polygon", coordinates: [i]}
		}

		var t, n, r = [0, 0], i = 6;
		return e.origin = function (t) {
			return arguments.length ? (r = t, e) : r
		}, e.angle = function (r) {
			return arguments.length ? (n = cr((t = +r) * Ss, i * Ss), e) : t
		}, e.precision = function (r) {
			return arguments.length ? (n = cr(t * Ss, (i = +r) * Ss), e) : i
		}, e.angle(90)
	}, Ga.geo.distance = function (e, t) {
		var n, r = (t[0] - e[0]) * Ss, i = e[1] * Ss, o = t[1] * Ss, a = Math.sin(r), s = Math.cos(r), l = Math.sin(i), u = Math.cos(i), c = Math.sin(o), h = Math.cos(o);
		return Math.atan2(Math.sqrt((n = h * a) * n + (n = u * c - l * h * s) * n), l * c + u * h * s)
	}, Ga.geo.graticule = function () {
		function e() {
			return{type: "MultiLineString", coordinates: t()}
		}

		function t() {
			return Ga.range(Math.ceil(o / g) * g, i, g).map(f).concat(Ga.range(Math.ceil(u / E) * E, l, E).map(d)).concat(Ga.range(Math.ceil(r / p) * p, n, p).filter(function (e) {
				return os(e % g) > Hs
			}).map(c)).concat(Ga.range(Math.ceil(s / m) * m, a, m).filter(function (e) {
				return os(e % E) > Hs
			}).map(h))
		}

		var n, r, i, o, a, s, l, u, c, h, f, d, p = 10, m = p, g = 90, E = 360, v = 2.5;
		return e.lines = function () {
			return t().map(function (e) {
				return{type: "LineString", coordinates: e}
			})
		}, e.outline = function () {
			return{type: "Polygon", coordinates: [f(o).concat(d(l).slice(1), f(i).reverse().slice(1), d(u).reverse().slice(1))]}
		}, e.extent = function (t) {
			return arguments.length ? e.majorExtent(t).minorExtent(t) : e.minorExtent()
		}, e.majorExtent = function (t) {
			return arguments.length ? (o = +t[0][0], i = +t[1][0], u = +t[0][1], l = +t[1][1], o > i && (t = o, o = i, i = t), u > l && (t = u, u = l, l = t), e.precision(v)) : [
				[o, u],
				[i, l]
			]
		}, e.minorExtent = function (t) {
			return arguments.length ? (r = +t[0][0], n = +t[1][0], s = +t[0][1], a = +t[1][1], r > n && (t = r, r = n, n = t), s > a && (t = s, s = a, a = t), e.precision(v)) : [
				[r, s],
				[n, a]
			]
		}, e.step = function (t) {
			return arguments.length ? e.majorStep(t).minorStep(t) : e.minorStep()
		}, e.majorStep = function (t) {
			return arguments.length ? (g = +t[0], E = +t[1], e) : [g, E]
		}, e.minorStep = function (t) {
			return arguments.length ? (p = +t[0], m = +t[1], e) : [p, m]
		}, e.precision = function (t) {
			return arguments.length ? (v = +t, c = fr(s, a, 90), h = dr(r, n, v), f = fr(u, l, 90), d = dr(o, i, v), e) : v
		}, e.majorExtent([
			[-180, -90 + Hs],
			[180, 90 - Hs]
		]).minorExtent([
			[-180, -80 - Hs],
			[180, 80 + Hs]
		])
	}, Ga.geo.greatArc = function () {
		function e() {
			return{type: "LineString", coordinates: [t || r.apply(this, arguments), n || i.apply(this, arguments)]}
		}

		var t, n, r = pr, i = mr;
		return e.distance = function () {
			return Ga.geo.distance(t || r.apply(this, arguments), n || i.apply(this, arguments))
		}, e.source = function (n) {
			return arguments.length ? (r = n, t = "function" == typeof n ? null : n, e) : r
		}, e.target = function (t) {
			return arguments.length ? (i = t, n = "function" == typeof t ? null : t, e) : i
		}, e.precision = function () {
			return arguments.length ? e : 0
		}, e
	}, Ga.geo.interpolate = function (e, t) {
		return gr(e[0] * Ss, e[1] * Ss, t[0] * Ss, t[1] * Ss)
	}, Ga.geo.length = function (e) {
		return Nl = 0, Ga.geo.stream(e, zl), Nl
	};
	var Nl, zl = {sphere: m, point: m, lineStart: Er, lineEnd: m, polygonStart: m, polygonEnd: m}, Ul = vr(function (e) {
		return Math.sqrt(2 / (1 + e))
	}, function (e) {
		return 2 * Math.asin(e / 2)
	});
	(Ga.geo.azimuthalEqualArea = function () {
		return tr(Ul)
	}).raw = Ul;
	var Vl = vr(function (e) {
		var t = Math.acos(e);
		return t && t / Math.sin(t)
	}, bt);
	(Ga.geo.azimuthalEquidistant = function () {
		return tr(Vl)
	}).raw = Vl, (Ga.geo.conicConformal = function () {
		return Bn(yr)
	}).raw = yr, (Ga.geo.conicEquidistant = function () {
		return Bn(Tr)
	}).raw = Tr;
	var Bl = vr(function (e) {
		return 1 / e
	}, Math.atan);
	(Ga.geo.gnomonic = function () {
		return tr(Bl)
	}).raw = Bl, xr.invert = function (e, t) {
		return[e, 2 * Math.atan(Math.exp(t)) - ws]
	}, (Ga.geo.mercator = function () {
		return Rr(xr)
	}).raw = xr;
	var Ol = vr(function () {
		return 1
	}, Math.asin);
	(Ga.geo.orthographic = function () {
		return tr(Ol)
	}).raw = Ol;
	var Il = vr(function (e) {
		return 1 / (1 + e)
	}, function (e) {
		return 2 * Math.atan(e)
	});
	(Ga.geo.stereographic = function () {
		return tr(Il)
	}).raw = Il, br.invert = function (e, t) {
		return[-t, 2 * Math.atan(Math.exp(e)) - ws]
	}, (Ga.geo.transverseMercator = function () {
		var e = Rr(br), t = e.center, n = e.rotate;
		return e.center = function (e) {
			return e ? t([-e[1], e[0]]) : (e = t(), [e[1], -e[0]])
		}, e.rotate = function (e) {
			return e ? n([e[0], e[1], e.length > 2 ? e[2] + 90 : 90]) : (e = n(), [e[0], e[1], e[2] - 90])
		}, n([0, 0, 90])
	}).raw = br, Ga.geom = {}, Ga.geom.hull = function (e) {
		function t(e) {
			if (e.length < 3)return[];
			var t, i = Rt(n), o = Rt(r), a = e.length, s = [], l = [];
			for (t = 0; a > t; t++)s.push([+i.call(this, e[t], t), +o.call(this, e[t], t), t]);
			for (s.sort(Mr), t = 0; a > t; t++)l.push([s[t][0], -s[t][1]]);
			var u = Hr(s), c = Hr(l), h = c[0] === u[0], f = c[c.length - 1] === u[u.length - 1], d = [];
			for (t = u.length - 1; t >= 0; --t)d.push(e[s[u[t]][2]]);
			for (t = +h; t < c.length - f; ++t)d.push(e[s[c[t]][2]]);
			return d
		}

		var n = _r, r = wr;
		return arguments.length ? t(e) : (t.x = function (e) {
			return arguments.length ? (n = e, t) : n
		}, t.y = function (e) {
			return arguments.length ? (r = e, t) : r
		}, t)
	}, Ga.geom.polygon = function (e) {
		return cs(e, jl), e
	};
	var jl = Ga.geom.polygon.prototype = [];
	jl.area = function () {
		for (var e, t = -1, n = this.length, r = this[n - 1], i = 0; ++t < n;)e = r, r = this[t], i += e[1] * r[0] - e[0] * r[1];
		return.5 * i
	}, jl.centroid = function (e) {
		var t, n, r = -1, i = this.length, o = 0, a = 0, s = this[i - 1];
		for (arguments.length || (e = -1 / (6 * this.area())); ++r < i;)t = s, s = this[r], n = t[0] * s[1] - s[0] * t[1], o += (t[0] + s[0]) * n, a += (t[1] + s[1]) * n;
		return[o * e, a * e]
	}, jl.clip = function (e) {
		for (var t, n, r, i, o, a, s = Ar(e), l = -1, u = this.length - Ar(this), c = this[u - 1]; ++l < u;) {
			for (t = e.slice(), e.length = 0, i = this[l], o = t[(r = t.length - s) - 1], n = -1; ++n < r;)a = t[n], Sr(a, c, i) ? (Sr(o, c, i) || e.push(Cr(o, a, c, i)), e.push(a)) : Sr(o, c, i) && e.push(Cr(o, a, c, i)), o = a;
			s && e.push(e[0]), c = i
		}
		return e
	};
	var Wl, Gl, Xl, ql, Yl, Kl = [], Zl = [];
	Ur.prototype.prepare = function () {
		for (var e, t = this.edges, n = t.length; n--;)e = t[n].edge, e.b && e.a || t.splice(n, 1);
		return t.sort(Br), t.length
	}, Zr.prototype = {start: function () {
		return this.edge.l === this.site ? this.edge.a : this.edge.b
	}, end: function () {
		return this.edge.l === this.site ? this.edge.b : this.edge.a
	}}, Qr.prototype = {insert: function (e, t) {
		var n, r, i;
		if (e) {
			if (t.P = e, t.N = e.N, e.N && (e.N.P = t), e.N = t, e.R) {
				for (e = e.R; e.L;)e = e.L;
				e.L = t
			} else e.R = t;
			n = e
		} else this._ ? (e = ti(this._), t.P = null, t.N = e, e.P = e.L = t, n = e) : (t.P = t.N = null, this._ = t, n = null);
		for (t.L = t.R = null, t.U = n, t.C = !0, e = t; n && n.C;)r = n.U, n === r.L ? (i = r.R, i && i.C ? (n.C = i.C = !1, r.C = !0, e = r) : (e === n.R && (Jr(this, n), e = n, n = e.U), n.C = !1, r.C = !0, ei(this, r))) : (i = r.L, i && i.C ? (n.C = i.C = !1, r.C = !0, e = r) : (e === n.L && (ei(this, n), e = n, n = e.U), n.C = !1, r.C = !0, Jr(this, r))), n = e.U;
		this._.C = !1
	}, remove: function (e) {
		e.N && (e.N.P = e.P), e.P && (e.P.N = e.N), e.N = e.P = null;
		var t, n, r, i = e.U, o = e.L, a = e.R;
		if (n = o ? a ? ti(a) : o : a, i ? i.L === e ? i.L = n : i.R = n : this._ = n, o && a ? (r = n.C, n.C = e.C, n.L = o, o.U = n, n !== a ? (i = n.U, n.U = e.U, e = n.R, i.L = e, n.R = a, a.U = n) : (n.U = i, i = n, e = n.R)) : (r = e.C, e = n), e && (e.U = i), !r) {
			if (e && e.C)return void(e.C = !1);
			do {
				if (e === this._)break;
				if (e === i.L) {
					if (t = i.R, t.C && (t.C = !1, i.C = !0, Jr(this, i), t = i.R), t.L && t.L.C || t.R && t.R.C) {
						t.R && t.R.C || (t.L.C = !1, t.C = !0, ei(this, t), t = i.R), t.C = i.C, i.C = t.R.C = !1, Jr(this, i), e = this._;
						break
					}
				} else if (t = i.L, t.C && (t.C = !1, i.C = !0, ei(this, i), t = i.L), t.L && t.L.C || t.R && t.R.C) {
					t.L && t.L.C || (t.R.C = !1, t.C = !0, Jr(this, t), t = i.L), t.C = i.C, i.C = t.L.C = !1, ei(this, i), e = this._;
					break
				}
				t.C = !0, e = i, i = i.U
			} while (!e.C);
			e && (e.C = !1)
		}
	}}, Ga.geom.voronoi = function (e) {
		function t(e) {
			var t = new Array(e.length), r = s[0][0], i = s[0][1], o = s[1][0], a = s[1][1];
			return ni(n(e), s).cells.forEach(function (n, s) {
				var l = n.edges, u = n.site, c = t[s] = l.length ? l.map(function (e) {
					var t = e.start();
					return[t.x, t.y]
				}) : u.x >= r && u.x <= o && u.y >= i && u.y <= a ? [
					[r, a],
					[o, a],
					[o, i],
					[r, i]
				] : [];
				c.point = e[s]
			}), t
		}

		function n(e) {
			return e.map(function (e, t) {
				return{x: Math.round(o(e, t) / Hs) * Hs, y: Math.round(a(e, t) / Hs) * Hs, i: t}
			})
		}

		var r = _r, i = wr, o = r, a = i, s = Ql;
		return e ? t(e) : (t.links = function (e) {
			return ni(n(e)).edges.filter(function (e) {
				return e.l && e.r
			}).map(function (t) {
				return{source: e[t.l.i], target: e[t.r.i]}
			})
		}, t.triangles = function (e) {
			var t = [];
			return ni(n(e)).cells.forEach(function (n, r) {
				for (var i, o, a = n.site, s = n.edges.sort(Br), l = -1, u = s.length, c = s[u - 1].edge, h = c.l === a ? c.r : c.l; ++l < u;)i = c, o = h, c = s[l].edge, h = c.l === a ? c.r : c.l, r < o.i && r < h.i && ii(a, o, h) < 0 && t.push([e[r], e[o.i], e[h.i]])
			}), t
		}, t.x = function (e) {
			return arguments.length ? (o = Rt(r = e), t) : r
		}, t.y = function (e) {
			return arguments.length ? (a = Rt(i = e), t) : i
		}, t.clipExtent = function (e) {
			return arguments.length ? (s = null == e ? Ql : e, t) : s === Ql ? null : s
		}, t.size = function (e) {
			return arguments.length ? t.clipExtent(e && [
				[0, 0],
				e
			]) : s === Ql ? null : s && s[1]
		}, t)
	};
	var Ql = [
		[-1e6, -1e6],
		[1e6, 1e6]
	];
	Ga.geom.delaunay = function (e) {
		return Ga.geom.voronoi().triangles(e)
	}, Ga.geom.quadtree = function (e, t, n, r, i) {
		function o(e) {
			function o(e, t, n, r, i, o, a, s) {
				if (!isNaN(n) && !isNaN(r))if (e.leaf) {
					var l = e.x, c = e.y;
					if (null != l)if (os(l - n) + os(c - r) < .01)u(e, t, n, r, i, o, a, s); else {
						var h = e.point;
						e.x = e.y = e.point = null, u(e, h, l, c, i, o, a, s), u(e, t, n, r, i, o, a, s)
					} else e.x = n, e.y = r, e.point = t
				} else u(e, t, n, r, i, o, a, s)
			}

			function u(e, t, n, r, i, a, s, l) {
				var u = .5 * (i + s), c = .5 * (a + l), h = n >= u, f = r >= c, d = (f << 1) + h;
				e.leaf = !1, e = e.nodes[d] || (e.nodes[d] = si()), h ? i = u : s = u, f ? a = c : l = c, o(e, t, n, r, i, a, s, l)
			}

			var c, h, f, d, p, m, g, E, v, y = Rt(s), T = Rt(l);
			if (null != t)m = t, g = n, E = r, v = i; else if (E = v = -(m = g = 1 / 0), h = [], f = [], p = e.length, a)for (d = 0; p > d; ++d)c = e[d], c.x < m && (m = c.x), c.y < g && (g = c.y), c.x > E && (E = c.x), c.y > v && (v = c.y), h.push(c.x), f.push(c.y); else for (d = 0; p > d; ++d) {
				var x = +y(c = e[d], d), R = +T(c, d);
				m > x && (m = x), g > R && (g = R), x > E && (E = x), R > v && (v = R), h.push(x), f.push(R)
			}
			var b = E - m, _ = v - g;
			b > _ ? v = g + b : E = m + _;
			var w = si();
			if (w.add = function (e) {
				o(w, e, +y(e, ++d), +T(e, d), m, g, E, v)
			}, w.visit = function (e) {
				li(e, w, m, g, E, v)
			}, d = -1, null == t) {
				for (; ++d < p;)o(w, e[d], h[d], f[d], m, g, E, v);
				--d
			} else e.forEach(w.add);
			return h = f = e = c = null, w
		}

		var a, s = _r, l = wr;
		return(a = arguments.length) ? (s = oi, l = ai, 3 === a && (i = n, r = t, n = t = 0), o(e)) : (o.x = function (e) {
			return arguments.length ? (s = e, o) : s
		}, o.y = function (e) {
			return arguments.length ? (l = e, o) : l
		}, o.extent = function (e) {
			return arguments.length ? (null == e ? t = n = r = i = null : (t = +e[0][0], n = +e[0][1], r = +e[1][0], i = +e[1][1]), o) : null == t ? null : [
				[t, n],
				[r, i]
			]
		}, o.size = function (e) {
			return arguments.length ? (null == e ? t = n = r = i = null : (t = n = 0, r = +e[0], i = +e[1]), o) : null == t ? null : [r - t, i - n]
		}, o)
	}, Ga.interpolateRgb = ui, Ga.interpolateObject = ci, Ga.interpolateNumber = hi, Ga.interpolateString = fi;
	var $l = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Jl = new RegExp($l.source, "g");
	Ga.interpolate = di, Ga.interpolators = [function (e, t) {
		var n = typeof t;
		return("string" === n ? Ws.has(t) || /^(#|rgb\(|hsl\()/.test(t) ? ui : fi : t instanceof nt ? ui : Array.isArray(t) ? pi : "object" === n && isNaN(t) ? ci : hi)(e, t)
	}], Ga.interpolateArray = pi;
	var eu = function () {
		return bt
	}, tu = Ga.map({linear: eu, poly: xi, quad: function () {
		return vi
	}, cubic: function () {
		return yi
	}, sin: function () {
		return Ri
	}, exp: function () {
		return bi
	}, circle: function () {
		return _i
	}, elastic: wi, back: Hi, bounce: function () {
		return Mi
	}}), nu = Ga.map({"in": bt, out: gi, "in-out": Ei, "out-in": function (e) {
		return Ei(gi(e))
	}});
	Ga.ease = function (e) {
		var t = e.indexOf("-"), n = t >= 0 ? e.substring(0, t) : e, r = t >= 0 ? e.substring(t + 1) : "in";
		return n = tu.get(n) || eu, r = nu.get(r) || bt, mi(r(n.apply(null, Xa.call(arguments, 1))))
	}, Ga.interpolateHcl = Si, Ga.interpolateHsl = Ci, Ga.interpolateLab = Ai, Ga.interpolateRound = Li, Ga.transform = function (e) {
		var t = Ya.createElementNS(Ga.ns.prefix.svg, "g");
		return(Ga.transform = function (e) {
			if (null != e) {
				t.setAttribute("transform", e);
				var n = t.transform.baseVal.consolidate()
			}
			return new ki(n ? n.matrix : ru)
		})(e)
	}, ki.prototype.toString = function () {
		return"translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")"
	};
	var ru = {a: 1, b: 0, c: 0, d: 1, e: 0, f: 0};
	Ga.interpolateTransform = Ni, Ga.layout = {}, Ga.layout.bundle = function () {
		return function (e) {
			for (var t = [], n = -1, r = e.length; ++n < r;)t.push(Vi(e[n]));
			return t
		}
	}, Ga.layout.chord = function () {
		function e() {
			var e, u, h, f, d, p = {}, m = [], g = Ga.range(o), E = [];
			for (n = [], r = [], e = 0, f = -1; ++f < o;) {
				for (u = 0, d = -1; ++d < o;)u += i[f][d];
				m.push(u), E.push(Ga.range(o)), e += u
			}
			for (a && g.sort(function (e, t) {
				return a(m[e], m[t])
			}), s && E.forEach(function (e, t) {
				e.sort(function (e, n) {
					return s(i[t][e], i[t][n])
				})
			}), e = (_s - c * o) / e, u = 0, f = -1; ++f < o;) {
				for (h = u, d = -1; ++d < o;) {
					var v = g[f], y = E[v][d], T = i[v][y], x = u, R = u += T * e;
					p[v + "-" + y] = {index: v, subindex: y, startAngle: x, endAngle: R, value: T}
				}
				r[v] = {index: v, startAngle: h, endAngle: u, value: (u - h) / e}, u += c
			}
			for (f = -1; ++f < o;)for (d = f - 1; ++d < o;) {
				var b = p[f + "-" + d], _ = p[d + "-" + f];
				(b.value || _.value) && n.push(b.value < _.value ? {source: _, target: b} : {source: b, target: _})
			}
			l && t()
		}

		function t() {
			n.sort(function (e, t) {
				return l((e.source.value + e.target.value) / 2, (t.source.value + t.target.value) / 2)
			})
		}

		var n, r, i, o, a, s, l, u = {}, c = 0;
		return u.matrix = function (e) {
			return arguments.length ? (o = (i = e) && i.length, n = r = null, u) : i
		}, u.padding = function (e) {
			return arguments.length ? (c = e, n = r = null, u) : c
		}, u.sortGroups = function (e) {
			return arguments.length ? (a = e, n = r = null, u) : a
		}, u.sortSubgroups = function (e) {
			return arguments.length ? (s = e, n = null, u) : s
		}, u.sortChords = function (e) {
			return arguments.length ? (l = e, n && t(), u) : l
		}, u.chords = function () {
			return n || e(), n
		}, u.groups = function () {
			return r || e(), r
		}, u
	}, Ga.layout.force = function () {
		function e(e) {
			return function (t, n, r, i) {
				if (t.point !== e) {
					var o = t.cx - e.x, a = t.cy - e.y, s = i - n, l = o * o + a * a;
					if (l > s * s / g) {
						if (p > l) {
							var u = t.charge / l;
							e.px -= o * u, e.py -= a * u
						}
						return!0
					}
					if (t.point && l && p > l) {
						var u = t.pointCharge / l;
						e.px -= o * u, e.py -= a * u
					}
				}
				return!t.charge
			}
		}

		function t(e) {
			e.px = Ga.event.x, e.py = Ga.event.y, s.resume()
		}

		var n, r, i, o, a, s = {}, l = Ga.dispatch("start", "tick", "end"), u = [1, 1], c = .9, h = iu, f = ou, d = -30, p = au, m = .1, g = .64, E = [], v = [];
		return s.tick = function () {
			if ((r *= .99) < .005)return l.end({type: "end", alpha: r = 0}), !0;
			var t, n, s, h, f, p, g, y, T, x = E.length, R = v.length;
			for (n = 0; R > n; ++n)s = v[n], h = s.source, f = s.target, y = f.x - h.x, T = f.y - h.y, (p = y * y + T * T) && (p = r * o[n] * ((p = Math.sqrt(p)) - i[n]) / p, y *= p, T *= p, f.x -= y * (g = h.weight / (f.weight + h.weight)), f.y -= T * g, h.x += y * (g = 1 - g), h.y += T * g);
			if ((g = r * m) && (y = u[0] / 2, T = u[1] / 2, n = -1, g))for (; ++n < x;)s = E[n], s.x += (y - s.x) * g, s.y += (T - s.y) * g;
			if (d)for (Xi(t = Ga.geom.quadtree(E), r, a), n = -1; ++n < x;)(s = E[n]).fixed || t.visit(e(s));
			for (n = -1; ++n < x;)s = E[n], s.fixed ? (s.x = s.px, s.y = s.py) : (s.x -= (s.px - (s.px = s.x)) * c, s.y -= (s.py - (s.py = s.y)) * c);
			l.tick({type: "tick", alpha: r})
		}, s.nodes = function (e) {
			return arguments.length ? (E = e, s) : E
		}, s.links = function (e) {
			return arguments.length ? (v = e, s) : v
		}, s.size = function (e) {
			return arguments.length ? (u = e, s) : u
		}, s.linkDistance = function (e) {
			return arguments.length ? (h = "function" == typeof e ? e : +e, s) : h
		}, s.distance = s.linkDistance, s.linkStrength = function (e) {
			return arguments.length ? (f = "function" == typeof e ? e : +e, s) : f
		}, s.friction = function (e) {
			return arguments.length ? (c = +e, s) : c
		}, s.charge = function (e) {
			return arguments.length ? (d = "function" == typeof e ? e : +e, s) : d
		}, s.chargeDistance = function (e) {
			return arguments.length ? (p = e * e, s) : Math.sqrt(p)
		}, s.gravity = function (e) {
			return arguments.length ? (m = +e, s) : m
		}, s.theta = function (e) {
			return arguments.length ? (g = e * e, s) : Math.sqrt(g)
		}, s.alpha = function (e) {
			return arguments.length ? (e = +e, r ? r = e > 0 ? e : 0 : e > 0 && (l.start({type: "start", alpha: r = e}), Ga.timer(s.tick)), s) : r
		}, s.start = function () {
			function e(e, r) {
				if (!n) {
					for (n = new Array(l), s = 0; l > s; ++s)n[s] = [];
					for (s = 0; u > s; ++s) {
						var i = v[s];
						n[i.source.index].push(i.target), n[i.target.index].push(i.source)
					}
				}
				for (var o, a = n[t], s = -1, u = a.length; ++s < u;)if (!isNaN(o = a[s][e]))return o;
				return Math.random() * r
			}

			var t, n, r, l = E.length, c = v.length, p = u[0], m = u[1];
			for (t = 0; l > t; ++t)(r = E[t]).index = t, r.weight = 0;
			for (t = 0; c > t; ++t)r = v[t], "number" == typeof r.source && (r.source = E[r.source]), "number" == typeof r.target && (r.target = E[r.target]), ++r.source.weight, ++r.target.weight;
			for (t = 0; l > t; ++t)r = E[t], isNaN(r.x) && (r.x = e("x", p)), isNaN(r.y) && (r.y = e("y", m)), isNaN(r.px) && (r.px = r.x), isNaN(r.py) && (r.py = r.y);
			if (i = [], "function" == typeof h)for (t = 0; c > t; ++t)i[t] = +h.call(this, v[t], t); else for (t = 0; c > t; ++t)i[t] = h;
			if (o = [], "function" == typeof f)for (t = 0; c > t; ++t)o[t] = +f.call(this, v[t], t); else for (t = 0; c > t; ++t)o[t] = f;
			if (a = [], "function" == typeof d)for (t = 0; l > t; ++t)a[t] = +d.call(this, E[t], t); else for (t = 0; l > t; ++t)a[t] = d;
			return s.resume()
		}, s.resume = function () {
			return s.alpha(.1)
		}, s.stop = function () {
			return s.alpha(0)
		}, s.drag = function () {
			return n || (n = Ga.behavior.drag().origin(bt).on("dragstart.force", Ii).on("drag.force", t).on("dragend.force", ji)), arguments.length ? void this.on("mouseover.force", Wi).on("mouseout.force", Gi).call(n) : n
		}, Ga.rebind(s, l, "on")
	};
	var iu = 20, ou = 1, au = 1 / 0;
	Ga.layout.hierarchy = function () {
		function e(i) {
			var o, a = [i], s = [];
			for (i.depth = 0; null != (o = a.pop());)if (s.push(o), (u = n.call(e, o, o.depth)) && (l = u.length)) {
				for (var l, u, c; --l >= 0;)a.push(c = u[l]), c.parent = o, c.depth = o.depth + 1;
				r && (o.value = 0), o.children = u
			} else r && (o.value = +r.call(e, o, o.depth) || 0), delete o.children;
			return Ki(i, function (e) {
				var n, i;
				t && (n = e.children) && n.sort(t), r && (i = e.parent) && (i.value += e.value)
			}), s
		}

		var t = $i, n = Zi, r = Qi;
		return e.sort = function (n) {
			return arguments.length ? (t = n, e) : t
		}, e.children = function (t) {
			return arguments.length ? (n = t, e) : n
		}, e.value = function (t) {
			return arguments.length ? (r = t, e) : r
		}, e.revalue = function (t) {
			return r && (Yi(t, function (e) {
				e.children && (e.value = 0)
			}), Ki(t, function (t) {
				var n;
				t.children || (t.value = +r.call(e, t, t.depth) || 0), (n = t.parent) && (n.value += t.value)
			})), t
		}, e
	}, Ga.layout.partition = function () {
		function e(t, n, r, i) {
			var o = t.children;
			if (t.x = n, t.y = t.depth * i, t.dx = r, t.dy = i, o && (a = o.length)) {
				var a, s, l, u = -1;
				for (r = t.value ? r / t.value : 0; ++u < a;)e(s = o[u], n, l = s.value * r, i), n += l
			}
		}

		function t(e) {
			var n = e.children, r = 0;
			if (n && (i = n.length))for (var i, o = -1; ++o < i;)r = Math.max(r, t(n[o]));
			return 1 + r
		}

		function n(n, o) {
			var a = r.call(this, n, o);
			return e(a[0], 0, i[0], i[1] / t(a[0])), a
		}

		var r = Ga.layout.hierarchy(), i = [1, 1];
		return n.size = function (e) {
			return arguments.length ? (i = e, n) : i
		}, qi(n, r)
	}, Ga.layout.pie = function () {
		function e(o) {
			var a = o.map(function (n, r) {
				return+t.call(e, n, r)
			}), s = +("function" == typeof r ? r.apply(this, arguments) : r), l = (("function" == typeof i ? i.apply(this, arguments) : i) - s) / Ga.sum(a), u = Ga.range(o.length);
			null != n && u.sort(n === su ? function (e, t) {
				return a[t] - a[e]
			} : function (e, t) {
				return n(o[e], o[t])
			});
			var c = [];
			return u.forEach(function (e) {
				var t;
				c[e] = {data: o[e], value: t = a[e], startAngle: s, endAngle: s += t * l}
			}), c
		}

		var t = Number, n = su, r = 0, i = _s;
		return e.value = function (n) {
			return arguments.length ? (t = n, e) : t
		}, e.sort = function (t) {
			return arguments.length ? (n = t, e) : n
		}, e.startAngle = function (t) {
			return arguments.length ? (r = t, e) : r
		}, e.endAngle = function (t) {
			return arguments.length ? (i = t, e) : i
		}, e
	};
	var su = {};
	Ga.layout.stack = function () {
		function e(s, l) {
			var u = s.map(function (n, r) {
				return t.call(e, n, r)
			}), c = u.map(function (t) {
				return t.map(function (t, n) {
					return[o.call(e, t, n), a.call(e, t, n)]
				})
			}), h = n.call(e, c, l);
			u = Ga.permute(u, h), c = Ga.permute(c, h);
			var f, d, p, m = r.call(e, c, l), g = u.length, E = u[0].length;
			for (d = 0; E > d; ++d)for (i.call(e, u[0][d], p = m[d], c[0][d][1]), f = 1; g > f; ++f)i.call(e, u[f][d], p += c[f - 1][d][1], c[f][d][1]);
			return s
		}

		var t = bt, n = ro, r = io, i = no, o = eo, a = to;
		return e.values = function (n) {
			return arguments.length ? (t = n, e) : t
		}, e.order = function (t) {
			return arguments.length ? (n = "function" == typeof t ? t : lu.get(t) || ro, e) : n
		}, e.offset = function (t) {
			return arguments.length ? (r = "function" == typeof t ? t : uu.get(t) || io, e) : r
		}, e.x = function (t) {
			return arguments.length ? (o = t, e) : o
		}, e.y = function (t) {
			return arguments.length ? (a = t, e) : a
		}, e.out = function (t) {
			return arguments.length ? (i = t, e) : i
		}, e
	};
	var lu = Ga.map({"inside-out": function (e) {
		var t, n, r = e.length, i = e.map(oo), o = e.map(ao), a = Ga.range(r).sort(function (e, t) {
			return i[e] - i[t]
		}), s = 0, l = 0, u = [], c = [];
		for (t = 0; r > t; ++t)n = a[t], l > s ? (s += o[n], u.push(n)) : (l += o[n], c.push(n));
		return c.reverse().concat(u)
	}, reverse: function (e) {
		return Ga.range(e.length).reverse()
	}, "default": ro}), uu = Ga.map({silhouette: function (e) {
		var t, n, r, i = e.length, o = e[0].length, a = [], s = 0, l = [];
		for (n = 0; o > n; ++n) {
			for (t = 0, r = 0; i > t; t++)r += e[t][n][1];
			r > s && (s = r), a.push(r)
		}
		for (n = 0; o > n; ++n)l[n] = (s - a[n]) / 2;
		return l
	}, wiggle: function (e) {
		var t, n, r, i, o, a, s, l, u, c = e.length, h = e[0], f = h.length, d = [];
		for (d[0] = l = u = 0, n = 1; f > n; ++n) {
			for (t = 0, i = 0; c > t; ++t)i += e[t][n][1];
			for (t = 0, o = 0, s = h[n][0] - h[n - 1][0]; c > t; ++t) {
				for (r = 0, a = (e[t][n][1] - e[t][n - 1][1]) / (2 * s); t > r; ++r)a += (e[r][n][1] - e[r][n - 1][1]) / s;
				o += a * e[t][n][1]
			}
			d[n] = l -= i ? o / i * s : 0, u > l && (u = l)
		}
		for (n = 0; f > n; ++n)d[n] -= u;
		return d
	}, expand: function (e) {
		var t, n, r, i = e.length, o = e[0].length, a = 1 / i, s = [];
		for (n = 0; o > n; ++n) {
			for (t = 0, r = 0; i > t; t++)r += e[t][n][1];
			if (r)for (t = 0; i > t; t++)e[t][n][1] /= r; else for (t = 0; i > t; t++)e[t][n][1] = a
		}
		for (n = 0; o > n; ++n)s[n] = 0;
		return s
	}, zero: io});
	Ga.layout.histogram = function () {
		function e(e, o) {
			for (var a, s, l = [], u = e.map(n, this), c = r.call(this, u, o), h = i.call(this, c, u, o), o = -1, f = u.length, d = h.length - 1, p = t ? 1 : 1 / f; ++o < d;)a = l[o] = [], a.dx = h[o + 1] - (a.x = h[o]), a.y = 0;
			if (d > 0)for (o = -1; ++o < f;)s = u[o], s >= c[0] && s <= c[1] && (a = l[Ga.bisect(h, s, 1, d) - 1], a.y += p, a.push(e[o]));
			return l
		}

		var t = !0, n = Number, r = co, i = lo;
		return e.value = function (t) {
			return arguments.length ? (n = t, e) : n
		}, e.range = function (t) {
			return arguments.length ? (r = Rt(t), e) : r
		}, e.bins = function (t) {
			return arguments.length ? (i = "number" == typeof t ? function (e) {
				return uo(e, t)
			} : Rt(t), e) : i
		}, e.frequency = function (n) {
			return arguments.length ? (t = !!n, e) : t
		}, e
	}, Ga.layout.pack = function () {
		function e(e, o) {
			var a = n.call(this, e, o), s = a[0], l = i[0], u = i[1], c = null == t ? Math.sqrt : "function" == typeof t ? t : function () {
				return t
			};
			if (s.x = s.y = 0, Ki(s, function (e) {
				e.r = +c(e.value)
			}), Ki(s, go), r) {
				var h = r * (t ? 1 : Math.max(2 * s.r / l, 2 * s.r / u)) / 2;
				Ki(s, function (e) {
					e.r += h
				}), Ki(s, go), Ki(s, function (e) {
					e.r -= h
				})
			}
			return yo(s, l / 2, u / 2, t ? 1 : 1 / Math.max(2 * s.r / l, 2 * s.r / u)), a
		}

		var t, n = Ga.layout.hierarchy().sort(ho), r = 0, i = [1, 1];
		return e.size = function (t) {
			return arguments.length ? (i = t, e) : i
		}, e.radius = function (n) {
			return arguments.length ? (t = null == n || "function" == typeof n ? n : +n, e) : t
		}, e.padding = function (t) {
			return arguments.length ? (r = +t, e) : r
		}, qi(e, n)
	}, Ga.layout.tree = function () {
		function e(e, i) {
			var c = a.call(this, e, i), h = c[0], f = t(h);
			if (Ki(f, n), f.parent.m = -f.z, Yi(f, r), u)Yi(h, o); else {
				var d = h, p = h, m = h;
				Yi(h, function (e) {
					e.x < d.x && (d = e), e.x > p.x && (p = e), e.depth > m.depth && (m = e)
				});
				var g = s(d, p) / 2 - d.x, E = l[0] / (p.x + s(p, d) / 2 + g), v = l[1] / (m.depth || 1);
				Yi(h, function (e) {
					e.x = (e.x + g) * E, e.y = e.depth * v
				})
			}
			return c
		}

		function t(e) {
			for (var t, n = {A: null, children: [e]}, r = [n]; null != (t = r.pop());)for (var i, o = t.children, a = 0, s = o.length; s > a; ++a)r.push((o[a] = i = {_: o[a], parent: t, children: (i = o[a].children) && i.slice() || [], A: null, a: null, z: 0, m: 0, c: 0, s: 0, t: null, i: a}).a = i);
			return n.children[0]
		}

		function n(e) {
			var t = e.children, n = e.parent.children, r = e.i ? n[e.i - 1] : null;
			if (t.length) {
				wo(e);
				var o = (t[0].z + t[t.length - 1].z) / 2;
				r ? (e.z = r.z + s(e._, r._), e.m = e.z - o) : e.z = o
			} else r && (e.z = r.z + s(e._, r._));
			e.parent.A = i(e, r, e.parent.A || n[0])
		}

		function r(e) {
			e._.x = e.z + e.parent.m, e.m += e.parent.m
		}

		function i(e, t, n) {
			if (t) {
				for (var r, i = e, o = e, a = t, l = i.parent.children[0], u = i.m, c = o.m, h = a.m, f = l.m; a = bo(a), i = Ro(i), a && i;)l = Ro(l), o = bo(o), o.a = e, r = a.z + h - i.z - u + s(a._, i._), r > 0 && (_o(Ho(a, e, n), e, r), u += r, c += r), h += a.m, u += i.m, f += l.m, c += o.m;
				a && !bo(o) && (o.t = a, o.m += h - c), i && !Ro(l) && (l.t = i, l.m += u - f, n = e)
			}
			return n
		}

		function o(e) {
			e.x *= l[0], e.y = e.depth * l[1]
		}

		var a = Ga.layout.hierarchy().sort(null).value(null), s = xo, l = [1, 1], u = null;
		return e.separation = function (t) {
			return arguments.length ? (s = t, e) : s
		}, e.size = function (t) {
			return arguments.length ? (u = null == (l = t) ? o : null, e) : u ? null : l
		}, e.nodeSize = function (t) {
			return arguments.length ? (u = null == (l = t) ? null : o, e) : u ? l : null
		}, qi(e, a)
	}, Ga.layout.cluster = function () {
		function e(e, o) {
			var a, s = t.call(this, e, o), l = s[0], u = 0;
			Ki(l, function (e) {
				var t = e.children;
				t && t.length ? (e.x = So(t), e.y = Mo(t)) : (e.x = a ? u += n(e, a) : 0, e.y = 0, a = e)
			});
			var c = Co(l), h = Ao(l), f = c.x - n(c, h) / 2, d = h.x + n(h, c) / 2;
			return Ki(l, i ? function (e) {
				e.x = (e.x - l.x) * r[0], e.y = (l.y - e.y) * r[1]
			} : function (e) {
				e.x = (e.x - f) / (d - f) * r[0], e.y = (1 - (l.y ? e.y / l.y : 1)) * r[1]
			}), s
		}

		var t = Ga.layout.hierarchy().sort(null).value(null), n = xo, r = [1, 1], i = !1;
		return e.separation = function (t) {
			return arguments.length ? (n = t, e) : n
		}, e.size = function (t) {
			return arguments.length ? (i = null == (r = t), e) : i ? null : r
		}, e.nodeSize = function (t) {
			return arguments.length ? (i = null != (r = t), e) : i ? r : null
		}, qi(e, t)
	}, Ga.layout.treemap = function () {
		function e(e, t) {
			for (var n, r, i = -1, o = e.length; ++i < o;)r = (n = e[i]).value * (0 > t ? 0 : t), n.area = isNaN(r) || 0 >= r ? 0 : r
		}

		function t(n) {
			var o = n.children;
			if (o && o.length) {
				var a, s, l, u = h(n), c = [], f = o.slice(), p = 1 / 0, m = "slice" === d ? u.dx : "dice" === d ? u.dy : "slice-dice" === d ? 1 & n.depth ? u.dy : u.dx : Math.min(u.dx, u.dy);
				for (e(f, u.dx * u.dy / n.value), c.area = 0; (l = f.length) > 0;)c.push(a = f[l - 1]), c.area += a.area, "squarify" !== d || (s = r(c, m)) <= p ? (f.pop(), p = s) : (c.area -= c.pop().area, i(c, m, u, !1), m = Math.min(u.dx, u.dy), c.length = c.area = 0, p = 1 / 0);
				c.length && (i(c, m, u, !0), c.length = c.area = 0), o.forEach(t)
			}
		}

		function n(t) {
			var r = t.children;
			if (r && r.length) {
				var o, a = h(t), s = r.slice(), l = [];
				for (e(s, a.dx * a.dy / t.value), l.area = 0; o = s.pop();)l.push(o), l.area += o.area, null != o.z && (i(l, o.z ? a.dx : a.dy, a, !s.length), l.length = l.area = 0);
				r.forEach(n)
			}
		}

		function r(e, t) {
			for (var n, r = e.area, i = 0, o = 1 / 0, a = -1, s = e.length; ++a < s;)(n = e[a].area) && (o > n && (o = n), n > i && (i = n));
			return r *= r, t *= t, r ? Math.max(t * i * p / r, r / (t * o * p)) : 1 / 0
		}

		function i(e, t, n, r) {
			var i, o = -1, a = e.length, s = n.x, u = n.y, c = t ? l(e.area / t) : 0;
			if (t == n.dx) {
				for ((r || c > n.dy) && (c = n.dy); ++o < a;)i = e[o], i.x = s, i.y = u, i.dy = c, s += i.dx = Math.min(n.x + n.dx - s, c ? l(i.area / c) : 0);
				i.z = !0, i.dx += n.x + n.dx - s, n.y += c, n.dy -= c
			} else {
				for ((r || c > n.dx) && (c = n.dx); ++o < a;)i = e[o], i.x = s, i.y = u, i.dx = c, u += i.dy = Math.min(n.y + n.dy - u, c ? l(i.area / c) : 0);
				i.z = !1, i.dy += n.y + n.dy - u, n.x += c, n.dx -= c
			}
		}

		function o(r) {
			var i = a || s(r), o = i[0];
			return o.x = 0, o.y = 0, o.dx = u[0], o.dy = u[1], a && s.revalue(o), e([o], o.dx * o.dy / o.value), (a ? n : t)(o), f && (a = i), i
		}

		var a, s = Ga.layout.hierarchy(), l = Math.round, u = [1, 1], c = null, h = Lo, f = !1, d = "squarify", p = .5 * (1 + Math.sqrt(5));
		return o.size = function (e) {
			return arguments.length ? (u = e, o) : u
		}, o.padding = function (e) {
			function t(t) {
				var n = e.call(o, t, t.depth);
				return null == n ? Lo(t) : ko(t, "number" == typeof n ? [n, n, n, n] : n)
			}

			function n(t) {
				return ko(t, e)
			}

			if (!arguments.length)return c;
			var r;
			return h = null == (c = e) ? Lo : "function" == (r = typeof e) ? t : "number" === r ? (e = [e, e, e, e], n) : n, o
		}, o.round = function (e) {
			return arguments.length ? (l = e ? Math.round : Number, o) : l != Number
		}, o.sticky = function (e) {
			return arguments.length ? (f = e, a = null, o) : f
		}, o.ratio = function (e) {
			return arguments.length ? (p = e, o) : p
		}, o.mode = function (e) {
			return arguments.length ? (d = e + "", o) : d
		}, qi(o, s)
	}, Ga.random = {normal: function (e, t) {
		var n = arguments.length;
		return 2 > n && (t = 1), 1 > n && (e = 0), function () {
			var n, r, i;
			do n = 2 * Math.random() - 1, r = 2 * Math.random() - 1, i = n * n + r * r; while (!i || i > 1);
			return e + t * n * Math.sqrt(-2 * Math.log(i) / i)
		}
	}, logNormal: function () {
		var e = Ga.random.normal.apply(Ga, arguments);
		return function () {
			return Math.exp(e())
		}
	}, bates: function (e) {
		var t = Ga.random.irwinHall(e);
		return function () {
			return t() / e
		}
	}, irwinHall: function (e) {
		return function () {
			for (var t = 0, n = 0; e > n; n++)t += Math.random();
			return t
		}
	}}, Ga.scale = {};
	var cu = {floor: bt, ceil: bt};
	Ga.scale.linear = function () {
		return Vo([0, 1], [0, 1], di, !1)
	};
	var hu = {s: 1, g: 1, p: 1, r: 1, e: 1};
	Ga.scale.log = function () {
		return qo(Ga.scale.linear().domain([0, 1]), 10, !0, [1, 10])
	};
	var fu = Ga.format(".0e"), du = {floor: function (e) {
		return-Math.ceil(-e)
	}, ceil: function (e) {
		return-Math.floor(-e)
	}};
	Ga.scale.pow = function () {
		return Yo(Ga.scale.linear(), 1, [0, 1])
	}, Ga.scale.sqrt = function () {
		return Ga.scale.pow().exponent(.5)
	}, Ga.scale.ordinal = function () {
		return Zo([], {t: "range", a: [
			[]
		]})
	}, Ga.scale.category10 = function () {
		return Ga.scale.ordinal().range(pu)
	}, Ga.scale.category20 = function () {
		return Ga.scale.ordinal().range(mu)
	}, Ga.scale.category20b = function () {
		return Ga.scale.ordinal().range(gu)
	}, Ga.scale.category20c = function () {
		return Ga.scale.ordinal().range(Eu)
	};
	var pu = [2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175].map(mt), mu = [2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725].map(mt), gu = [3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654].map(mt), Eu = [3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081].map(mt);
	Ga.scale.quantile = function () {
		return Qo([], [])
	}, Ga.scale.quantize = function () {
		return $o(0, 1, [0, 1])
	}, Ga.scale.threshold = function () {
		return Jo([.5], [0, 1])
	}, Ga.scale.identity = function () {
		return ea([0, 1])
	}, Ga.svg = {}, Ga.svg.arc = function () {
		function e() {
			var e = t.apply(this, arguments), o = n.apply(this, arguments), a = r.apply(this, arguments) + vu, s = i.apply(this, arguments) + vu, l = (a > s && (l = a, a = s, s = l), s - a), u = bs > l ? "0" : "1", c = Math.cos(a), h = Math.sin(a), f = Math.cos(s), d = Math.sin(s);
			return l >= yu ? e ? "M0," + o + "A" + o + "," + o + " 0 1,1 0," + -o + "A" + o + "," + o + " 0 1,1 0," + o + "M0," + e + "A" + e + "," + e + " 0 1,0 0," + -e + "A" + e + "," + e + " 0 1,0 0," + e + "Z" : "M0," + o + "A" + o + "," + o + " 0 1,1 0," + -o + "A" + o + "," + o + " 0 1,1 0," + o + "Z" : e ? "M" + o * c + "," + o * h + "A" + o + "," + o + " 0 " + u + ",1 " + o * f + "," + o * d + "L" + e * f + "," + e * d + "A" + e + "," + e + " 0 " + u + ",0 " + e * c + "," + e * h + "Z" : "M" + o * c + "," + o * h + "A" + o + "," + o + " 0 " + u + ",1 " + o * f + "," + o * d + "L0,0Z"
		}

		var t = ta, n = na, r = ra, i = ia;
		return e.innerRadius = function (n) {
			return arguments.length ? (t = Rt(n), e) : t
		}, e.outerRadius = function (t) {
			return arguments.length ? (n = Rt(t), e) : n
		}, e.startAngle = function (t) {
			return arguments.length ? (r = Rt(t), e) : r
		}, e.endAngle = function (t) {
			return arguments.length ? (i = Rt(t), e) : i
		}, e.centroid = function () {
			var e = (t.apply(this, arguments) + n.apply(this, arguments)) / 2, o = (r.apply(this, arguments) + i.apply(this, arguments)) / 2 + vu;
			return[Math.cos(o) * e, Math.sin(o) * e]
		}, e
	};
	var vu = -ws, yu = _s - Hs;
	Ga.svg.line = function () {
		return oa(bt)
	};
	var Tu = Ga.map({linear: aa, "linear-closed": sa, step: la, "step-before": ua, "step-after": ca, basis: ga, "basis-open": Ea, "basis-closed": va, bundle: ya, cardinal: da, "cardinal-open": ha, "cardinal-closed": fa, monotone: wa});
	Tu.forEach(function (e, t) {
		t.key = e, t.closed = /-closed$/.test(e)
	});
	var xu = [0, 2 / 3, 1 / 3, 0], Ru = [0, 1 / 3, 2 / 3, 0], bu = [0, 1 / 6, 2 / 3, 1 / 6];
	Ga.svg.line.radial = function () {
		var e = oa(Ha);
		return e.radius = e.x, delete e.x, e.angle = e.y, delete e.y, e
	}, ua.reverse = ca, ca.reverse = ua, Ga.svg.area = function () {
		return Ma(bt)
	}, Ga.svg.area.radial = function () {
		var e = Ma(Ha);
		return e.radius = e.x, delete e.x, e.innerRadius = e.x0, delete e.x0, e.outerRadius = e.x1, delete e.x1, e.angle = e.y, delete e.y, e.startAngle = e.y0, delete e.y0, e.endAngle = e.y1, delete e.y1, e
	}, Ga.svg.chord = function () {
		function e(e, s) {
			var l = t(this, o, e, s), u = t(this, a, e, s);
			return"M" + l.p0 + r(l.r, l.p1, l.a1 - l.a0) + (n(l, u) ? i(l.r, l.p1, l.r, l.p0) : i(l.r, l.p1, u.r, u.p0) + r(u.r, u.p1, u.a1 - u.a0) + i(u.r, u.p1, l.r, l.p0)) + "Z"
		}

		function t(e, t, n, r) {
			var i = t.call(e, n, r), o = s.call(e, i, r), a = l.call(e, i, r) + vu, c = u.call(e, i, r) + vu;
			return{r: o, a0: a, a1: c, p0: [o * Math.cos(a), o * Math.sin(a)], p1: [o * Math.cos(c), o * Math.sin(c)]}
		}

		function n(e, t) {
			return e.a0 == t.a0 && e.a1 == t.a1
		}

		function r(e, t, n) {
			return"A" + e + "," + e + " 0 " + +(n > bs) + ",1 " + t
		}

		function i(e, t, n, r) {
			return"Q 0,0 " + r
		}

		var o = pr, a = mr, s = Sa, l = ra, u = ia;
		return e.radius = function (t) {
			return arguments.length ? (s = Rt(t), e) : s
		}, e.source = function (t) {
			return arguments.length ? (o = Rt(t), e) : o
		}, e.target = function (t) {
			return arguments.length ? (a = Rt(t), e) : a
		}, e.startAngle = function (t) {
			return arguments.length ? (l = Rt(t), e) : l
		}, e.endAngle = function (t) {
			return arguments.length ? (u = Rt(t), e) : u
		}, e
	}, Ga.svg.diagonal = function () {
		function e(e, i) {
			var o = t.call(this, e, i), a = n.call(this, e, i), s = (o.y + a.y) / 2, l = [o, {x: o.x, y: s}, {x: a.x, y: s}, a];
			return l = l.map(r), "M" + l[0] + "C" + l[1] + " " + l[2] + " " + l[3]
		}

		var t = pr, n = mr, r = Ca;
		return e.source = function (n) {
			return arguments.length ? (t = Rt(n), e) : t
		}, e.target = function (t) {
			return arguments.length ? (n = Rt(t), e) : n
		}, e.projection = function (t) {
			return arguments.length ? (r = t, e) : r
		}, e
	}, Ga.svg.diagonal.radial = function () {
		var e = Ga.svg.diagonal(), t = Ca, n = e.projection;
		return e.projection = function (e) {
			return arguments.length ? n(Aa(t = e)) : t
		}, e
	}, Ga.svg.symbol = function () {
		function e(e, r) {
			return(_u.get(t.call(this, e, r)) || Pa)(n.call(this, e, r))
		}

		var t = ka, n = La;
		return e.type = function (n) {
			return arguments.length ? (t = Rt(n), e) : t
		}, e.size = function (t) {
			return arguments.length ? (n = Rt(t), e) : n
		}, e
	};
	var _u = Ga.map({circle: Pa, cross: function (e) {
		var t = Math.sqrt(e / 5) / 2;
		return"M" + -3 * t + "," + -t + "H" + -t + "V" + -3 * t + "H" + t + "V" + -t + "H" + 3 * t + "V" + t + "H" + t + "V" + 3 * t + "H" + -t + "V" + t + "H" + -3 * t + "Z"
	}, diamond: function (e) {
		var t = Math.sqrt(e / (2 * Su)), n = t * Su;
		return"M0," + -t + "L" + n + ",0 0," + t + " " + -n + ",0Z"
	}, square: function (e) {
		var t = Math.sqrt(e) / 2;
		return"M" + -t + "," + -t + "L" + t + "," + -t + " " + t + "," + t + " " + -t + "," + t + "Z"
	}, "triangle-down": function (e) {
		var t = Math.sqrt(e / Mu), n = t * Mu / 2;
		return"M0," + n + "L" + t + "," + -n + " " + -t + "," + -n + "Z"
	}, "triangle-up": function (e) {
		var t = Math.sqrt(e / Mu), n = t * Mu / 2;
		return"M0," + -n + "L" + t + "," + n + " " + -t + "," + n + "Z"
	}});
	Ga.svg.symbolTypes = _u.keys();
	var wu, Hu, Mu = Math.sqrt(3), Su = Math.tan(30 * Ss), Cu = [], Au = 0;
	Cu.call = ms.call, Cu.empty = ms.empty, Cu.node = ms.node, Cu.size = ms.size, Ga.transition = function (e) {
		return arguments.length ? wu ? e.transition() : e : vs.transition()
	}, Ga.transition.prototype = Cu, Cu.select = function (e) {
		var t, n, r, i = this.id, o = [];
		e = R(e);
		for (var a = -1, s = this.length; ++a < s;) {
			o.push(t = []);
			for (var l = this[a], u = -1, c = l.length; ++u < c;)(r = l[u]) && (n = e.call(r, r.__data__, u, a)) ? ("__data__"in r && (n.__data__ = r.__data__), za(n, u, i, r.__transition__[i]), t.push(n)) : t.push(null)
		}
		return Da(o, i)
	}, Cu.selectAll = function (e) {
		var t, n, r, i, o, a = this.id, s = [];
		e = b(e);
		for (var l = -1, u = this.length; ++l < u;)for (var c = this[l], h = -1, f = c.length; ++h < f;)if (r = c[h]) {
			o = r.__transition__[a], n = e.call(r, r.__data__, h, l), s.push(t = []);
			for (var d = -1, p = n.length; ++d < p;)(i = n[d]) && za(i, d, a, o), t.push(i)
		}
		return Da(s, a)
	}, Cu.filter = function (e) {
		var t, n, r, i = [];
		"function" != typeof e && (e = D(e));
		for (var o = 0, a = this.length; a > o; o++) {
			i.push(t = []);
			for (var n = this[o], s = 0, l = n.length; l > s; s++)(r = n[s]) && e.call(r, r.__data__, s, o) && t.push(r)
		}
		return Da(i, this.id)
	}, Cu.tween = function (e, t) {
		var n = this.id;
		return arguments.length < 2 ? this.node().__transition__[n].tween.get(e) : N(this, null == t ? function (t) {
			t.__transition__[n].tween.remove(e)
		} : function (r) {
			r.__transition__[n].tween.set(e, t)
		})
	}, Cu.attr = function (e, t) {
		function n() {
			this.removeAttribute(s)
		}

		function r() {
			this.removeAttributeNS(s.space, s.local)
		}

		function i(e) {
			return null == e ? n : (e += "", function () {
				var t, n = this.getAttribute(s);
				return n !== e && (t = a(n, e), function (e) {
					this.setAttribute(s, t(e))
				})
			})
		}

		function o(e) {
			return null == e ? r : (e += "", function () {
				var t, n = this.getAttributeNS(s.space, s.local);
				return n !== e && (t = a(n, e), function (e) {
					this.setAttributeNS(s.space, s.local, t(e))
				})
			})
		}

		if (arguments.length < 2) {
			for (t in e)this.attr(t, e[t]);
			return this
		}
		var a = "transform" == e ? Ni : di, s = Ga.ns.qualify(e);
		return Fa(this, "attr." + e, t, s.local ? o : i)
	}, Cu.attrTween = function (e, t) {
		function n(e, n) {
			var r = t.call(this, e, n, this.getAttribute(i));
			return r && function (e) {
				this.setAttribute(i, r(e))
			}
		}

		function r(e, n) {
			var r = t.call(this, e, n, this.getAttributeNS(i.space, i.local));
			return r && function (e) {
				this.setAttributeNS(i.space, i.local, r(e))
			}
		}

		var i = Ga.ns.qualify(e);
		return this.tween("attr." + e, i.local ? r : n)
	}, Cu.style = function (e, t, n) {
		function r() {
			this.style.removeProperty(e)
		}

		function i(t) {
			return null == t ? r : (t += "", function () {
				var r, i = Za.getComputedStyle(this, null).getPropertyValue(e);
				return i !== t && (r = di(i, t), function (t) {
					this.style.setProperty(e, r(t), n)
				})
			})
		}

		var o = arguments.length;
		if (3 > o) {
			if ("string" != typeof e) {
				2 > o && (t = "");
				for (n in e)this.style(n, e[n], t);
				return this
			}
			n = ""
		}
		return Fa(this, "style." + e, t, i)
	}, Cu.styleTween = function (e, t, n) {
		function r(r, i) {
			var o = t.call(this, r, i, Za.getComputedStyle(this, null).getPropertyValue(e));
			return o && function (t) {
				this.style.setProperty(e, o(t), n)
			}
		}

		return arguments.length < 3 && (n = ""), this.tween("style." + e, r)
	}, Cu.text = function (e) {
		return Fa(this, "text", e, Na)
	}, Cu.remove = function () {
		return this.each("end.transition", function () {
			var e;
			this.__transition__.count < 2 && (e = this.parentNode) && e.removeChild(this)
		})
	}, Cu.ease = function (e) {
		var t = this.id;
		return arguments.length < 1 ? this.node().__transition__[t].ease : ("function" != typeof e && (e = Ga.ease.apply(Ga, arguments)), N(this, function (n) {
			n.__transition__[t].ease = e
		}))
	}, Cu.delay = function (e) {
		var t = this.id;
		return arguments.length < 1 ? this.node().__transition__[t].delay : N(this, "function" == typeof e ? function (n, r, i) {
			n.__transition__[t].delay = +e.call(n, n.__data__, r, i)
		} : (e = +e, function (n) {
			n.__transition__[t].delay = e
		}))
	}, Cu.duration = function (e) {
		var t = this.id;
		return arguments.length < 1 ? this.node().__transition__[t].duration : N(this, "function" == typeof e ? function (n, r, i) {
			n.__transition__[t].duration = Math.max(1, e.call(n, n.__data__, r, i))
		} : (e = Math.max(1, e), function (n) {
			n.__transition__[t].duration = e
		}))
	}, Cu.each = function (e, t) {
		var n = this.id;
		if (arguments.length < 2) {
			var r = Hu, i = wu;
			wu = n, N(this, function (t, r, i) {
				Hu = t.__transition__[n], e.call(t, t.__data__, r, i)
			}), Hu = r, wu = i
		} else N(this, function (r) {
			var i = r.__transition__[n];
			(i.event || (i.event = Ga.dispatch("start", "end"))).on(e, t)
		});
		return this
	}, Cu.transition = function () {
		for (var e, t, n, r, i = this.id, o = ++Au, a = [], s = 0, l = this.length; l > s; s++) {
			a.push(e = []);
			for (var t = this[s], u = 0, c = t.length; c > u; u++)(n = t[u]) && (r = Object.create(n.__transition__[i]), r.delay += r.duration, za(n, u, o, r)), e.push(n)
		}
		return Da(a, o)
	}, Ga.svg.axis = function () {
		function e(e) {
			e.each(function () {
				var e, u = Ga.select(this), c = this.__chart__ || n, h = this.__chart__ = n.copy(), f = null == l ? h.ticks ? h.ticks.apply(h, s) : h.domain() : l, d = null == t ? h.tickFormat ? h.tickFormat.apply(h, s) : bt : t, p = u.selectAll(".tick").data(f, h), m = p.enter().insert("g", ".domain").attr("class", "tick").style("opacity", Hs), g = Ga.transition(p.exit()).style("opacity", Hs).remove(), E = Ga.transition(p.order()).style("opacity", 1), v = Do(h), y = u.selectAll(".domain").data([0]), T = (y.enter().append("path").attr("class", "domain"), Ga.transition(y));
				m.append("line"), m.append("text");
				var x = m.select("line"), R = E.select("line"), b = p.select("text").text(d), _ = m.select("text"), w = E.select("text");
				switch (r) {
					case"bottom":
						e = Ua, x.attr("y2", i), _.attr("y", Math.max(i, 0) + a), R.attr("x2", 0).attr("y2", i), w.attr("x", 0).attr("y", Math.max(i, 0) + a), b.attr("dy", ".71em").style("text-anchor", "middle"), T.attr("d", "M" + v[0] + "," + o + "V0H" + v[1] + "V" + o);
						break;
					case"top":
						e = Ua, x.attr("y2", -i), _.attr("y", -(Math.max(i, 0) + a)), R.attr("x2", 0).attr("y2", -i), w.attr("x", 0).attr("y", -(Math.max(i, 0) + a)), b.attr("dy", "0em").style("text-anchor", "middle"), T.attr("d", "M" + v[0] + "," + -o + "V0H" + v[1] + "V" + -o);
						break;
					case"left":
						e = Va, x.attr("x2", -i), _.attr("x", -(Math.max(i, 0) + a)), R.attr("x2", -i).attr("y2", 0), w.attr("x", -(Math.max(i, 0) + a)).attr("y", 0), b.attr("dy", ".32em").style("text-anchor", "end"), T.attr("d", "M" + -o + "," + v[0] + "H0V" + v[1] + "H" + -o);
						break;
					case"right":
						e = Va, x.attr("x2", i), _.attr("x", Math.max(i, 0) + a), R.attr("x2", i).attr("y2", 0), w.attr("x", Math.max(i, 0) + a).attr("y", 0), b.attr("dy", ".32em").style("text-anchor", "start"), T.attr("d", "M" + o + "," + v[0] + "H0V" + v[1] + "H" + o)
				}
				if (h.rangeBand) {
					var H = h, M = H.rangeBand() / 2;
					c = h = function (e) {
						return H(e) + M
					}
				} else c.rangeBand ? c = h : g.call(e, h);
				m.call(e, c), E.call(e, h)
			})
		}

		var t, n = Ga.scale.linear(), r = Lu, i = 6, o = 6, a = 3, s = [10], l = null;
		return e.scale = function (t) {
			return arguments.length ? (n = t, e) : n
		}, e.orient = function (t) {
			return arguments.length ? (r = t in ku ? t + "" : Lu, e) : r
		}, e.ticks = function () {
			return arguments.length ? (s = arguments, e) : s
		}, e.tickValues = function (t) {
			return arguments.length ? (l = t, e) : l
		}, e.tickFormat = function (n) {
			return arguments.length ? (t = n, e) : t
		}, e.tickSize = function (t) {
			var n = arguments.length;
			return n ? (i = +t, o = +arguments[n - 1], e) : i
		}, e.innerTickSize = function (t) {
			return arguments.length ? (i = +t, e) : i
		}, e.outerTickSize = function (t) {
			return arguments.length ? (o = +t, e) : o
		}, e.tickPadding = function (t) {
			return arguments.length ? (a = +t, e) : a
		}, e.tickSubdivide = function () {
			return arguments.length && e
		}, e
	};
	var Lu = "bottom", ku = {top: 1, right: 1, bottom: 1, left: 1};
	Ga.svg.brush = function () {
		function e(o) {
			o.each(function () {
				var o = Ga.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", i).on("touchstart.brush", i), a = o.selectAll(".background").data([0]);
				a.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair"), o.selectAll(".extent").data([0]).enter().append("rect").attr("class", "extent").style("cursor", "move");
				var s = o.selectAll(".resize").data(p, bt);
				s.exit().remove(), s.enter().append("g").attr("class",function (e) {
					return"resize " + e
				}).style("cursor",function (e) {
					return Pu[e]
				}).append("rect").attr("x",function (e) {
					return/[ew]$/.test(e) ? -3 : null
				}).attr("y",function (e) {
					return/^[ns]/.test(e) ? -3 : null
				}).attr("width", 6).attr("height", 6).style("visibility", "hidden"), s.style("display", e.empty() ? "none" : null);
				var c, h = Ga.transition(o), f = Ga.transition(a);
				l && (c = Do(l), f.attr("x", c[0]).attr("width", c[1] - c[0]), n(h)), u && (c = Do(u), f.attr("y", c[0]).attr("height", c[1] - c[0]), r(h)), t(h)
			})
		}

		function t(e) {
			e.selectAll(".resize").attr("transform", function (e) {
				return"translate(" + c[+/e$/.test(e)] + "," + h[+/^s/.test(e)] + ")"
			})
		}

		function n(e) {
			e.select(".extent").attr("x", c[0]), e.selectAll(".extent,.n>rect,.s>rect").attr("width", c[1] - c[0])
		}

		function r(e) {
			e.select(".extent").attr("y", h[0]), e.selectAll(".extent,.e>rect,.w>rect").attr("height", h[1] - h[0])
		}

		function i() {
			function i() {
				32 == Ga.event.keyCode && (S || (y = null, A[0] -= c[1], A[1] -= h[1], S = 2), v())
			}

			function p() {
				32 == Ga.event.keyCode && 2 == S && (A[0] += c[1], A[1] += h[1], S = 0, v())
			}

			function m() {
				var e = Ga.mouse(x), i = !1;
				T && (e[0] += T[0], e[1] += T[1]), S || (Ga.event.altKey ? (y || (y = [(c[0] + c[1]) / 2, (h[0] + h[1]) / 2]), A[0] = c[+(e[0] < y[0])], A[1] = h[+(e[1] < y[1])]) : y = null), H && g(e, l, 0) && (n(_), i = !0), M && g(e, u, 1) && (r(_), i = !0), i && (t(_), b({type: "brush", mode: S ? "move" : "resize"}))
			}

			function g(e, t, n) {
				var r, i, s = Do(t), l = s[0], u = s[1], p = A[n], m = n ? h : c, g = m[1] - m[0];
				return S && (l -= p, u -= g + p), r = (n ? d : f) ? Math.max(l, Math.min(u, e[n])) : e[n], S ? i = (r += p) + g : (y && (p = Math.max(l, Math.min(u, 2 * y[n] - r))), r > p ? (i = r, r = p) : i = p), m[0] != r || m[1] != i ? (n ? a = null : o = null, m[0] = r, m[1] = i, !0) : void 0
			}

			function E() {
				m(), _.style("pointer-events", "all").selectAll(".resize").style("display", e.empty() ? "none" : null), Ga.select("body").style("cursor", null), L.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null), C(), b({type: "brushend"})
			}

			var y, T, x = this, R = Ga.select(Ga.event.target), b = s.of(x, arguments), _ = Ga.select(x), w = R.datum(), H = !/^(n|s)$/.test(w) && l, M = !/^(e|w)$/.test(w) && u, S = R.classed("extent"), C = j(), A = Ga.mouse(x), L = Ga.select(Za).on("keydown.brush", i).on("keyup.brush", p);
			if (Ga.event.changedTouches ? L.on("touchmove.brush", m).on("touchend.brush", E) : L.on("mousemove.brush", m).on("mouseup.brush", E), _.interrupt().selectAll("*").interrupt(), S)A[0] = c[0] - A[0], A[1] = h[0] - A[1]; else if (w) {
				var k = +/w$/.test(w), P = +/^n/.test(w);
				T = [c[1 - k] - A[0], h[1 - P] - A[1]], A[0] = c[k], A[1] = h[P]
			} else Ga.event.altKey && (y = A.slice());
			_.style("pointer-events", "none").selectAll(".resize").style("display", null), Ga.select("body").style("cursor", R.style("cursor")), b({type: "brushstart"}), m()
		}

		var o, a, s = T(e, "brushstart", "brush", "brushend"), l = null, u = null, c = [0, 0], h = [0, 0], f = !0, d = !0, p = Du[0];
		return e.event = function (e) {
			e.each(function () {
				var e = s.of(this, arguments), t = {x: c, y: h, i: o, j: a}, n = this.__chart__ || t;
				this.__chart__ = t, wu ? Ga.select(this).transition().each("start.brush",function () {
					o = n.i, a = n.j, c = n.x, h = n.y, e({type: "brushstart"})
				}).tween("brush:brush",function () {
					var n = pi(c, t.x), r = pi(h, t.y);
					return o = a = null, function (i) {
						c = t.x = n(i), h = t.y = r(i), e({type: "brush", mode: "resize"})
					}
				}).each("end.brush", function () {
					o = t.i, a = t.j, e({type: "brush", mode: "resize"}), e({type: "brushend"})
				}) : (e({type: "brushstart"}), e({type: "brush", mode: "resize"}), e({type: "brushend"}))
			})
		}, e.x = function (t) {
			return arguments.length ? (l = t, p = Du[!l << 1 | !u], e) : l
		}, e.y = function (t) {
			return arguments.length ? (u = t, p = Du[!l << 1 | !u], e) : u
		}, e.clamp = function (t) {
			return arguments.length ? (l && u ? (f = !!t[0], d = !!t[1]) : l ? f = !!t : u && (d = !!t), e) : l && u ? [f, d] : l ? f : u ? d : null
		}, e.extent = function (t) {
			var n, r, i, s, f;
			return arguments.length ? (l && (n = t[0], r = t[1], u && (n = n[0], r = r[0]), o = [n, r], l.invert && (n = l(n), r = l(r)), n > r && (f = n, n = r, r = f), (n != c[0] || r != c[1]) && (c = [n, r])), u && (i = t[0], s = t[1], l && (i = i[1], s = s[1]), a = [i, s], u.invert && (i = u(i), s = u(s)), i > s && (f = i, i = s, s = f), (i != h[0] || s != h[1]) && (h = [i, s])), e) : (l && (o ? (n = o[0], r = o[1]) : (n = c[0], r = c[1], l.invert && (n = l.invert(n), r = l.invert(r)), n > r && (f = n, n = r, r = f))), u && (a ? (i = a[0], s = a[1]) : (i = h[0], s = h[1], u.invert && (i = u.invert(i), s = u.invert(s)), i > s && (f = i, i = s, s = f))), l && u ? [
				[n, i],
				[r, s]
			] : l ? [n, r] : u && [i, s])
		}, e.clear = function () {
			return e.empty() || (c = [0, 0], h = [0, 0], o = a = null), e
		}, e.empty = function () {
			return!!l && c[0] == c[1] || !!u && h[0] == h[1]
		}, Ga.rebind(e, s, "on")
	};
	var Pu = {n: "ns-resize", e: "ew-resize", s: "ns-resize", w: "ew-resize", nw: "nwse-resize", ne: "nesw-resize", se: "nwse-resize", sw: "nesw-resize"}, Du = [
		["n", "e", "s", "w", "nw", "ne", "se", "sw"],
		["e", "w"],
		["n", "s"],
		[]
	], Fu = el.format = al.timeFormat, Nu = Fu.utc, zu = Nu("%Y-%m-%dT%H:%M:%S.%LZ");
	Fu.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? Ba : zu, Ba.parse = function (e) {
		var t = new Date(e);
		return isNaN(t) ? null : t
	}, Ba.toString = zu.toString, el.second = Ft(function (e) {
		return new tl(1e3 * Math.floor(e / 1e3))
	}, function (e, t) {
		e.setTime(e.getTime() + 1e3 * Math.floor(t))
	}, function (e) {
		return e.getSeconds()
	}), el.seconds = el.second.range, el.seconds.utc = el.second.utc.range, el.minute = Ft(function (e) {
		return new tl(6e4 * Math.floor(e / 6e4))
	}, function (e, t) {
		e.setTime(e.getTime() + 6e4 * Math.floor(t))
	}, function (e) {
		return e.getMinutes()
	}), el.minutes = el.minute.range, el.minutes.utc = el.minute.utc.range, el.hour = Ft(function (e) {
		var t = e.getTimezoneOffset() / 60;
		return new tl(36e5 * (Math.floor(e / 36e5 - t) + t))
	}, function (e, t) {
		e.setTime(e.getTime() + 36e5 * Math.floor(t))
	}, function (e) {
		return e.getHours()
	}), el.hours = el.hour.range, el.hours.utc = el.hour.utc.range, el.month = Ft(function (e) {
		return e = el.day(e), e.setDate(1), e
	}, function (e, t) {
		e.setMonth(e.getMonth() + t)
	}, function (e) {
		return e.getMonth()
	}), el.months = el.month.range, el.months.utc = el.month.utc.range;
	var Uu = [1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6], Vu = [
		[el.second, 1],
		[el.second, 5],
		[el.second, 15],
		[el.second, 30],
		[el.minute, 1],
		[el.minute, 5],
		[el.minute, 15],
		[el.minute, 30],
		[el.hour, 1],
		[el.hour, 3],
		[el.hour, 6],
		[el.hour, 12],
		[el.day, 1],
		[el.day, 2],
		[el.week, 1],
		[el.month, 1],
		[el.month, 3],
		[el.year, 1]
	], Bu = Fu.multi([
		[".%L", function (e) {
			return e.getMilliseconds()
		}],
		[":%S", function (e) {
			return e.getSeconds()
		}],
		["%I:%M", function (e) {
			return e.getMinutes()
		}],
		["%I %p", function (e) {
			return e.getHours()
		}],
		["%a %d", function (e) {
			return e.getDay() && 1 != e.getDate()
		}],
		["%b %d", function (e) {
			return 1 != e.getDate()
		}],
		["%B", function (e) {
			return e.getMonth()
		}],
		["%Y", _n]
	]), Ou = {range: function (e, t, n) {
		return Ga.range(Math.ceil(e / n) * n, +t, n).map(Ia)
	}, floor: bt, ceil: bt};
	Vu.year = el.year, el.scale = function () {
		return Oa(Ga.scale.linear(), Vu, Bu)
	};
	var Iu = Vu.map(function (e) {
		return[e[0].utc, e[1]]
	}), ju = Nu.multi([
		[".%L", function (e) {
			return e.getUTCMilliseconds()
		}],
		[":%S", function (e) {
			return e.getUTCSeconds()
		}],
		["%I:%M", function (e) {
			return e.getUTCMinutes()
		}],
		["%I %p", function (e) {
			return e.getUTCHours()
		}],
		["%a %d", function (e) {
			return e.getUTCDay() && 1 != e.getUTCDate()
		}],
		["%b %d", function (e) {
			return 1 != e.getUTCDate()
		}],
		["%B", function (e) {
			return e.getUTCMonth()
		}],
		["%Y", _n]
	]);
	Iu.year = el.year.utc, el.scale.utc = function () {
		return Oa(Ga.scale.linear(), Iu, ju)
	}, Ga.text = _t(function (e) {
		return e.responseText
	}), Ga.json = function (e, t) {
		return wt(e, "application/json", ja, t)
	}, Ga.html = function (e, t) {
		return wt(e, "text/html", Wa, t)
	}, Ga.xml = _t(function (e) {
		return e.responseXML
	}), "function" == typeof define && define.amd ? define(Ga) : "object" == typeof module && module.exports && (module.exports = Ga), this.d3 = Ga
}(), function () {
	function e(e, t, n) {
		n = (n || 0) - 1;
		for (var r = e ? e.length : 0; ++n < r;)if (e[n] === t)return n;
		return-1
	}

	function t(t, n) {
		var r = typeof n;
		if (t = t.l, "boolean" == r || null == n)return t[n] ? 0 : -1;
		"number" != r && "string" != r && (r = "object");
		var i = "number" == r ? n : E + n;
		return t = (t = t[r]) && t[i], "object" == r ? t && -1 < e(t, n) ? 0 : -1 : t ? 0 : -1
	}

	function n(e) {
		var t = this.l, n = typeof e;
		if ("boolean" == n || null == e)t[e] = !0; else {
			"number" != n && "string" != n && (n = "object");
			var r = "number" == n ? e : E + e, t = t[n] || (t[n] = {});
			"object" == n ? (t[r] || (t[r] = [])).push(e) : t[r] = !0
		}
	}

	function r(e) {
		return e.charCodeAt(0)
	}

	function i(e, t) {
		for (var n = e.m, r = t.m, i = -1, o = n.length; ++i < o;) {
			var a = n[i], s = r[i];
			if (a !== s) {
				if (a > s || "undefined" == typeof a)return 1;
				if (s > a || "undefined" == typeof s)return-1
			}
		}
		return e.n - t.n
	}

	function o(e) {
		var t = -1, r = e.length, i = e[0], o = e[r / 2 | 0], a = e[r - 1];
		if (i && "object" == typeof i && o && "object" == typeof o && a && "object" == typeof a)return!1;
		for (i = l(), i["false"] = i["null"] = i["true"] = i.undefined = !1, o = l(), o.k = e, o.l = i, o.push = n; ++t < r;)o.push(e[t]);
		return o
	}

	function a(e) {
		return"\\" + X[e]
	}

	function s() {
		return p.pop() || []
	}

	function l() {
		return m.pop() || {k: null, l: null, m: null, "false": !1, n: 0, "null": !1, number: null, object: null, push: null, string: null, "true": !1, undefined: !1, o: null}
	}

	function u(e) {
		e.length = 0, p.length < y && p.push(e)
	}

	function c(e) {
		var t = e.l;
		t && c(t), e.k = e.l = e.m = e.object = e.number = e.string = e.o = null, m.length < y && m.push(e)
	}

	function h(e, t, n) {
		t || (t = 0), "undefined" == typeof n && (n = e ? e.length : 0);
		var r = -1;
		n = n - t || 0;
		for (var i = Array(0 > n ? 0 : n); ++r < n;)i[r] = e[t + r];
		return i
	}

	function f(n) {
		function p(e, t, n) {
			if (!e || !G[typeof e])return e;
			t = t && "undefined" == typeof n ? t : tt(t, n, 3);
			for (var r = -1, i = G[typeof e] && zn(e), o = i ? i.length : 0; ++r < o && (n = i[r], !1 !== t(e[n], n, e)););
			return e
		}

		function m(e, t, n) {
			var r;
			if (!e || !G[typeof e])return e;
			t = t && "undefined" == typeof n ? t : tt(t, n, 3);
			for (r in e)if (!1 === t(e[r], r, e))break;
			return e
		}

		function y(e, t, n) {
			var r, i = e, o = i;
			if (!i)return o;
			for (var a = arguments, s = 0, l = "number" == typeof n ? 2 : a.length; ++s < l;)if ((i = a[s]) && G[typeof i])for (var u = -1, c = G[typeof i] && zn(i), h = c ? c.length : 0; ++u < h;)r = c[u], "undefined" == typeof o[r] && (o[r] = i[r]);
			return o
		}

		function X(e, t, n) {
			var r, i = e, o = i;
			if (!i)return o;
			var a = arguments, s = 0, l = "number" == typeof n ? 2 : a.length;
			if (l > 3 && "function" == typeof a[l - 2])var u = tt(a[--l - 1], a[l--], 2); else l > 2 && "function" == typeof a[l - 1] && (u = a[--l]);
			for (; ++s < l;)if ((i = a[s]) && G[typeof i])for (var c = -1, h = G[typeof i] && zn(i), f = h ? h.length : 0; ++c < f;)r = h[c], o[r] = u ? u(o[r], i[r]) : i[r];
			return o
		}

		function Y(e) {
			var t, n = [];
			if (!e || !G[typeof e])return n;
			for (t in e)vn.call(e, t) && n.push(t);
			return n
		}

		function K(e) {
			return e && "object" == typeof e && !Nn(e) && vn.call(e, "__wrapped__") ? e : new Z(e)
		}

		function Z(e, t) {
			this.__chain__ = !!t, this.__wrapped__ = e
		}

		function Q(e) {
			function t() {
				if (r) {
					var e = h(r);
					yn.apply(e, arguments)
				}
				if (this instanceof t) {
					var o = et(n.prototype), e = n.apply(o, e || arguments);
					return xt(e) ? e : o
				}
				return n.apply(i, e || arguments)
			}

			var n = e[0], r = e[2], i = e[4];
			return Fn(t, e), t
		}

		function J(e, t, n, r, i) {
			if (n) {
				var o = n(e);
				if ("undefined" != typeof o)return o
			}
			if (!xt(e))return e;
			var a = hn.call(e);
			if (!I[a])return e;
			var l = Pn[a];
			switch (a) {
				case F:
				case N:
					return new l(+e);
				case U:
				case O:
					return new l(e);
				case B:
					return o = l(e.source, w.exec(e)), o.lastIndex = e.lastIndex, o
			}
			if (a = Nn(e), t) {
				var c = !r;
				r || (r = s()), i || (i = s());
				for (var f = r.length; f--;)if (r[f] == e)return i[f];
				o = a ? l(e.length) : {}
			} else o = a ? h(e) : X({}, e);
			return a && (vn.call(e, "index") && (o.index = e.index), vn.call(e, "input") && (o.input = e.input)), t ? (r.push(e), i.push(o), (a ? Ct : p)(e, function (e, a) {
				o[a] = J(e, t, n, r, i)
			}), c && (u(r), u(i)), o) : o
		}

		function et(e) {
			return xt(e) ? _n(e) : {}
		}

		function tt(e, t, n) {
			if ("function" != typeof e)return Xt;
			if ("undefined" == typeof t || !("prototype"in e))return e;
			var r = e.__bindData__;
			if ("undefined" == typeof r && (Dn.funcNames && (r = !e.name), r = r || !Dn.funcDecomp, !r)) {
				var i = gn.call(e);
				Dn.funcNames || (r = !H.test(i)), r || (r = A.test(i), Fn(e, r))
			}
			if (!1 === r || !0 !== r && 1 & r[1])return e;
			switch (n) {
				case 1:
					return function (n) {
						return e.call(t, n)
					};
				case 2:
					return function (n, r) {
						return e.call(t, n, r)
					};
				case 3:
					return function (n, r, i) {
						return e.call(t, n, r, i)
					};
				case 4:
					return function (n, r, i, o) {
						return e.call(t, n, r, i, o)
					}
			}
			return Wt(e, t)
		}

		function nt(e) {
			function t() {
				var e = l ? a : this;
				if (i) {
					var p = h(i);
					yn.apply(p, arguments)
				}
				return(o || c) && (p || (p = h(arguments)), o && yn.apply(p, o), c && p.length < s) ? (r |= 16, nt([n, f ? r : -4 & r, p, null, a, s])) : (p || (p = arguments), u && (n = e[d]), this instanceof t ? (e = et(n.prototype), p = n.apply(e, p), xt(p) ? p : e) : n.apply(e, p))
			}

			var n = e[0], r = e[1], i = e[2], o = e[3], a = e[4], s = e[5], l = 1 & r, u = 2 & r, c = 4 & r, f = 8 & r, d = n;
			return Fn(t, e), t
		}

		function rt(n, r) {
			var i = -1, a = ft(), s = n ? n.length : 0, l = s >= v && a === e, u = [];
			if (l) {
				var h = o(r);
				h ? (a = t, r = h) : l = !1
			}
			for (; ++i < s;)h = n[i], 0 > a(r, h) && u.push(h);
			return l && c(r), u
		}

		function it(e, t, n, r) {
			r = (r || 0) - 1;
			for (var i = e ? e.length : 0, o = []; ++r < i;) {
				var a = e[r];
				if (a && "object" == typeof a && "number" == typeof a.length && (Nn(a) || gt(a))) {
					t || (a = it(a, t, n));
					var s = -1, l = a.length, u = o.length;
					for (o.length += l; ++s < l;)o[u++] = a[s]
				} else n || o.push(a)
			}
			return o
		}

		function ot(e, t, n, r, i, o) {
			if (n) {
				var a = n(e, t);
				if ("undefined" != typeof a)return!!a
			}
			if (e === t)return 0 !== e || 1 / e == 1 / t;
			if (e === e && !(e && G[typeof e] || t && G[typeof t]))return!1;
			if (null == e || null == t)return e === t;
			var l = hn.call(e), c = hn.call(t);
			if (l == P && (l = V), c == P && (c = V), l != c)return!1;
			switch (l) {
				case F:
				case N:
					return+e == +t;
				case U:
					return e != +e ? t != +t : 0 == e ? 1 / e == 1 / t : e == +t;
				case B:
				case O:
					return e == an(t)
			}
			if (c = l == D, !c) {
				var h = vn.call(e, "__wrapped__"), f = vn.call(t, "__wrapped__");
				if (h || f)return ot(h ? e.__wrapped__ : e, f ? t.__wrapped__ : t, n, r, i, o);
				if (l != V)return!1;
				if (l = e.constructor, h = t.constructor, l != h && !(Tt(l) && l instanceof l && Tt(h) && h instanceof h) && "constructor"in e && "constructor"in t)return!1
			}
			for (l = !i, i || (i = s()), o || (o = s()), h = i.length; h--;)if (i[h] == e)return o[h] == t;
			var d = 0, a = !0;
			if (i.push(e), o.push(t), c) {
				if (h = e.length, d = t.length, (a = d == h) || r)for (; d--;)if (c = h, f = t[d], r)for (; c-- && !(a = ot(e[c], f, n, r, i, o));); else if (!(a = ot(e[d], f, n, r, i, o)))break
			} else m(t, function (t, s, l) {
				return vn.call(l, s) ? (d++, a = vn.call(e, s) && ot(e[s], t, n, r, i, o)) : void 0
			}), a && !r && m(e, function (e, t, n) {
				return vn.call(n, t) ? a = -1 < --d : void 0
			});
			return i.pop(), o.pop(), l && (u(i), u(o)), a
		}

		function at(e, t, n, r, i) {
			(Nn(t) ? Ct : p)(t, function (t, o) {
				var a, s, l = t, u = e[o];
				if (t && ((s = Nn(t)) || In(t))) {
					for (l = r.length; l--;)if (a = r[l] == t) {
						u = i[l];
						break
					}
					if (!a) {
						var c;
						n && (l = n(u, t), c = "undefined" != typeof l) && (u = l), c || (u = s ? Nn(u) ? u : [] : In(u) ? u : {}), r.push(t), i.push(u), c || at(u, t, n, r, i)
					}
				} else n && (l = n(u, t), "undefined" == typeof l && (l = t)), "undefined" != typeof l && (u = l);
				e[o] = u
			})
		}

		function st(e, t) {
			return e + mn(kn() * (t - e + 1))
		}

		function lt(n, r, i) {
			var a = -1, l = ft(), h = n ? n.length : 0, f = [], d = !r && h >= v && l === e, p = i || d ? s() : f;
			for (d && (p = o(p), l = t); ++a < h;) {
				var m = n[a], g = i ? i(m, a, n) : m;
				(r ? !a || p[p.length - 1] !== g : 0 > l(p, g)) && ((i || d) && p.push(g), f.push(m))
			}
			return d ? (u(p.k), c(p)) : i && u(p), f
		}

		function ut(e) {
			return function (t, n, r) {
				var i = {};
				n = K.createCallback(n, r, 3), r = -1;
				var o = t ? t.length : 0;
				if ("number" == typeof o)for (; ++r < o;) {
					var a = t[r];
					e(i, a, n(a, r, t), t)
				} else p(t, function (t, r, o) {
					e(i, t, n(t, r, o), o)
				});
				return i
			}
		}

		function ct(e, t, n, r, i, o) {
			var a = 1 & t, s = 4 & t, l = 16 & t, u = 32 & t;
			if (!(2 & t || Tt(e)))throw new sn;
			l && !n.length && (t &= -17, l = n = !1), u && !r.length && (t &= -33, u = r = !1);
			var c = e && e.__bindData__;
			return c && !0 !== c ? (c = h(c), c[2] && (c[2] = h(c[2])), c[3] && (c[3] = h(c[3])), !a || 1 & c[1] || (c[4] = i), !a && 1 & c[1] && (t |= 8), !s || 4 & c[1] || (c[5] = o), l && yn.apply(c[2] || (c[2] = []), n), u && Rn.apply(c[3] || (c[3] = []), r), c[1] |= t, ct.apply(null, c)) : (1 == t || 17 === t ? Q : nt)([e, t, n, r, i, o])
		}

		function ht(e) {
			return Un[e]
		}

		function ft() {
			var t = (t = K.indexOf) === Ut ? e : t;
			return t
		}

		function dt(e) {
			return"function" == typeof e && fn.test(e)
		}

		function pt(e) {
			var t, n;
			return e && hn.call(e) == V && (t = e.constructor, !Tt(t) || t instanceof t) ? (m(e, function (e, t) {
				n = t
			}), "undefined" == typeof n || vn.call(e, n)) : !1
		}

		function mt(e) {
			return Vn[e]
		}

		function gt(e) {
			return e && "object" == typeof e && "number" == typeof e.length && hn.call(e) == P || !1
		}

		function Et(e, t, n) {
			var r = zn(e), i = r.length;
			for (t = tt(t, n, 3); i-- && (n = r[i], !1 !== t(e[n], n, e)););
			return e
		}

		function vt(e) {
			var t = [];
			return m(e, function (e, n) {
				Tt(e) && t.push(n)
			}), t.sort()
		}

		function yt(e) {
			for (var t = -1, n = zn(e), r = n.length, i = {}; ++t < r;) {
				var o = n[t];
				i[e[o]] = o
			}
			return i
		}

		function Tt(e) {
			return"function" == typeof e
		}

		function xt(e) {
			return!(!e || !G[typeof e])
		}

		function Rt(e) {
			return"number" == typeof e || e && "object" == typeof e && hn.call(e) == U || !1
		}

		function bt(e) {
			return"string" == typeof e || e && "object" == typeof e && hn.call(e) == O || !1
		}

		function _t(e) {
			for (var t = -1, n = zn(e), r = n.length, i = Qt(r); ++t < r;)i[t] = e[n[t]];
			return i
		}

		function wt(e, t, n) {
			var r = -1, i = ft(), o = e ? e.length : 0, a = !1;
			return n = (0 > n ? Cn(0, o + n) : n) || 0, Nn(e) ? a = -1 < i(e, t, n) : "number" == typeof o ? a = -1 < (bt(e) ? e.indexOf(t, n) : i(e, t, n)) : p(e, function (e) {
				return++r < n ? void 0 : !(a = e === t)
			}), a
		}

		function Ht(e, t, n) {
			var r = !0;
			t = K.createCallback(t, n, 3), n = -1;
			var i = e ? e.length : 0;
			if ("number" == typeof i)for (; ++n < i && (r = !!t(e[n], n, e));); else p(e, function (e, n, i) {
				return r = !!t(e, n, i)
			});
			return r
		}

		function Mt(e, t, n) {
			var r = [];
			t = K.createCallback(t, n, 3), n = -1;
			var i = e ? e.length : 0;
			if ("number" == typeof i)for (; ++n < i;) {
				var o = e[n];
				t(o, n, e) && r.push(o)
			} else p(e, function (e, n, i) {
				t(e, n, i) && r.push(e)
			});
			return r
		}

		function St(e, t, n) {
			t = K.createCallback(t, n, 3), n = -1;
			var r = e ? e.length : 0;
			if ("number" != typeof r) {
				var i;
				return p(e, function (e, n, r) {
					return t(e, n, r) ? (i = e, !1) : void 0
				}), i
			}
			for (; ++n < r;) {
				var o = e[n];
				if (t(o, n, e))return o
			}
		}

		function Ct(e, t, n) {
			var r = -1, i = e ? e.length : 0;
			if (t = t && "undefined" == typeof n ? t : tt(t, n, 3), "number" == typeof i)for (; ++r < i && !1 !== t(e[r], r, e);); else p(e, t);
			return e
		}

		function At(e, t, n) {
			var r = e ? e.length : 0;
			if (t = t && "undefined" == typeof n ? t : tt(t, n, 3), "number" == typeof r)for (; r-- && !1 !== t(e[r], r, e);); else {
				var i = zn(e), r = i.length;
				p(e, function (e, n, o) {
					return n = i ? i[--r] : --r, t(o[n], n, o)
				})
			}
			return e
		}

		function Lt(e, t, n) {
			var r = -1, i = e ? e.length : 0;
			if (t = K.createCallback(t, n, 3), "number" == typeof i)for (var o = Qt(i); ++r < i;)o[r] = t(e[r], r, e); else o = [], p(e, function (e, n, i) {
				o[++r] = t(e, n, i)
			});
			return o
		}

		function kt(e, t, n) {
			var i = -1 / 0, o = i;
			if ("function" != typeof t && n && n[t] === e && (t = null), null == t && Nn(e)) {
				n = -1;
				for (var a = e.length; ++n < a;) {
					var s = e[n];
					s > o && (o = s)
				}
			} else t = null == t && bt(e) ? r : K.createCallback(t, n, 3), Ct(e, function (e, n, r) {
				n = t(e, n, r), n > i && (i = n, o = e)
			});
			return o
		}

		function Pt(e, t, n, r) {
			if (!e)return n;
			var i = 3 > arguments.length;
			t = K.createCallback(t, r, 4);
			var o = -1, a = e.length;
			if ("number" == typeof a)for (i && (n = e[++o]); ++o < a;)n = t(n, e[o], o, e); else p(e, function (e, r, o) {
				n = i ? (i = !1, e) : t(n, e, r, o)
			});
			return n
		}

		function Dt(e, t, n, r) {
			var i = 3 > arguments.length;
			return t = K.createCallback(t, r, 4), At(e, function (e, r, o) {
				n = i ? (i = !1, e) : t(n, e, r, o)
			}), n
		}

		function Ft(e) {
			var t = -1, n = e ? e.length : 0, r = Qt("number" == typeof n ? n : 0);
			return Ct(e, function (e) {
				var n = st(0, ++t);
				r[t] = r[n], r[n] = e
			}), r
		}

		function Nt(e, t, n) {
			var r;
			t = K.createCallback(t, n, 3), n = -1;
			var i = e ? e.length : 0;
			if ("number" == typeof i)for (; ++n < i && !(r = t(e[n], n, e));); else p(e, function (e, n, i) {
				return!(r = t(e, n, i))
			});
			return!!r
		}

		function zt(e, t, n) {
			var r = 0, i = e ? e.length : 0;
			if ("number" != typeof t && null != t) {
				var o = -1;
				for (t = K.createCallback(t, n, 3); ++o < i && t(e[o], o, e);)r++
			} else if (r = t, null == r || n)return e ? e[0] : d;
			return h(e, 0, An(Cn(0, r), i))
		}

		function Ut(t, n, r) {
			if ("number" == typeof r) {
				var i = t ? t.length : 0;
				r = 0 > r ? Cn(0, i + r) : r || 0
			} else if (r)return r = Bt(t, n), t[r] === n ? r : -1;
			return e(t, n, r)
		}

		function Vt(e, t, n) {
			if ("number" != typeof t && null != t) {
				var r = 0, i = -1, o = e ? e.length : 0;
				for (t = K.createCallback(t, n, 3); ++i < o && t(e[i], i, e);)r++
			} else r = null == t || n ? 1 : Cn(0, t);
			return h(e, r)
		}

		function Bt(e, t, n, r) {
			var i = 0, o = e ? e.length : i;
			for (n = n ? K.createCallback(n, r, 1) : Xt, t = n(t); o > i;)r = i + o >>> 1, n(e[r]) < t ? i = r + 1 : o = r;
			return i
		}

		function Ot(e, t, n, r) {
			return"boolean" != typeof t && null != t && (r = n, n = "function" != typeof t && r && r[t] === e ? null : t, t = !1), null != n && (n = K.createCallback(n, r, 3)), lt(e, t, n)
		}

		function It() {
			for (var e = 1 < arguments.length ? arguments : arguments[0], t = -1, n = e ? kt(Xn(e, "length")) : 0, r = Qt(0 > n ? 0 : n); ++t < n;)r[t] = Xn(e, t);
			return r
		}

		function jt(e, t) {
			var n = -1, r = e ? e.length : 0, i = {};
			for (t || !r || Nn(e[0]) || (t = []); ++n < r;) {
				var o = e[n];
				t ? i[o] = t[n] : o && (i[o[0]] = o[1])
			}
			return i
		}

		function Wt(e, t) {
			return 2 < arguments.length ? ct(e, 17, h(arguments, 2), null, t) : ct(e, 1, null, null, t)
		}

		function Gt(e, t, n) {
			function r() {
				c && pn(c), a = c = h = d, (m || p !== t) && (f = qn(), s = e.apply(u, o), c || a || (o = u = null))
			}

			function i() {
				var n = t - (qn() - l);
				n > 0 ? c = Tn(i, n) : (a && pn(a), n = h, a = c = h = d, n && (f = qn(), s = e.apply(u, o), c || a || (o = u = null)))
			}

			var o, a, s, l, u, c, h, f = 0, p = !1, m = !0;
			if (!Tt(e))throw new sn;
			if (t = Cn(0, t) || 0, !0 === n)var g = !0, m = !1; else xt(n) && (g = n.leading, p = "maxWait"in n && (Cn(t, n.maxWait) || 0), m = "trailing"in n ? n.trailing : m);
			return function () {
				if (o = arguments, l = qn(), u = this, h = m && (c || !g), !1 === p)var n = g && !c; else {
					a || g || (f = l);
					var d = p - (l - f), E = 0 >= d;
					E ? (a && (a = pn(a)), f = l, s = e.apply(u, o)) : a || (a = Tn(r, d))
				}
				return E && c ? c = pn(c) : c || t === p || (c = Tn(i, t)), n && (E = !0, s = e.apply(u, o)), !E || c || a || (o = u = null), s
			}
		}

		function Xt(e) {
			return e
		}

		function qt(e, t, n) {
			var r = !0, i = t && vt(t);
			t && (n || i.length) || (null == n && (n = t), o = Z, t = e, e = K, i = vt(t)), !1 === n ? r = !1 : xt(n) && "chain"in n && (r = n.chain);
			var o = e, a = Tt(o);
			Ct(i, function (n) {
				var i = e[n] = t[n];
				a && (o.prototype[n] = function () {
					var t = this.__chain__, n = this.__wrapped__, a = [n];
					if (yn.apply(a, arguments), a = i.apply(e, a), r || t) {
						if (n === a && xt(a))return this;
						a = new o(a), a.__chain__ = t
					}
					return a
				})
			})
		}

		function Yt() {
		}

		function Kt(e) {
			return function (t) {
				return t[e]
			}
		}

		function Zt() {
			return this.__wrapped__
		}

		n = n ? $.defaults(q.Object(), n, $.pick(q, k)) : q;
		var Qt = n.Array, $t = n.Boolean, Jt = n.Date, en = n.Function, tn = n.Math, nn = n.Number, rn = n.Object, on = n.RegExp, an = n.String, sn = n.TypeError, ln = [], un = rn.prototype, cn = n._, hn = un.toString, fn = on("^" + an(hn).replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/toString| for [^\]]+/g, ".*?") + "$"), dn = tn.ceil, pn = n.clearTimeout, mn = tn.floor, gn = en.prototype.toString, En = dt(En = rn.getPrototypeOf) && En, vn = un.hasOwnProperty, yn = ln.push, Tn = n.setTimeout, xn = ln.splice, Rn = ln.unshift, bn = function () {
			try {
				var e = {}, t = dt(t = rn.defineProperty) && t, n = t(e, e, e) && t
			} catch (r) {
			}
			return n
		}(), _n = dt(_n = rn.create) && _n, wn = dt(wn = Qt.isArray) && wn, Hn = n.isFinite, Mn = n.isNaN, Sn = dt(Sn = rn.keys) && Sn, Cn = tn.max, An = tn.min, Ln = n.parseInt, kn = tn.random, Pn = {};
		Pn[D] = Qt, Pn[F] = $t, Pn[N] = Jt, Pn[z] = en, Pn[V] = rn, Pn[U] = nn, Pn[B] = on, Pn[O] = an, Z.prototype = K.prototype;
		var Dn = K.support = {};
		Dn.funcDecomp = !dt(n.a) && A.test(f), Dn.funcNames = "string" == typeof en.name, K.templateSettings = {escape: /<%-([\s\S]+?)%>/g, evaluate: /<%([\s\S]+?)%>/g, interpolate: M, variable: "", imports: {_: K}}, _n || (et = function () {
			function e() {
			}

			return function (t) {
				if (xt(t)) {
					e.prototype = t;
					var r = new e;
					e.prototype = null
				}
				return r || n.Object()
			}
		}());
		var Fn = bn ? function (e, t) {
			W.value = t, bn(e, "__bindData__", W)
		} : Yt, Nn = wn || function (e) {
			return e && "object" == typeof e && "number" == typeof e.length && hn.call(e) == D || !1
		}, zn = Sn ? function (e) {
			return xt(e) ? Sn(e) : []
		} : Y, Un = {"&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;"}, Vn = yt(Un), Bn = on("(" + zn(Vn).join("|") + ")", "g"), On = on("[" + zn(Un).join("") + "]", "g"), In = En ? function (e) {
			if (!e || hn.call(e) != V)return!1;
			var t = e.valueOf, n = dt(t) && (n = En(t)) && En(n);
			return n ? e == n || En(e) == n : pt(e)
		} : pt, jn = ut(function (e, t, n) {
			vn.call(e, n) ? e[n]++ : e[n] = 1
		}), Wn = ut(function (e, t, n) {
			(vn.call(e, n) ? e[n] : e[n] = []).push(t)
		}), Gn = ut(function (e, t, n) {
			e[n] = t
		}), Xn = Lt, qn = dt(qn = Jt.now) && qn || function () {
			return(new Jt).getTime()
		}, Yn = 8 == Ln(T + "08") ? Ln : function (e, t) {
			return Ln(bt(e) ? e.replace(S, "") : e, t || 0)
		};
		return K.after = function (e, t) {
			if (!Tt(t))throw new sn;
			return function () {
				return 1 > --e ? t.apply(this, arguments) : void 0
			}
		}, K.assign = X, K.at = function (e) {
			for (var t = arguments, n = -1, r = it(t, !0, !1, 1), t = t[2] && t[2][t[1]] === e ? 1 : r.length, i = Qt(t); ++n < t;)i[n] = e[r[n]];
			return i
		}, K.bind = Wt, K.bindAll = function (e) {
			for (var t = 1 < arguments.length ? it(arguments, !0, !1, 1) : vt(e), n = -1, r = t.length; ++n < r;) {
				var i = t[n];
				e[i] = ct(e[i], 1, null, null, e)
			}
			return e
		}, K.bindKey = function (e, t) {
			return 2 < arguments.length ? ct(t, 19, h(arguments, 2), null, e) : ct(t, 3, null, null, e)
		}, K.chain = function (e) {
			return e = new Z(e), e.__chain__ = !0, e
		}, K.compact = function (e) {
			for (var t = -1, n = e ? e.length : 0, r = []; ++t < n;) {
				var i = e[t];
				i && r.push(i)
			}
			return r
		}, K.compose = function () {
			for (var e = arguments, t = e.length; t--;)if (!Tt(e[t]))throw new sn;
			return function () {
				for (var t = arguments, n = e.length; n--;)t = [e[n].apply(this, t)];
				return t[0]
			}
		}, K.constant = function (e) {
			return function () {
				return e
			}
		}, K.countBy = jn, K.create = function (e, t) {
			var n = et(e);
			return t ? X(n, t) : n
		}, K.createCallback = function (e, t, n) {
			var r = typeof e;
			if (null == e || "function" == r)return tt(e, t, n);
			if ("object" != r)return Kt(e);
			var i = zn(e), o = i[0], a = e[o];
			return 1 != i.length || a !== a || xt(a) ? function (t) {
				for (var n = i.length, r = !1; n-- && (r = ot(t[i[n]], e[i[n]], null, !0)););
				return r
			} : function (e) {
				return e = e[o], a === e && (0 !== a || 1 / a == 1 / e)
			}
		}, K.curry = function (e, t) {
			return t = "number" == typeof t ? t : +t || e.length, ct(e, 4, null, null, null, t)
		}, K.debounce = Gt, K.defaults = y, K.defer = function (e) {
			if (!Tt(e))throw new sn;
			var t = h(arguments, 1);
			return Tn(function () {
				e.apply(d, t)
			}, 1)
		}, K.delay = function (e, t) {
			if (!Tt(e))throw new sn;
			var n = h(arguments, 2);
			return Tn(function () {
				e.apply(d, n)
			}, t)
		}, K.difference = function (e) {
			return rt(e, it(arguments, !0, !0, 1))
		}, K.filter = Mt, K.flatten = function (e, t, n, r) {
			return"boolean" != typeof t && null != t && (r = n, n = "function" != typeof t && r && r[t] === e ? null : t, t = !1), null != n && (e = Lt(e, n, r)), it(e, t)
		}, K.forEach = Ct, K.forEachRight = At, K.forIn = m, K.forInRight = function (e, t, n) {
			var r = [];
			m(e, function (e, t) {
				r.push(t, e)
			});
			var i = r.length;
			for (t = tt(t, n, 3); i-- && !1 !== t(r[i--], r[i], e););
			return e
		}, K.forOwn = p, K.forOwnRight = Et, K.functions = vt, K.groupBy = Wn, K.indexBy = Gn, K.initial = function (e, t, n) {
			var r = 0, i = e ? e.length : 0;
			if ("number" != typeof t && null != t) {
				var o = i;
				for (t = K.createCallback(t, n, 3); o-- && t(e[o], o, e);)r++
			} else r = null == t || n ? 1 : t || r;
			return h(e, 0, An(Cn(0, i - r), i))
		}, K.intersection = function () {
			for (var n = [], r = -1, i = arguments.length, a = s(), l = ft(), h = l === e, f = s(); ++r < i;) {
				var d = arguments[r];
				(Nn(d) || gt(d)) && (n.push(d), a.push(h && d.length >= v && o(r ? n[r] : f)))
			}
			var h = n[0], p = -1, m = h ? h.length : 0, g = [];
			e:for (; ++p < m;) {
				var E = a[0], d = h[p];
				if (0 > (E ? t(E, d) : l(f, d))) {
					for (r = i, (E || f).push(d); --r;)if (E = a[r], 0 > (E ? t(E, d) : l(n[r], d)))continue e;
					g.push(d)
				}
			}
			for (; i--;)(E = a[i]) && c(E);
			return u(a), u(f), g
		}, K.invert = yt, K.invoke = function (e, t) {
			var n = h(arguments, 2), r = -1, i = "function" == typeof t, o = e ? e.length : 0, a = Qt("number" == typeof o ? o : 0);
			return Ct(e, function (e) {
				a[++r] = (i ? t : e[t]).apply(e, n)
			}), a
		}, K.keys = zn, K.map = Lt, K.mapValues = function (e, t, n) {
			var r = {};
			return t = K.createCallback(t, n, 3), p(e, function (e, n, i) {
				r[n] = t(e, n, i)
			}), r
		}, K.max = kt, K.memoize = function (e, t) {
			function n() {
				var r = n.cache, i = t ? t.apply(this, arguments) : E + arguments[0];
				return vn.call(r, i) ? r[i] : r[i] = e.apply(this, arguments)
			}

			if (!Tt(e))throw new sn;
			return n.cache = {}, n
		}, K.merge = function (e) {
			var t = arguments, n = 2;
			if (!xt(e))return e;
			if ("number" != typeof t[2] && (n = t.length), n > 3 && "function" == typeof t[n - 2])var r = tt(t[--n - 1], t[n--], 2); else n > 2 && "function" == typeof t[n - 1] && (r = t[--n]);
			for (var t = h(arguments, 1, n), i = -1, o = s(), a = s(); ++i < n;)at(e, t[i], r, o, a);
			return u(o), u(a), e
		}, K.min = function (e, t, n) {
			var i = 1 / 0, o = i;
			if ("function" != typeof t && n && n[t] === e && (t = null), null == t && Nn(e)) {
				n = -1;
				for (var a = e.length; ++n < a;) {
					var s = e[n];
					o > s && (o = s)
				}
			} else t = null == t && bt(e) ? r : K.createCallback(t, n, 3), Ct(e, function (e, n, r) {
				n = t(e, n, r), i > n && (i = n, o = e)
			});
			return o
		}, K.omit = function (e, t, n) {
			var r = {};
			if ("function" != typeof t) {
				var i = [];
				m(e, function (e, t) {
					i.push(t)
				});
				for (var i = rt(i, it(arguments, !0, !1, 1)), o = -1, a = i.length; ++o < a;) {
					var s = i[o];
					r[s] = e[s]
				}
			} else t = K.createCallback(t, n, 3), m(e, function (e, n, i) {
				t(e, n, i) || (r[n] = e)
			});
			return r
		}, K.once = function (e) {
			var t, n;
			if (!Tt(e))throw new sn;
			return function () {
				return t ? n : (t = !0, n = e.apply(this, arguments), e = null, n)
			}
		}, K.pairs = function (e) {
			for (var t = -1, n = zn(e), r = n.length, i = Qt(r); ++t < r;) {
				var o = n[t];
				i[t] = [o, e[o]]
			}
			return i
		}, K.partial = function (e) {
			return ct(e, 16, h(arguments, 1))
		}, K.partialRight = function (e) {
			return ct(e, 32, null, h(arguments, 1))
		}, K.pick = function (e, t, n) {
			var r = {};
			if ("function" != typeof t)for (var i = -1, o = it(arguments, !0, !1, 1), a = xt(e) ? o.length : 0; ++i < a;) {
				var s = o[i];
				s in e && (r[s] = e[s])
			} else t = K.createCallback(t, n, 3), m(e, function (e, n, i) {
				t(e, n, i) && (r[n] = e)
			});
			return r
		}, K.pluck = Xn, K.property = Kt, K.pull = function (e) {
			for (var t = arguments, n = 0, r = t.length, i = e ? e.length : 0; ++n < r;)for (var o = -1, a = t[n]; ++o < i;)e[o] === a && (xn.call(e, o--, 1), i--);
			return e
		}, K.range = function (e, t, n) {
			e = +e || 0, n = "number" == typeof n ? n : +n || 1, null == t && (t = e, e = 0);
			var r = -1;
			t = Cn(0, dn((t - e) / (n || 1)));
			for (var i = Qt(t); ++r < t;)i[r] = e, e += n;
			return i
		}, K.reject = function (e, t, n) {
			return t = K.createCallback(t, n, 3), Mt(e, function (e, n, r) {
				return!t(e, n, r)
			})
		}, K.remove = function (e, t, n) {
			var r = -1, i = e ? e.length : 0, o = [];
			for (t = K.createCallback(t, n, 3); ++r < i;)n = e[r], t(n, r, e) && (o.push(n), xn.call(e, r--, 1), i--);
			return o
		}, K.rest = Vt, K.shuffle = Ft, K.sortBy = function (e, t, n) {
			var r = -1, o = Nn(t), a = e ? e.length : 0, h = Qt("number" == typeof a ? a : 0);
			for (o || (t = K.createCallback(t, n, 3)), Ct(e, function (e, n, i) {
				var a = h[++r] = l();
				o ? a.m = Lt(t, function (t) {
					return e[t]
				}) : (a.m = s())[0] = t(e, n, i), a.n = r, a.o = e
			}), a = h.length, h.sort(i); a--;)e = h[a], h[a] = e.o, o || u(e.m), c(e);
			return h
		}, K.tap = function (e, t) {
			return t(e), e
		}, K.throttle = function (e, t, n) {
			var r = !0, i = !0;
			if (!Tt(e))throw new sn;
			return!1 === n ? r = !1 : xt(n) && (r = "leading"in n ? n.leading : r, i = "trailing"in n ? n.trailing : i), j.leading = r, j.maxWait = t, j.trailing = i, Gt(e, t, j)
		}, K.times = function (e, t, n) {
			e = -1 < (e = +e) ? e : 0;
			var r = -1, i = Qt(e);
			for (t = tt(t, n, 1); ++r < e;)i[r] = t(r);
			return i
		}, K.toArray = function (e) {
			return e && "number" == typeof e.length ? h(e) : _t(e)
		}, K.transform = function (e, t, n, r) {
			var i = Nn(e);
			if (null == n)if (i)n = []; else {
				var o = e && e.constructor;
				n = et(o && o.prototype)
			}
			return t && (t = K.createCallback(t, r, 4), (i ? Ct : p)(e, function (e, r, i) {
				return t(n, e, r, i)
			})), n
		}, K.union = function () {
			return lt(it(arguments, !0, !0))
		}, K.uniq = Ot, K.values = _t, K.where = Mt, K.without = function (e) {
			return rt(e, h(arguments, 1))
		}, K.wrap = function (e, t) {
			return ct(t, 16, [e])
		}, K.xor = function () {
			for (var e = -1, t = arguments.length; ++e < t;) {
				var n = arguments[e];
				if (Nn(n) || gt(n))var r = r ? lt(rt(r, n).concat(rt(n, r))) : n
			}
			return r || []
		}, K.zip = It, K.zipObject = jt, K.collect = Lt, K.drop = Vt, K.each = Ct, K.eachRight = At, K.extend = X, K.methods = vt, K.object = jt, K.select = Mt, K.tail = Vt, K.unique = Ot, K.unzip = It, qt(K), K.clone = function (e, t, n, r) {
			return"boolean" != typeof t && null != t && (r = n, n = t, t = !1), J(e, t, "function" == typeof n && tt(n, r, 1))
		}, K.cloneDeep = function (e, t, n) {
			return J(e, !0, "function" == typeof t && tt(t, n, 1))
		}, K.contains = wt, K.escape = function (e) {
			return null == e ? "" : an(e).replace(On, ht)
		}, K.every = Ht, K.find = St, K.findIndex = function (e, t, n) {
			var r = -1, i = e ? e.length : 0;
			for (t = K.createCallback(t, n, 3); ++r < i;)if (t(e[r], r, e))return r;
			return-1
		}, K.findKey = function (e, t, n) {
			var r;
			return t = K.createCallback(t, n, 3), p(e, function (e, n, i) {
				return t(e, n, i) ? (r = n, !1) : void 0
			}), r
		}, K.findLast = function (e, t, n) {
			var r;
			return t = K.createCallback(t, n, 3), At(e, function (e, n, i) {
				return t(e, n, i) ? (r = e, !1) : void 0
			}), r
		}, K.findLastIndex = function (e, t, n) {
			var r = e ? e.length : 0;
			for (t = K.createCallback(t, n, 3); r--;)if (t(e[r], r, e))return r;
			return-1
		}, K.findLastKey = function (e, t, n) {
			var r;
			return t = K.createCallback(t, n, 3), Et(e, function (e, n, i) {
				return t(e, n, i) ? (r = n, !1) : void 0
			}), r
		}, K.has = function (e, t) {
			return e ? vn.call(e, t) : !1
		}, K.identity = Xt, K.indexOf = Ut, K.isArguments = gt, K.isArray = Nn, K.isBoolean = function (e) {
			return!0 === e || !1 === e || e && "object" == typeof e && hn.call(e) == F || !1
		}, K.isDate = function (e) {
			return e && "object" == typeof e && hn.call(e) == N || !1
		}, K.isElement = function (e) {
			return e && 1 === e.nodeType || !1
		}, K.isEmpty = function (e) {
			var t = !0;
			if (!e)return t;
			var n = hn.call(e), r = e.length;
			return n == D || n == O || n == P || n == V && "number" == typeof r && Tt(e.splice) ? !r : (p(e, function () {
				return t = !1
			}), t)
		}, K.isEqual = function (e, t, n, r) {
			return ot(e, t, "function" == typeof n && tt(n, r, 2))
		}, K.isFinite = function (e) {
			return Hn(e) && !Mn(parseFloat(e))
		}, K.isFunction = Tt, K.isNaN = function (e) {
			return Rt(e) && e != +e
		}, K.isNull = function (e) {
			return null === e
		}, K.isNumber = Rt, K.isObject = xt, K.isPlainObject = In, K.isRegExp = function (e) {
			return e && "object" == typeof e && hn.call(e) == B || !1
		}, K.isString = bt, K.isUndefined = function (e) {
			return"undefined" == typeof e
		}, K.lastIndexOf = function (e, t, n) {
			var r = e ? e.length : 0;
			for ("number" == typeof n && (r = (0 > n ? Cn(0, r + n) : An(n, r - 1)) + 1); r--;)if (e[r] === t)return r;
			return-1
		}, K.mixin = qt, K.noConflict = function () {
			return n._ = cn, this
		}, K.noop = Yt, K.now = qn, K.parseInt = Yn, K.random = function (e, t, n) {
			var r = null == e, i = null == t;
			return null == n && ("boolean" == typeof e && i ? (n = e, e = 1) : i || "boolean" != typeof t || (n = t, i = !0)), r && i && (t = 1), e = +e || 0, i ? (t = e, e = 0) : t = +t || 0, n || e % 1 || t % 1 ? (n = kn(), An(e + n * (t - e + parseFloat("1e-" + ((n + "").length - 1))), t)) : st(e, t)
		}, K.reduce = Pt, K.reduceRight = Dt, K.result = function (e, t) {
			if (e) {
				var n = e[t];
				return Tt(n) ? e[t]() : n
			}
		}, K.runInContext = f, K.size = function (e) {
			var t = e ? e.length : 0;
			return"number" == typeof t ? t : zn(e).length
		}, K.some = Nt, K.sortedIndex = Bt, K.template = function (e, t, n) {
			var r = K.templateSettings;
			e = an(e || ""), n = y({}, n, r);
			var i, o = y({}, n.imports, r.imports), r = zn(o), o = _t(o), s = 0, l = n.interpolate || C, u = "__p+='", l = on((n.escape || C).source + "|" + l.source + "|" + (l === M ? _ : C).source + "|" + (n.evaluate || C).source + "|$", "g");
			e.replace(l, function (t, n, r, o, l, c) {
				return r || (r = o), u += e.slice(s, c).replace(L, a), n && (u += "'+__e(" + n + ")+'"), l && (i = !0, u += "';" + l + ";\n__p+='"), r && (u += "'+((__t=(" + r + "))==null?'':__t)+'"), s = c + t.length, t
			}), u += "';", l = n = n.variable, l || (n = "obj", u = "with(" + n + "){" + u + "}"), u = (i ? u.replace(x, "") : u).replace(R, "$1").replace(b, "$1;"), u = "function(" + n + "){" + (l ? "" : n + "||(" + n + "={});") + "var __t,__p='',__e=_.escape" + (i ? ",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}" : ";") + u + "return __p}";
			try {
				var c = en(r, "return " + u).apply(d, o)
			} catch (h) {
				throw h.source = u, h
			}
			return t ? c(t) : (c.source = u, c)
		}, K.unescape = function (e) {
			return null == e ? "" : an(e).replace(Bn, mt)
		}, K.uniqueId = function (e) {
			var t = ++g;
			return an(null == e ? "" : e) + t
		}, K.all = Ht, K.any = Nt, K.detect = St, K.findWhere = St, K.foldl = Pt, K.foldr = Dt, K.include = wt, K.inject = Pt, qt(function () {
			var e = {};
			return p(K, function (t, n) {
				K.prototype[n] || (e[n] = t)
			}), e
		}(), !1), K.first = zt, K.last = function (e, t, n) {
			var r = 0, i = e ? e.length : 0;
			if ("number" != typeof t && null != t) {
				var o = i;
				for (t = K.createCallback(t, n, 3); o-- && t(e[o], o, e);)r++
			} else if (r = t, null == r || n)return e ? e[i - 1] : d;
			return h(e, Cn(0, i - r))
		}, K.sample = function (e, t, n) {
			return e && "number" != typeof e.length && (e = _t(e)), null == t || n ? e ? e[st(0, e.length - 1)] : d : (e = Ft(e), e.length = An(Cn(0, t), e.length), e)
		}, K.take = zt, K.head = zt, p(K, function (e, t) {
			var n = "sample" !== t;
			K.prototype[t] || (K.prototype[t] = function (t, r) {
				var i = this.__chain__, o = e(this.__wrapped__, t, r);
				return i || null != t && (!r || n && "function" == typeof t) ? new Z(o, i) : o
			})
		}), K.VERSION = "2.4.1", K.prototype.chain = function () {
			return this.__chain__ = !0, this
		}, K.prototype.toString = function () {
			return an(this.__wrapped__)
		}, K.prototype.value = Zt, K.prototype.valueOf = Zt, Ct(["join", "pop", "shift"], function (e) {
			var t = ln[e];
			K.prototype[e] = function () {
				var e = this.__chain__, n = t.apply(this.__wrapped__, arguments);
				return e ? new Z(n, e) : n
			}
		}), Ct(["push", "reverse", "sort", "unshift"], function (e) {
			var t = ln[e];
			K.prototype[e] = function () {
				return t.apply(this.__wrapped__, arguments), this
			}
		}), Ct(["concat", "slice", "splice"], function (e) {
			var t = ln[e];
			K.prototype[e] = function () {
				return new Z(t.apply(this.__wrapped__, arguments), this.__chain__)
			}
		}), K
	}

	var d, p = [], m = [], g = 0, E = +new Date + "", v = 75, y = 40, T = " 	\f\n\r\u2028\u2029", x = /\b__p\+='';/g, R = /\b(__p\+=)''\+/g, b = /(__e\(.*?\)|\b__t\))\+'';/g, _ = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, w = /\w*$/, H = /^\s*function[ \n\r\t]+\w/, M = /<%=([\s\S]+?)%>/g, S = RegExp("^[" + T + "]*0+(?=.$)"), C = /($^)/, A = /\bthis\b/, L = /['\n\r\t\u2028\u2029\\]/g, k = "Array Boolean Date Function Math Number Object RegExp String _ attachEvent clearTimeout isFinite isNaN parseInt setTimeout".split(" "), P = "[object Arguments]", D = "[object Array]", F = "[object Boolean]", N = "[object Date]", z = "[object Function]", U = "[object Number]", V = "[object Object]", B = "[object RegExp]", O = "[object String]", I = {};
	I[z] = !1, I[P] = I[D] = I[F] = I[N] = I[U] = I[V] = I[B] = I[O] = !0;
	var j = {leading: !1, maxWait: 0, trailing: !1}, W = {configurable: !1, enumerable: !1, value: null, writable: !1}, G = {"boolean": !1, "function": !0, object: !0, number: !1, string: !1, undefined: !1}, X = {"\\": "\\", "'": "'", "\n": "n", "\r": "r", "	": "t", "\u2028": "u2028", "\u2029": "u2029"}, q = G[typeof window] && window || this, Y = G[typeof exports] && exports && !exports.nodeType && exports, K = G[typeof module] && module && !module.nodeType && module, Z = K && K.exports === Y && Y, Q = G[typeof global] && global;
	!Q || Q.global !== Q && Q.window !== Q || (q = Q);
	var $ = f();
	"function" == typeof define && "object" == typeof define.amd && define.amd ? (q._ = $, define(function () {
		return $
	})) : Y && K ? Z ? (K.exports = $)._ = $ : Y._ = $ : q._ = $
}.call(this);
var THREE = {REVISION: "68"};
"object" == typeof module && (module.exports = THREE), THREE.CullFaceNone = 0, THREE.CullFaceBack = 1, THREE.CullFaceFront = 2, THREE.CullFaceFrontBack = 3, THREE.FrontFaceDirectionCW = 0, THREE.FrontFaceDirectionCCW = 1, THREE.BasicShadowMap = 0, THREE.PCFShadowMap = 1, THREE.PCFSoftShadowMap = 2, THREE.FrontSide = 0, THREE.BackSide = 1, THREE.DoubleSide = 2, THREE.NoShading = 0, THREE.FlatShading = 1, THREE.SmoothShading = 2, THREE.NoColors = 0, THREE.FaceColors = 1, THREE.VertexColors = 2, THREE.NoBlending = 0, THREE.NormalBlending = 1, THREE.AdditiveBlending = 2, THREE.SubtractiveBlending = 3, THREE.MultiplyBlending = 4, THREE.CustomBlending = 5, THREE.AddEquation = 100, THREE.SubtractEquation = 101, THREE.ReverseSubtractEquation = 102, THREE.ZeroFactor = 200, THREE.OneFactor = 201, THREE.SrcColorFactor = 202, THREE.OneMinusSrcColorFactor = 203, THREE.SrcAlphaFactor = 204, THREE.OneMinusSrcAlphaFactor = 205, THREE.DstAlphaFactor = 206, THREE.OneMinusDstAlphaFactor = 207, THREE.DstColorFactor = 208, THREE.OneMinusDstColorFactor = 209, THREE.SrcAlphaSaturateFactor = 210, THREE.MultiplyOperation = 0, THREE.MixOperation = 1, THREE.AddOperation = 2, THREE.UVMapping = function () {
}, THREE.CubeReflectionMapping = function () {
}, THREE.CubeRefractionMapping = function () {
}, THREE.SphericalReflectionMapping = function () {
}, THREE.SphericalRefractionMapping = function () {
}, THREE.RepeatWrapping = 1e3, THREE.ClampToEdgeWrapping = 1001, THREE.MirroredRepeatWrapping = 1002, THREE.NearestFilter = 1003, THREE.NearestMipMapNearestFilter = 1004, THREE.NearestMipMapLinearFilter = 1005, THREE.LinearFilter = 1006, THREE.LinearMipMapNearestFilter = 1007, THREE.LinearMipMapLinearFilter = 1008, THREE.UnsignedByteType = 1009, THREE.ByteType = 1010, THREE.ShortType = 1011, THREE.UnsignedShortType = 1012, THREE.IntType = 1013, THREE.UnsignedIntType = 1014, THREE.FloatType = 1015, THREE.UnsignedShort4444Type = 1016, THREE.UnsignedShort5551Type = 1017, THREE.UnsignedShort565Type = 1018, THREE.AlphaFormat = 1019, THREE.RGBFormat = 1020, THREE.RGBAFormat = 1021, THREE.LuminanceFormat = 1022, THREE.LuminanceAlphaFormat = 1023, THREE.RGB_S3TC_DXT1_Format = 2001, THREE.RGBA_S3TC_DXT1_Format = 2002, THREE.RGBA_S3TC_DXT3_Format = 2003, THREE.RGBA_S3TC_DXT5_Format = 2004, THREE.Color = function (e) {
	return 3 === arguments.length ? this.setRGB(arguments[0], arguments[1], arguments[2]) : this.set(e)
}, THREE.Color.prototype = {constructor: THREE.Color, r: 1, g: 1, b: 1, set: function (e) {
	return e instanceof THREE.Color ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
}, setHex: function (e) {
	return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
}, setRGB: function (e, t, n) {
	return this.r = e, this.g = t, this.b = n, this
}, setHSL: function (e, t, n) {
	if (0 === t)this.r = this.g = this.b = n; else {
		var r = function (e, t, n) {
			return 0 > n && (n += 1), n > 1 && (n -= 1), 1 / 6 > n ? e + 6 * (t - e) * n : .5 > n ? t : 2 / 3 > n ? e + 6 * (t - e) * (2 / 3 - n) : e
		};
		t = .5 >= n ? n * (1 + t) : n + t - n * t, n = 2 * n - t, this.r = r(n, t, e + 1 / 3), this.g = r(n, t, e), this.b = r(n, t, e - 1 / 3)
	}
	return this
}, setStyle: function (e) {
	return/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(e) ? (e = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(e), this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, this) : /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(e) ? (e = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(e), this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, this) : /^\#([0-9a-f]{6})$/i.test(e) ? (e = /^\#([0-9a-f]{6})$/i.exec(e), this.setHex(parseInt(e[1], 16)), this) : /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(e) ? (e = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(e), this.setHex(parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3], 16)), this) : /^(\w+)$/i.test(e) ? (this.setHex(THREE.ColorKeywords[e]), this) : void 0
}, copy: function (e) {
	return this.r = e.r, this.g = e.g, this.b = e.b, this
}, copyGammaToLinear: function (e) {
	return this.r = e.r * e.r, this.g = e.g * e.g, this.b = e.b * e.b, this
}, copyLinearToGamma: function (e) {
	return this.r = Math.sqrt(e.r), this.g = Math.sqrt(e.g), this.b = Math.sqrt(e.b), this
}, convertGammaToLinear: function () {
	var e = this.r, t = this.g, n = this.b;
	return this.r = e * e, this.g = t * t, this.b = n * n, this
}, convertLinearToGamma: function () {
	return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
}, getHex: function () {
	return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
}, getHexString: function () {
	return("000000" + this.getHex().toString(16)).slice(-6)
}, getHSL: function (e) {
	e = e || {h: 0, s: 0, l: 0};
	var t, n = this.r, r = this.g, i = this.b, o = Math.max(n, r, i), a = Math.min(n, r, i), s = (a + o) / 2;
	if (a === o)a = t = 0; else {
		var l = o - a, a = .5 >= s ? l / (o + a) : l / (2 - o - a);
		switch (o) {
			case n:
				t = (r - i) / l + (i > r ? 6 : 0);
				break;
			case r:
				t = (i - n) / l + 2;
				break;
			case i:
				t = (n - r) / l + 4
		}
		t /= 6
	}
	return e.h = t, e.s = a, e.l = s, e
}, getStyle: function () {
	return"rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
}, offsetHSL: function (e, t, n) {
	var r = this.getHSL();
	return r.h += e, r.s += t, r.l += n, this.setHSL(r.h, r.s, r.l), this
}, add: function (e) {
	return this.r += e.r, this.g += e.g, this.b += e.b, this
}, addColors: function (e, t) {
	return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
}, addScalar: function (e) {
	return this.r += e, this.g += e, this.b += e, this
}, multiply: function (e) {
	return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
}, multiplyScalar: function (e) {
	return this.r *= e, this.g *= e, this.b *= e, this
}, lerp: function (e, t) {
	return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
}, equals: function (e) {
	return e.r === this.r && e.g === this.g && e.b === this.b
}, fromArray: function (e) {
	return this.r = e[0], this.g = e[1], this.b = e[2], this
}, toArray: function () {
	return[this.r, this.g, this.b]
}, clone: function () {
	return(new THREE.Color).setRGB(this.r, this.g, this.b)
}}, THREE.ColorKeywords = {aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074}, THREE.Quaternion = function (e, t, n, r) {
	this._x = e || 0, this._y = t || 0, this._z = n || 0, this._w = void 0 !== r ? r : 1
}, THREE.Quaternion.prototype = {constructor: THREE.Quaternion, _x: 0, _y: 0, _z: 0, _w: 0, get x() {
	return this._x
}, set x(e) {
	this._x = e, this.onChangeCallback()
}, get y() {
	return this._y
}, set y(e) {
	this._y = e, this.onChangeCallback()
}, get z() {
	return this._z
}, set z(e) {
	this._z = e, this.onChangeCallback()
}, get w() {
	return this._w
}, set w(e) {
	this._w = e, this.onChangeCallback()
}, set: function (e, t, n, r) {
	return this._x = e, this._y = t, this._z = n, this._w = r, this.onChangeCallback(), this
}, copy: function (e) {
	return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this.onChangeCallback(), this
}, setFromEuler: function (e, t) {
	if (!1 == e instanceof THREE.Euler)throw Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
	var n = Math.cos(e._x / 2), r = Math.cos(e._y / 2), i = Math.cos(e._z / 2), o = Math.sin(e._x / 2), a = Math.sin(e._y / 2), s = Math.sin(e._z / 2);
	return"XYZ" === e.order ? (this._x = o * r * i + n * a * s, this._y = n * a * i - o * r * s, this._z = n * r * s + o * a * i, this._w = n * r * i - o * a * s) : "YXZ" === e.order ? (this._x = o * r * i + n * a * s, this._y = n * a * i - o * r * s, this._z = n * r * s - o * a * i, this._w = n * r * i + o * a * s) : "ZXY" === e.order ? (this._x = o * r * i - n * a * s, this._y = n * a * i + o * r * s, this._z = n * r * s + o * a * i, this._w = n * r * i - o * a * s) : "ZYX" === e.order ? (this._x = o * r * i - n * a * s, this._y = n * a * i + o * r * s, this._z = n * r * s - o * a * i, this._w = n * r * i + o * a * s) : "YZX" === e.order ? (this._x = o * r * i + n * a * s, this._y = n * a * i + o * r * s, this._z = n * r * s - o * a * i, this._w = n * r * i - o * a * s) : "XZY" === e.order && (this._x = o * r * i - n * a * s, this._y = n * a * i - o * r * s, this._z = n * r * s + o * a * i, this._w = n * r * i + o * a * s), !1 !== t && this.onChangeCallback(), this
}, setFromAxisAngle: function (e, t) {
	var n = t / 2, r = Math.sin(n);
	return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this.onChangeCallback(), this
}, setFromRotationMatrix: function (e) {
	var t = e.elements, n = t[0];
	e = t[4];
	var r = t[8], i = t[1], o = t[5], a = t[9], s = t[2], l = t[6], t = t[10], u = n + o + t;
	return u > 0 ? (n = .5 / Math.sqrt(u + 1), this._w = .25 / n, this._x = (l - a) * n, this._y = (r - s) * n, this._z = (i - e) * n) : n > o && n > t ? (n = 2 * Math.sqrt(1 + n - o - t), this._w = (l - a) / n, this._x = .25 * n, this._y = (e + i) / n, this._z = (r + s) / n) : o > t ? (n = 2 * Math.sqrt(1 + o - n - t), this._w = (r - s) / n, this._x = (e + i) / n, this._y = .25 * n, this._z = (a + l) / n) : (n = 2 * Math.sqrt(1 + t - n - o), this._w = (i - e) / n, this._x = (r + s) / n, this._y = (a + l) / n, this._z = .25 * n), this.onChangeCallback(), this
}, setFromUnitVectors: function () {
	var e, t;
	return function (n, r) {
		return void 0 === e && (e = new THREE.Vector3), t = n.dot(r) + 1, 1e-6 > t ? (t = 0, Math.abs(n.x) > Math.abs(n.z) ? e.set(-n.y, n.x, 0) : e.set(0, -n.z, n.y)) : e.crossVectors(n, r), this._x = e.x, this._y = e.y, this._z = e.z, this._w = t, this.normalize(), this
	}
}(), inverse: function () {
	return this.conjugate().normalize(), this
}, conjugate: function () {
	return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
}, dot: function (e) {
	return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
}, lengthSq: function () {
	return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
}, length: function () {
	return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
}, normalize: function () {
	var e = this.length();
	return 0 === e ? (this._z = this._y = this._x = 0, this._w = 1) : (e = 1 / e, this._x *= e, this._y *= e, this._z *= e, this._w *= e), this.onChangeCallback(), this
}, multiply: function (e, t) {
	return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
}, multiplyQuaternions: function (e, t) {
	var n = e._x, r = e._y, i = e._z, o = e._w, a = t._x, s = t._y, l = t._z, u = t._w;
	return this._x = n * u + o * a + r * l - i * s, this._y = r * u + o * s + i * a - n * l, this._z = i * u + o * l + n * s - r * a, this._w = o * u - n * a - r * s - i * l, this.onChangeCallback(), this
}, multiplyVector3: function (e) {
	return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
}, slerp: function (e, t) {
	var n = this._x, r = this._y, i = this._z, o = this._w, a = o * e._w + n * e._x + r * e._y + i * e._z;
	if (0 > a ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1)return this._w = o, this._x = n, this._y = r, this._z = i, this;
	var s = Math.acos(a), l = Math.sqrt(1 - a * a);
	return.001 > Math.abs(l) ? (this._w = .5 * (o + this._w), this._x = .5 * (n + this._x), this._y = .5 * (r + this._y), this._z = .5 * (i + this._z), this) : (a = Math.sin((1 - t) * s) / l, s = Math.sin(t * s) / l, this._w = o * a + this._w * s, this._x = n * a + this._x * s, this._y = r * a + this._y * s, this._z = i * a + this._z * s, this.onChangeCallback(), this)
}, equals: function (e) {
	return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
}, fromArray: function (e) {
	return this._x = e[0], this._y = e[1], this._z = e[2], this._w = e[3], this.onChangeCallback(), this
}, toArray: function () {
	return[this._x, this._y, this._z, this._w]
}, onChange: function (e) {
	return this.onChangeCallback = e, this
}, onChangeCallback: function () {
}, clone: function () {
	return new THREE.Quaternion(this._x, this._y, this._z, this._w)
}}, THREE.Quaternion.slerp = function (e, t, n, r) {
	return n.copy(e).slerp(t, r)
}, THREE.Vector2 = function (e, t) {
	this.x = e || 0, this.y = t || 0
}, THREE.Vector2.prototype = {constructor: THREE.Vector2, set: function (e, t) {
	return this.x = e, this.y = t, this
}, setX: function (e) {
	return this.x = e, this
}, setY: function (e) {
	return this.y = e, this
}, setComponent: function (e, t) {
	switch (e) {
		case 0:
			this.x = t;
			break;
		case 1:
			this.y = t;
			break;
		default:
			throw Error("index is out of range: " + e)
	}
}, getComponent: function (e) {
	switch (e) {
		case 0:
			return this.x;
		case 1:
			return this.y;
		default:
			throw Error("index is out of range: " + e)
	}
}, copy: function (e) {
	return this.x = e.x, this.y = e.y, this
}, add: function (e, t) {
	return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
}, addVectors: function (e, t) {
	return this.x = e.x + t.x, this.y = e.y + t.y, this
}, addScalar: function (e) {
	return this.x += e, this.y += e, this
}, sub: function (e, t) {
	return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
}, subVectors: function (e, t) {
	return this.x = e.x - t.x, this.y = e.y - t.y, this
}, multiply: function (e) {
	return this.x *= e.x, this.y *= e.y, this
}, multiplyScalar: function (e) {
	return this.x *= e, this.y *= e, this
}, divide: function (e) {
	return this.x /= e.x, this.y /= e.y, this
}, divideScalar: function (e) {
	return 0 !== e ? (e = 1 / e, this.x *= e, this.y *= e) : this.y = this.x = 0, this
}, min: function (e) {
	return this.x > e.x && (this.x = e.x), this.y > e.y && (this.y = e.y), this
}, max: function (e) {
	return this.x < e.x && (this.x = e.x), this.y < e.y && (this.y = e.y), this
}, clamp: function (e, t) {
	return this.x < e.x ? this.x = e.x : this.x > t.x && (this.x = t.x), this.y < e.y ? this.y = e.y : this.y > t.y && (this.y = t.y), this
}, clampScalar: function () {
	var e, t;
	return function (n, r) {
		return void 0 === e && (e = new THREE.Vector2, t = new THREE.Vector2), e.set(n, n), t.set(r, r), this.clamp(e, t)
	}
}(), floor: function () {
	return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
}, ceil: function () {
	return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
}, round: function () {
	return this.x = Math.round(this.x), this.y = Math.round(this.y), this
}, roundToZero: function () {
	return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this
}, negate: function () {
	return this.x = -this.x, this.y = -this.y, this
}, dot: function (e) {
	return this.x * e.x + this.y * e.y
}, lengthSq: function () {
	return this.x * this.x + this.y * this.y
}, length: function () {
	return Math.sqrt(this.x * this.x + this.y * this.y)
}, normalize: function () {
	return this.divideScalar(this.length())
}, distanceTo: function (e) {
	return Math.sqrt(this.distanceToSquared(e))
}, distanceToSquared: function (e) {
	var t = this.x - e.x;
	return e = this.y - e.y, t * t + e * e
}, setLength: function (e) {
	var t = this.length();
	return 0 !== t && e !== t && this.multiplyScalar(e / t), this
}, lerp: function (e, t) {
	return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
}, equals: function (e) {
	return e.x === this.x && e.y === this.y
}, fromArray: function (e) {
	return this.x = e[0], this.y = e[1], this
}, toArray: function () {
	return[this.x, this.y]
}, clone: function () {
	return new THREE.Vector2(this.x, this.y)
}}, THREE.Vector3 = function (e, t, n) {
	this.x = e || 0, this.y = t || 0, this.z = n || 0
}, THREE.Vector3.prototype = {constructor: THREE.Vector3, set: function (e, t, n) {
	return this.x = e, this.y = t, this.z = n, this
}, setX: function (e) {
	return this.x = e, this
}, setY: function (e) {
	return this.y = e, this
}, setZ: function (e) {
	return this.z = e, this
}, setComponent: function (e, t) {
	switch (e) {
		case 0:
			this.x = t;
			break;
		case 1:
			this.y = t;
			break;
		case 2:
			this.z = t;
			break;
		default:
			throw Error("index is out of range: " + e)
	}
}, getComponent: function (e) {
	switch (e) {
		case 0:
			return this.x;
		case 1:
			return this.y;
		case 2:
			return this.z;
		default:
			throw Error("index is out of range: " + e)
	}
}, copy: function (e) {
	return this.x = e.x, this.y = e.y, this.z = e.z, this
}, add: function (e, t) {
	return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
}, addScalar: function (e) {
	return this.x += e, this.y += e, this.z += e, this
}, addVectors: function (e, t) {
	return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
}, sub: function (e, t) {
	return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
}, subVectors: function (e, t) {
	return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
}, multiply: function (e, t) {
	return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
}, multiplyScalar: function (e) {
	return this.x *= e, this.y *= e, this.z *= e, this
}, multiplyVectors: function (e, t) {
	return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
}, applyEuler: function () {
	var e;
	return function (t) {
		return!1 == t instanceof THREE.Euler && console.error("THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order."), void 0 === e && (e = new THREE.Quaternion), this.applyQuaternion(e.setFromEuler(t)), this
	}
}(), applyAxisAngle: function () {
	var e;
	return function (t, n) {
		return void 0 === e && (e = new THREE.Quaternion), this.applyQuaternion(e.setFromAxisAngle(t, n)), this
	}
}(), applyMatrix3: function (e) {
	var t = this.x, n = this.y, r = this.z;
	return e = e.elements, this.x = e[0] * t + e[3] * n + e[6] * r, this.y = e[1] * t + e[4] * n + e[7] * r, this.z = e[2] * t + e[5] * n + e[8] * r, this
}, applyMatrix4: function (e) {
	var t = this.x, n = this.y, r = this.z;
	return e = e.elements, this.x = e[0] * t + e[4] * n + e[8] * r + e[12], this.y = e[1] * t + e[5] * n + e[9] * r + e[13], this.z = e[2] * t + e[6] * n + e[10] * r + e[14], this
}, applyProjection: function (e) {
	var t = this.x, n = this.y, r = this.z;
	e = e.elements;
	var i = 1 / (e[3] * t + e[7] * n + e[11] * r + e[15]);
	return this.x = (e[0] * t + e[4] * n + e[8] * r + e[12]) * i, this.y = (e[1] * t + e[5] * n + e[9] * r + e[13]) * i, this.z = (e[2] * t + e[6] * n + e[10] * r + e[14]) * i, this
}, applyQuaternion: function (e) {
	var t = this.x, n = this.y, r = this.z, i = e.x, o = e.y, a = e.z;
	e = e.w;
	var s = e * t + o * r - a * n, l = e * n + a * t - i * r, u = e * r + i * n - o * t, t = -i * t - o * n - a * r;
	return this.x = s * e + t * -i + l * -a - u * -o, this.y = l * e + t * -o + u * -i - s * -a, this.z = u * e + t * -a + s * -o - l * -i, this
}, transformDirection: function (e) {
	var t = this.x, n = this.y, r = this.z;
	return e = e.elements, this.x = e[0] * t + e[4] * n + e[8] * r, this.y = e[1] * t + e[5] * n + e[9] * r, this.z = e[2] * t + e[6] * n + e[10] * r, this.normalize(), this
}, divide: function (e) {
	return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
}, divideScalar: function (e) {
	return 0 !== e ? (e = 1 / e, this.x *= e, this.y *= e, this.z *= e) : this.z = this.y = this.x = 0, this
}, min: function (e) {
	return this.x > e.x && (this.x = e.x), this.y > e.y && (this.y = e.y), this.z > e.z && (this.z = e.z), this
}, max: function (e) {
	return this.x < e.x && (this.x = e.x), this.y < e.y && (this.y = e.y), this.z < e.z && (this.z = e.z), this
}, clamp: function (e, t) {
	return this.x < e.x ? this.x = e.x : this.x > t.x && (this.x = t.x), this.y < e.y ? this.y = e.y : this.y > t.y && (this.y = t.y), this.z < e.z ? this.z = e.z : this.z > t.z && (this.z = t.z), this
}, clampScalar: function () {
	var e, t;
	return function (n, r) {
		return void 0 === e && (e = new THREE.Vector3, t = new THREE.Vector3), e.set(n, n, n), t.set(r, r, r), this.clamp(e, t)
	}
}(), floor: function () {
	return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
}, ceil: function () {
	return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
}, round: function () {
	return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
}, roundToZero: function () {
	return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this
}, negate: function () {
	return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
}, dot: function (e) {
	return this.x * e.x + this.y * e.y + this.z * e.z
}, lengthSq: function () {
	return this.x * this.x + this.y * this.y + this.z * this.z
}, length: function () {
	return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
}, lengthManhattan: function () {
	return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
}, normalize: function () {
	return this.divideScalar(this.length())
}, setLength: function (e) {
	var t = this.length();
	return 0 !== t && e !== t && this.multiplyScalar(e / t), this
}, lerp: function (e, t) {
	return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
}, cross: function (e, t) {
	if (void 0 !== t)return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t);
	var n = this.x, r = this.y, i = this.z;
	return this.x = r * e.z - i * e.y, this.y = i * e.x - n * e.z, this.z = n * e.y - r * e.x, this
}, crossVectors: function (e, t) {
	var n = e.x, r = e.y, i = e.z, o = t.x, a = t.y, s = t.z;
	return this.x = r * s - i * a, this.y = i * o - n * s, this.z = n * a - r * o, this
}, projectOnVector: function () {
	var e, t;
	return function (n) {
		return void 0 === e && (e = new THREE.Vector3), e.copy(n).normalize(), t = this.dot(e), this.copy(e).multiplyScalar(t)
	}
}(), projectOnPlane: function () {
	var e;
	return function (t) {
		return void 0 === e && (e = new THREE.Vector3), e.copy(this).projectOnVector(t), this.sub(e)
	}
}(), reflect: function () {
	var e;
	return function (t) {
		return void 0 === e && (e = new THREE.Vector3), this.sub(e.copy(t).multiplyScalar(2 * this.dot(t)))
	}
}(), angleTo: function (e) {
	return e = this.dot(e) / (this.length() * e.length()), Math.acos(THREE.Math.clamp(e, -1, 1))
}, distanceTo: function (e) {
	return Math.sqrt(this.distanceToSquared(e))
}, distanceToSquared: function (e) {
	var t = this.x - e.x, n = this.y - e.y;
	return e = this.z - e.z, t * t + n * n + e * e
}, setEulerFromRotationMatrix: function () {
	console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
}, setEulerFromQuaternion: function () {
	console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
}, getPositionFromMatrix: function (e) {
	return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
}, getScaleFromMatrix: function (e) {
	return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
}, getColumnFromMatrix: function (e, t) {
	return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
}, setFromMatrixPosition: function (e) {
	return this.x = e.elements[12], this.y = e.elements[13], this.z = e.elements[14], this
}, setFromMatrixScale: function (e) {
	var t = this.set(e.elements[0], e.elements[1], e.elements[2]).length(), n = this.set(e.elements[4], e.elements[5], e.elements[6]).length();
	return e = this.set(e.elements[8], e.elements[9], e.elements[10]).length(), this.x = t, this.y = n, this.z = e, this
}, setFromMatrixColumn: function (e, t) {
	var n = 4 * e, r = t.elements;
	return this.x = r[n], this.y = r[n + 1], this.z = r[n + 2], this
}, equals: function (e) {
	return e.x === this.x && e.y === this.y && e.z === this.z
}, fromArray: function (e) {
	return this.x = e[0], this.y = e[1], this.z = e[2], this
}, toArray: function () {
	return[this.x, this.y, this.z]
}, clone: function () {
	return new THREE.Vector3(this.x, this.y, this.z)
}}, THREE.Vector4 = function (e, t, n, r) {
	this.x = e || 0, this.y = t || 0, this.z = n || 0, this.w = void 0 !== r ? r : 1
}, THREE.Vector4.prototype = {constructor: THREE.Vector4, set: function (e, t, n, r) {
	return this.x = e, this.y = t, this.z = n, this.w = r, this
}, setX: function (e) {
	return this.x = e, this
}, setY: function (e) {
	return this.y = e, this
}, setZ: function (e) {
	return this.z = e, this
}, setW: function (e) {
	return this.w = e, this
}, setComponent: function (e, t) {
	switch (e) {
		case 0:
			this.x = t;
			break;
		case 1:
			this.y = t;
			break;
		case 2:
			this.z = t;
			break;
		case 3:
			this.w = t;
			break;
		default:
			throw Error("index is out of range: " + e)
	}
}, getComponent: function (e) {
	switch (e) {
		case 0:
			return this.x;
		case 1:
			return this.y;
		case 2:
			return this.z;
		case 3:
			return this.w;
		default:
			throw Error("index is out of range: " + e)
	}
}, copy: function (e) {
	return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
}, add: function (e, t) {
	return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
}, addScalar: function (e) {
	return this.x += e, this.y += e, this.z += e, this.w += e, this
}, addVectors: function (e, t) {
	return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
}, sub: function (e, t) {
	return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
}, subVectors: function (e, t) {
	return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
}, multiplyScalar: function (e) {
	return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
}, applyMatrix4: function (e) {
	var t = this.x, n = this.y, r = this.z, i = this.w;
	return e = e.elements, this.x = e[0] * t + e[4] * n + e[8] * r + e[12] * i, this.y = e[1] * t + e[5] * n + e[9] * r + e[13] * i, this.z = e[2] * t + e[6] * n + e[10] * r + e[14] * i, this.w = e[3] * t + e[7] * n + e[11] * r + e[15] * i, this
}, divideScalar: function (e) {
	return 0 !== e ? (e = 1 / e, this.x *= e, this.y *= e, this.z *= e, this.w *= e) : (this.z = this.y = this.x = 0, this.w = 1), this
}, setAxisAngleFromQuaternion: function (e) {
	this.w = 2 * Math.acos(e.w);
	var t = Math.sqrt(1 - e.w * e.w);
	return 1e-4 > t ? (this.x = 1, this.z = this.y = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
}, setAxisAngleFromRotationMatrix: function (e) {
	var t, n, r;
	e = e.elements;
	var i = e[0];
	r = e[4];
	var o = e[8], a = e[1], s = e[5], l = e[9];
	n = e[2], t = e[6];
	var u = e[10];
	return.01 > Math.abs(r - a) && .01 > Math.abs(o - n) && .01 > Math.abs(l - t) ? .1 > Math.abs(r + a) && .1 > Math.abs(o + n) && .1 > Math.abs(l + t) && .1 > Math.abs(i + s + u - 3) ? (this.set(1, 0, 0, 0), this) : (e = Math.PI, i = (i + 1) / 2, s = (s + 1) / 2, u = (u + 1) / 2, r = (r + a) / 4, o = (o + n) / 4, l = (l + t) / 4, i > s && i > u ? .01 > i ? (t = 0, r = n = .707106781) : (t = Math.sqrt(i), n = r / t, r = o / t) : s > u ? .01 > s ? (t = .707106781, n = 0, r = .707106781) : (n = Math.sqrt(s), t = r / n, r = l / n) : .01 > u ? (n = t = .707106781, r = 0) : (r = Math.sqrt(u), t = o / r, n = l / r), this.set(t, n, r, e), this) : (e = Math.sqrt((t - l) * (t - l) + (o - n) * (o - n) + (a - r) * (a - r)), .001 > Math.abs(e) && (e = 1), this.x = (t - l) / e, this.y = (o - n) / e, this.z = (a - r) / e, this.w = Math.acos((i + s + u - 1) / 2), this)
}, min: function (e) {
	return this.x > e.x && (this.x = e.x), this.y > e.y && (this.y = e.y), this.z > e.z && (this.z = e.z), this.w > e.w && (this.w = e.w), this
}, max: function (e) {
	return this.x < e.x && (this.x = e.x), this.y < e.y && (this.y = e.y), this.z < e.z && (this.z = e.z), this.w < e.w && (this.w = e.w), this
}, clamp: function (e, t) {
	return this.x < e.x ? this.x = e.x : this.x > t.x && (this.x = t.x), this.y < e.y ? this.y = e.y : this.y > t.y && (this.y = t.y), this.z < e.z ? this.z = e.z : this.z > t.z && (this.z = t.z), this.w < e.w ? this.w = e.w : this.w > t.w && (this.w = t.w), this
}, clampScalar: function () {
	var e, t;
	return function (n, r) {
		return void 0 === e && (e = new THREE.Vector4, t = new THREE.Vector4), e.set(n, n, n, n), t.set(r, r, r, r), this.clamp(e, t)
	}
}(), floor: function () {
	return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
}, ceil: function () {
	return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
}, round: function () {
	return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
}, roundToZero: function () {
	return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), this
}, negate: function () {
	return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
}, dot: function (e) {
	return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
}, lengthSq: function () {
	return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
}, length: function () {
	return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
}, lengthManhattan: function () {
	return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
}, normalize: function () {
	return this.divideScalar(this.length())
}, setLength: function (e) {
	var t = this.length();
	return 0 !== t && e !== t && this.multiplyScalar(e / t), this
}, lerp: function (e, t) {
	return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
}, equals: function (e) {
	return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
}, fromArray: function (e) {
	return this.x = e[0], this.y = e[1], this.z = e[2], this.w = e[3], this
}, toArray: function () {
	return[this.x, this.y, this.z, this.w]
}, clone: function () {
	return new THREE.Vector4(this.x, this.y, this.z, this.w)
}}, THREE.Euler = function (e, t, n, r) {
	this._x = e || 0, this._y = t || 0, this._z = n || 0, this._order = r || THREE.Euler.DefaultOrder
}, THREE.Euler.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), THREE.Euler.DefaultOrder = "XYZ", THREE.Euler.prototype = {constructor: THREE.Euler, _x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder, get x() {
	return this._x
}, set x(e) {
	this._x = e, this.onChangeCallback()
}, get y() {
	return this._y
}, set y(e) {
	this._y = e, this.onChangeCallback()
}, get z() {
	return this._z
}, set z(e) {
	this._z = e, this.onChangeCallback()
}, get order() {
	return this._order
}, set order(e) {
	this._order = e, this.onChangeCallback()
}, set: function (e, t, n, r) {
	return this._x = e, this._y = t, this._z = n, this._order = r || this._order, this.onChangeCallback(), this
}, copy: function (e) {
	return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this.onChangeCallback(), this
}, setFromRotationMatrix: function (e, t) {
	var n = THREE.Math.clamp, r = e.elements, i = r[0], o = r[4], a = r[8], s = r[1], l = r[5], u = r[9], c = r[2], h = r[6], r = r[10];
	return t = t || this._order, "XYZ" === t ? (this._y = Math.asin(n(a, -1, 1)), .99999 > Math.abs(a) ? (this._x = Math.atan2(-u, r), this._z = Math.atan2(-o, i)) : (this._x = Math.atan2(h, l), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-n(u, -1, 1)), .99999 > Math.abs(u) ? (this._y = Math.atan2(a, r), this._z = Math.atan2(s, l)) : (this._y = Math.atan2(-c, i), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(n(h, -1, 1)), .99999 > Math.abs(h) ? (this._y = Math.atan2(-c, r), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(s, i))) : "ZYX" === t ? (this._y = Math.asin(-n(c, -1, 1)), .99999 > Math.abs(c) ? (this._x = Math.atan2(h, r), this._z = Math.atan2(s, i)) : (this._x = 0, this._z = Math.atan2(-o, l))) : "YZX" === t ? (this._z = Math.asin(n(s, -1, 1)), .99999 > Math.abs(s) ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-c, i)) : (this._x = 0, this._y = Math.atan2(a, r))) : "XZY" === t ? (this._z = Math.asin(-n(o, -1, 1)), .99999 > Math.abs(o) ? (this._x = Math.atan2(h, l), this._y = Math.atan2(a, i)) : (this._x = Math.atan2(-u, r), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, this.onChangeCallback(), this
}, setFromQuaternion: function (e, t, n) {
	var r = THREE.Math.clamp, i = e.x * e.x, o = e.y * e.y, a = e.z * e.z, s = e.w * e.w;
	return t = t || this._order, "XYZ" === t ? (this._x = Math.atan2(2 * (e.x * e.w - e.y * e.z), s - i - o + a), this._y = Math.asin(r(2 * (e.x * e.z + e.y * e.w), -1, 1)), this._z = Math.atan2(2 * (e.z * e.w - e.x * e.y), s + i - o - a)) : "YXZ" === t ? (this._x = Math.asin(r(2 * (e.x * e.w - e.y * e.z), -1, 1)), this._y = Math.atan2(2 * (e.x * e.z + e.y * e.w), s - i - o + a), this._z = Math.atan2(2 * (e.x * e.y + e.z * e.w), s - i + o - a)) : "ZXY" === t ? (this._x = Math.asin(r(2 * (e.x * e.w + e.y * e.z), -1, 1)), this._y = Math.atan2(2 * (e.y * e.w - e.z * e.x), s - i - o + a), this._z = Math.atan2(2 * (e.z * e.w - e.x * e.y), s - i + o - a)) : "ZYX" === t ? (this._x = Math.atan2(2 * (e.x * e.w + e.z * e.y), s - i - o + a), this._y = Math.asin(r(2 * (e.y * e.w - e.x * e.z), -1, 1)), this._z = Math.atan2(2 * (e.x * e.y + e.z * e.w), s + i - o - a)) : "YZX" === t ? (this._x = Math.atan2(2 * (e.x * e.w - e.z * e.y), s - i + o - a), this._y = Math.atan2(2 * (e.y * e.w - e.x * e.z), s + i - o - a), this._z = Math.asin(r(2 * (e.x * e.y + e.z * e.w), -1, 1))) : "XZY" === t ? (this._x = Math.atan2(2 * (e.x * e.w + e.y * e.z), s - i + o - a), this._y = Math.atan2(2 * (e.x * e.z + e.y * e.w), s + i - o - a), this._z = Math.asin(r(2 * (e.z * e.w - e.x * e.y), -1, 1))) : console.warn("THREE.Euler: .setFromQuaternion() given unsupported order: " + t), this._order = t, !1 !== n && this.onChangeCallback(), this
}, reorder: function () {
	var e = new THREE.Quaternion;
	return function (t) {
		e.setFromEuler(this), this.setFromQuaternion(e, t)
	}
}(), equals: function (e) {
	return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
}, fromArray: function (e) {
	return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this.onChangeCallback(), this
}, toArray: function () {
	return[this._x, this._y, this._z, this._order]
}, onChange: function (e) {
	return this.onChangeCallback = e, this
}, onChangeCallback: function () {
}, clone: function () {
	return new THREE.Euler(this._x, this._y, this._z, this._order)
}}, THREE.Line3 = function (e, t) {
	this.start = void 0 !== e ? e : new THREE.Vector3, this.end = void 0 !== t ? t : new THREE.Vector3
}, THREE.Line3.prototype = {constructor: THREE.Line3, set: function (e, t) {
	return this.start.copy(e), this.end.copy(t), this
}, copy: function (e) {
	return this.start.copy(e.start), this.end.copy(e.end), this
}, center: function (e) {
	return(e || new THREE.Vector3).addVectors(this.start, this.end).multiplyScalar(.5)
}, delta: function (e) {
	return(e || new THREE.Vector3).subVectors(this.end, this.start)
}, distanceSq: function () {
	return this.start.distanceToSquared(this.end)
}, distance: function () {
	return this.start.distanceTo(this.end)
}, at: function (e, t) {
	var n = t || new THREE.Vector3;
	return this.delta(n).multiplyScalar(e).add(this.start)
}, closestPointToPointParameter: function () {
	var e = new THREE.Vector3, t = new THREE.Vector3;
	return function (n, r) {
		e.subVectors(n, this.start), t.subVectors(this.end, this.start);
		var i = t.dot(t), i = t.dot(e) / i;
		return r && (i = THREE.Math.clamp(i, 0, 1)), i
	}
}(), closestPointToPoint: function (e, t, n) {
	return e = this.closestPointToPointParameter(e, t), n = n || new THREE.Vector3, this.delta(n).multiplyScalar(e).add(this.start)
}, applyMatrix4: function (e) {
	return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
}, equals: function (e) {
	return e.start.equals(this.start) && e.end.equals(this.end)
}, clone: function () {
	return(new THREE.Line3).copy(this)
}}, THREE.Box2 = function (e, t) {
	this.min = void 0 !== e ? e : new THREE.Vector2(1 / 0, 1 / 0), this.max = void 0 !== t ? t : new THREE.Vector2(-1 / 0, -1 / 0)
}, THREE.Box2.prototype = {constructor: THREE.Box2, set: function (e, t) {
	return this.min.copy(e), this.max.copy(t), this
}, setFromPoints: function (e) {
	this.makeEmpty();
	for (var t = 0, n = e.length; n > t; t++)this.expandByPoint(e[t]);
	return this
}, setFromCenterAndSize: function () {
	var e = new THREE.Vector2;
	return function (t, n) {
		var r = e.copy(n).multiplyScalar(.5);
		return this.min.copy(t).sub(r), this.max.copy(t).add(r), this
	}
}(), copy: function (e) {
	return this.min.copy(e.min), this.max.copy(e.max), this
}, makeEmpty: function () {
	return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
}, empty: function () {
	return this.max.x < this.min.x || this.max.y < this.min.y
}, center: function (e) {
	return(e || new THREE.Vector2).addVectors(this.min, this.max).multiplyScalar(.5)
}, size: function (e) {
	return(e || new THREE.Vector2).subVectors(this.max, this.min)
}, expandByPoint: function (e) {
	return this.min.min(e), this.max.max(e), this
}, expandByVector: function (e) {
	return this.min.sub(e), this.max.add(e), this
}, expandByScalar: function (e) {
	return this.min.addScalar(-e), this.max.addScalar(e), this
}, containsPoint: function (e) {
	return e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y ? !1 : !0
}, containsBox: function (e) {
	return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y ? !0 : !1
}, getParameter: function (e, t) {
	return(t || new THREE.Vector2).set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
}, isIntersectionBox: function (e) {
	return e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y ? !1 : !0
}, clampPoint: function (e, t) {
	return(t || new THREE.Vector2).copy(e).clamp(this.min, this.max)
}, distanceToPoint: function () {
	var e = new THREE.Vector2;
	return function (t) {
		return e.copy(t).clamp(this.min, this.max).sub(t).length()
	}
}(), intersect: function (e) {
	return this.min.max(e.min), this.max.min(e.max), this
}, union: function (e) {
	return this.min.min(e.min), this.max.max(e.max), this
}, translate: function (e) {
	return this.min.add(e), this.max.add(e), this
}, equals: function (e) {
	return e.min.equals(this.min) && e.max.equals(this.max)
}, clone: function () {
	return(new THREE.Box2).copy(this)
}}, THREE.Box3 = function (e, t) {
	this.min = void 0 !== e ? e : new THREE.Vector3(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t ? t : new THREE.Vector3(-1 / 0, -1 / 0, -1 / 0)
}, THREE.Box3.prototype = {constructor: THREE.Box3, set: function (e, t) {
	return this.min.copy(e), this.max.copy(t), this
}, setFromPoints: function (e) {
	this.makeEmpty();
	for (var t = 0, n = e.length; n > t; t++)this.expandByPoint(e[t]);
	return this
}, setFromCenterAndSize: function () {
	var e = new THREE.Vector3;
	return function (t, n) {
		var r = e.copy(n).multiplyScalar(.5);
		return this.min.copy(t).sub(r), this.max.copy(t).add(r), this
	}
}(), setFromObject: function () {
	var e = new THREE.Vector3;
	return function (t) {
		var n = this;
		return t.updateMatrixWorld(!0), this.makeEmpty(), t.traverse(function (t) {
			if (void 0 !== t.geometry && void 0 !== t.geometry.vertices)for (var r = t.geometry.vertices, i = 0, o = r.length; o > i; i++)e.copy(r[i]), e.applyMatrix4(t.matrixWorld), n.expandByPoint(e)
		}), this
	}
}(), copy: function (e) {
	return this.min.copy(e.min), this.max.copy(e.max), this
}, makeEmpty: function () {
	return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
}, empty: function () {
	return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
}, center: function (e) {
	return(e || new THREE.Vector3).addVectors(this.min, this.max).multiplyScalar(.5)
}, size: function (e) {
	return(e || new THREE.Vector3).subVectors(this.max, this.min)
}, expandByPoint: function (e) {
	return this.min.min(e), this.max.max(e), this
}, expandByVector: function (e) {
	return this.min.sub(e), this.max.add(e), this
}, expandByScalar: function (e) {
	return this.min.addScalar(-e), this.max.addScalar(e), this
}, containsPoint: function (e) {
	return e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z ? !1 : !0
}, containsBox: function (e) {
	return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z ? !0 : !1
}, getParameter: function (e, t) {
	return(t || new THREE.Vector3).set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
}, isIntersectionBox: function (e) {
	return e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z ? !1 : !0
}, clampPoint: function (e, t) {
	return(t || new THREE.Vector3).copy(e).clamp(this.min, this.max)
}, distanceToPoint: function () {
	var e = new THREE.Vector3;
	return function (t) {
		return e.copy(t).clamp(this.min, this.max).sub(t).length()
	}
}(), getBoundingSphere: function () {
	var e = new THREE.Vector3;
	return function (t) {
		return t = t || new THREE.Sphere, t.center = this.center(), t.radius = .5 * this.size(e).length(), t
	}
}(), intersect: function (e) {
	return this.min.max(e.min), this.max.min(e.max), this
}, union: function (e) {
	return this.min.min(e.min), this.max.max(e.max), this
}, applyMatrix4: function () {
	var e = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3];
	return function (t) {
		return e[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), e[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), e[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), e[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), e[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), e[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), e[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), e[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.makeEmpty(), this.setFromPoints(e), this
	}
}(), translate: function (e) {
	return this.min.add(e), this.max.add(e), this
}, equals: function (e) {
	return e.min.equals(this.min) && e.max.equals(this.max)
}, clone: function () {
	return(new THREE.Box3).copy(this)
}}, THREE.Matrix3 = function (e, t, n, r, i, o, a, s, l) {
	var u = this.elements = new Float32Array(9);
	u[0] = void 0 !== e ? e : 1, u[3] = t || 0, u[6] = n || 0, u[1] = r || 0, u[4] = void 0 !== i ? i : 1, u[7] = o || 0, u[2] = a || 0, u[5] = s || 0, u[8] = void 0 !== l ? l : 1
}, THREE.Matrix3.prototype = {constructor: THREE.Matrix3, set: function (e, t, n, r, i, o, a, s, l) {
	var u = this.elements;
	return u[0] = e, u[3] = t, u[6] = n, u[1] = r, u[4] = i, u[7] = o, u[2] = a, u[5] = s, u[8] = l, this
}, identity: function () {
	return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
}, copy: function (e) {
	return e = e.elements, this.set(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8]), this
}, multiplyVector3: function (e) {
	return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
}, multiplyVector3Array: function (e) {
	return console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(e)
}, applyToVector3Array: function () {
	var e = new THREE.Vector3;
	return function (t, n, r) {
		void 0 === n && (n = 0), void 0 === r && (r = t.length);
		for (var i = 0; r > i; i += 3, n += 3)e.x = t[n], e.y = t[n + 1], e.z = t[n + 2], e.applyMatrix3(this), t[n] = e.x, t[n + 1] = e.y, t[n + 2] = e.z;
		return t
	}
}(), multiplyScalar: function (e) {
	var t = this.elements;
	return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
}, determinant: function () {
	var e = this.elements, t = e[0], n = e[1], r = e[2], i = e[3], o = e[4], a = e[5], s = e[6], l = e[7], e = e[8];
	return t * o * e - t * a * l - n * i * e + n * a * s + r * i * l - r * o * s
}, getInverse: function (e, t) {
	var n = e.elements, r = this.elements;
	if (r[0] = n[10] * n[5] - n[6] * n[9], r[1] = -n[10] * n[1] + n[2] * n[9], r[2] = n[6] * n[1] - n[2] * n[5], r[3] = -n[10] * n[4] + n[6] * n[8], r[4] = n[10] * n[0] - n[2] * n[8], r[5] = -n[6] * n[0] + n[2] * n[4], r[6] = n[9] * n[4] - n[5] * n[8], r[7] = -n[9] * n[0] + n[1] * n[8], r[8] = n[5] * n[0] - n[1] * n[4], n = n[0] * r[0] + n[1] * r[3] + n[2] * r[6], 0 === n) {
		if (t)throw Error("Matrix3.getInverse(): can't invert matrix, determinant is 0");
		return console.warn("Matrix3.getInverse(): can't invert matrix, determinant is 0"), this.identity(), this
	}
	return this.multiplyScalar(1 / n), this
}, transpose: function () {
	var e, t = this.elements;
	return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
}, flattenToArrayOffset: function (e, t) {
	var n = this.elements;
	return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
}, getNormalMatrix: function (e) {
	return this.getInverse(e).transpose(), this
}, transposeIntoArray: function (e) {
	var t = this.elements;
	return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
}, fromArray: function (e) {
	return this.elements.set(e), this
}, toArray: function () {
	var e = this.elements;
	return[e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]]
}, clone: function () {
	var e = this.elements;
	return new THREE.Matrix3(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8])
}}, THREE.Matrix4 = function (e, t, n, r, i, o, a, s, l, u, c, h, f, d, p, m) {
	var g = this.elements = new Float32Array(16);
	g[0] = void 0 !== e ? e : 1, g[4] = t || 0, g[8] = n || 0, g[12] = r || 0, g[1] = i || 0, g[5] = void 0 !== o ? o : 1, g[9] = a || 0, g[13] = s || 0, g[2] = l || 0, g[6] = u || 0, g[10] = void 0 !== c ? c : 1, g[14] = h || 0, g[3] = f || 0, g[7] = d || 0, g[11] = p || 0, g[15] = void 0 !== m ? m : 1
}, THREE.Matrix4.prototype = {constructor: THREE.Matrix4, set: function (e, t, n, r, i, o, a, s, l, u, c, h, f, d, p, m) {
	var g = this.elements;
	return g[0] = e, g[4] = t, g[8] = n, g[12] = r, g[1] = i, g[5] = o, g[9] = a, g[13] = s, g[2] = l, g[6] = u, g[10] = c, g[14] = h, g[3] = f, g[7] = d, g[11] = p, g[15] = m, this
}, identity: function () {
	return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
}, copy: function (e) {
	return this.elements.set(e.elements), this
}, extractPosition: function (e) {
	return console.warn("THREEMatrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
}, copyPosition: function (e) {
	var t = this.elements;
	return e = e.elements, t[12] = e[12], t[13] = e[13], t[14] = e[14], this
}, extractRotation: function () {
	var e = new THREE.Vector3;
	return function (t) {
		var n = this.elements;
		t = t.elements;
		var r = 1 / e.set(t[0], t[1], t[2]).length(), i = 1 / e.set(t[4], t[5], t[6]).length(), o = 1 / e.set(t[8], t[9], t[10]).length();
		return n[0] = t[0] * r, n[1] = t[1] * r, n[2] = t[2] * r, n[4] = t[4] * i, n[5] = t[5] * i, n[6] = t[6] * i, n[8] = t[8] * o, n[9] = t[9] * o, n[10] = t[10] * o, this
	}
}(), makeRotationFromEuler: function (e) {
	!1 == e instanceof THREE.Euler && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
	var t = this.elements, n = e.x, r = e.y, i = e.z, o = Math.cos(n), n = Math.sin(n), a = Math.cos(r), r = Math.sin(r), s = Math.cos(i), i = Math.sin(i);
	if ("XYZ" === e.order) {
		e = o * s;
		var l = o * i, u = n * s, c = n * i;
		t[0] = a * s, t[4] = -a * i, t[8] = r, t[1] = l + u * r, t[5] = e - c * r, t[9] = -n * a, t[2] = c - e * r, t[6] = u + l * r, t[10] = o * a
	} else"YXZ" === e.order ? (e = a * s, l = a * i, u = r * s, c = r * i, t[0] = e + c * n, t[4] = u * n - l, t[8] = o * r, t[1] = o * i, t[5] = o * s, t[9] = -n, t[2] = l * n - u, t[6] = c + e * n, t[10] = o * a) : "ZXY" === e.order ? (e = a * s, l = a * i, u = r * s, c = r * i, t[0] = e - c * n, t[4] = -o * i, t[8] = u + l * n, t[1] = l + u * n, t[5] = o * s, t[9] = c - e * n, t[2] = -o * r, t[6] = n, t[10] = o * a) : "ZYX" === e.order ? (e = o * s, l = o * i, u = n * s, c = n * i, t[0] = a * s, t[4] = u * r - l, t[8] = e * r + c, t[1] = a * i, t[5] = c * r + e, t[9] = l * r - u, t[2] = -r, t[6] = n * a, t[10] = o * a) : "YZX" === e.order ? (e = o * a, l = o * r, u = n * a, c = n * r, t[0] = a * s, t[4] = c - e * i, t[8] = u * i + l, t[1] = i, t[5] = o * s, t[9] = -n * s, t[2] = -r * s, t[6] = l * i + u, t[10] = e - c * i) : "XZY" === e.order && (e = o * a, l = o * r, u = n * a, c = n * r, t[0] = a * s, t[4] = -i, t[8] = r * s, t[1] = e * i + c, t[5] = o * s, t[9] = l * i - u, t[2] = u * i - l, t[6] = n * s, t[10] = c * i + e);
	return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
}, setRotationFromQuaternion: function (e) {
	return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
}, makeRotationFromQuaternion: function (e) {
	var t = this.elements, n = e.x, r = e.y, i = e.z, o = e.w, a = n + n, s = r + r, l = i + i;
	e = n * a;
	var u = n * s, n = n * l, c = r * s, r = r * l, i = i * l, a = o * a, s = o * s, o = o * l;
	return t[0] = 1 - (c + i), t[4] = u - o, t[8] = n + s, t[1] = u + o, t[5] = 1 - (e + i), t[9] = r - a, t[2] = n - s, t[6] = r + a, t[10] = 1 - (e + c), t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
}, lookAt: function () {
	var e = new THREE.Vector3, t = new THREE.Vector3, n = new THREE.Vector3;
	return function (r, i, o) {
		var a = this.elements;
		return n.subVectors(r, i).normalize(), 0 === n.length() && (n.z = 1), e.crossVectors(o, n).normalize(), 0 === e.length() && (n.x += 1e-4, e.crossVectors(o, n).normalize()), t.crossVectors(n, e), a[0] = e.x, a[4] = t.x, a[8] = n.x, a[1] = e.y, a[5] = t.y, a[9] = n.y, a[2] = e.z, a[6] = t.z, a[10] = n.z, this
	}
}(), multiply: function (e, t) {
	return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
}, multiplyMatrices: function (e, t) {
	var n = e.elements, r = t.elements, i = this.elements, o = n[0], a = n[4], s = n[8], l = n[12], u = n[1], c = n[5], h = n[9], f = n[13], d = n[2], p = n[6], m = n[10], g = n[14], E = n[3], v = n[7], y = n[11], n = n[15], T = r[0], x = r[4], R = r[8], b = r[12], _ = r[1], w = r[5], H = r[9], M = r[13], S = r[2], C = r[6], A = r[10], L = r[14], k = r[3], P = r[7], D = r[11], r = r[15];
	return i[0] = o * T + a * _ + s * S + l * k, i[4] = o * x + a * w + s * C + l * P, i[8] = o * R + a * H + s * A + l * D, i[12] = o * b + a * M + s * L + l * r, i[1] = u * T + c * _ + h * S + f * k, i[5] = u * x + c * w + h * C + f * P, i[9] = u * R + c * H + h * A + f * D, i[13] = u * b + c * M + h * L + f * r, i[2] = d * T + p * _ + m * S + g * k, i[6] = d * x + p * w + m * C + g * P, i[10] = d * R + p * H + m * A + g * D, i[14] = d * b + p * M + m * L + g * r, i[3] = E * T + v * _ + y * S + n * k, i[7] = E * x + v * w + y * C + n * P, i[11] = E * R + v * H + y * A + n * D, i[15] = E * b + v * M + y * L + n * r, this
}, multiplyToArray: function (e, t, n) {
	var r = this.elements;
	return this.multiplyMatrices(e, t), n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[3], n[4] = r[4], n[5] = r[5], n[6] = r[6], n[7] = r[7], n[8] = r[8], n[9] = r[9], n[10] = r[10], n[11] = r[11], n[12] = r[12], n[13] = r[13], n[14] = r[14], n[15] = r[15], this
}, multiplyScalar: function (e) {
	var t = this.elements;
	return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
}, multiplyVector3: function (e) {
	return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."), e.applyProjection(this)
}, multiplyVector4: function (e) {
	return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
}, multiplyVector3Array: function (e) {
	return console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(e)
}, applyToVector3Array: function () {
	var e = new THREE.Vector3;
	return function (t, n, r) {
		void 0 === n && (n = 0), void 0 === r && (r = t.length);
		for (var i = 0; r > i; i += 3, n += 3)e.x = t[n], e.y = t[n + 1], e.z = t[n + 2], e.applyMatrix4(this), t[n] = e.x, t[n + 1] = e.y, t[n + 2] = e.z;
		return t
	}
}(), rotateAxis: function (e) {
	console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
}, crossVector: function (e) {
	return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
}, determinant: function () {
	var e = this.elements, t = e[0], n = e[4], r = e[8], i = e[12], o = e[1], a = e[5], s = e[9], l = e[13], u = e[2], c = e[6], h = e[10], f = e[14];
	return e[3] * (+i * s * c - r * l * c - i * a * h + n * l * h + r * a * f - n * s * f) + e[7] * (+t * s * f - t * l * h + i * o * h - r * o * f + r * l * u - i * s * u) + e[11] * (+t * l * c - t * a * f - i * o * c + n * o * f + i * a * u - n * l * u) + e[15] * (-r * a * u - t * s * c + t * a * h + r * o * c - n * o * h + n * s * u)
}, transpose: function () {
	var e, t = this.elements;
	return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
}, flattenToArrayOffset: function (e, t) {
	var n = this.elements;
	return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
}, getPosition: function () {
	var e = new THREE.Vector3;
	return function () {
		console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
		var t = this.elements;
		return e.set(t[12], t[13], t[14])
	}
}(), setPosition: function (e) {
	var t = this.elements;
	return t[12] = e.x, t[13] = e.y, t[14] = e.z, this
}, getInverse: function (e, t) {
	var n = this.elements, r = e.elements, i = r[0], o = r[4], a = r[8], s = r[12], l = r[1], u = r[5], c = r[9], h = r[13], f = r[2], d = r[6], p = r[10], m = r[14], g = r[3], E = r[7], v = r[11], r = r[15];
	if (n[0] = c * m * E - h * p * E + h * d * v - u * m * v - c * d * r + u * p * r, n[4] = s * p * E - a * m * E - s * d * v + o * m * v + a * d * r - o * p * r, n[8] = a * h * E - s * c * E + s * u * v - o * h * v - a * u * r + o * c * r, n[12] = s * c * d - a * h * d - s * u * p + o * h * p + a * u * m - o * c * m, n[1] = h * p * g - c * m * g - h * f * v + l * m * v + c * f * r - l * p * r, n[5] = a * m * g - s * p * g + s * f * v - i * m * v - a * f * r + i * p * r, n[9] = s * c * g - a * h * g - s * l * v + i * h * v + a * l * r - i * c * r, n[13] = a * h * f - s * c * f + s * l * p - i * h * p - a * l * m + i * c * m, n[2] = u * m * g - h * d * g + h * f * E - l * m * E - u * f * r + l * d * r, n[6] = s * d * g - o * m * g - s * f * E + i * m * E + o * f * r - i * d * r, n[10] = o * h * g - s * u * g + s * l * E - i * h * E - o * l * r + i * u * r, n[14] = s * u * f - o * h * f - s * l * d + i * h * d + o * l * m - i * u * m, n[3] = c * d * g - u * p * g - c * f * E + l * p * E + u * f * v - l * d * v, n[7] = o * p * g - a * d * g + a * f * E - i * p * E - o * f * v + i * d * v, n[11] = a * u * g - o * c * g - a * l * E + i * c * E + o * l * v - i * u * v, n[15] = o * c * f - a * u * f + a * l * d - i * c * d - o * l * p + i * u * p, n = i * n[0] + l * n[4] + f * n[8] + g * n[12], 0 == n) {
		if (t)throw Error("Matrix4.getInverse(): can't invert matrix, determinant is 0");
		return console.warn("Matrix4.getInverse(): can't invert matrix, determinant is 0"), this.identity(), this
	}
	return this.multiplyScalar(1 / n), this
}, translate: function () {
	console.warn("THREE.Matrix4: .translate() has been removed.")
}, rotateX: function () {
	console.warn("THREE.Matrix4: .rotateX() has been removed.")
}, rotateY: function () {
	console.warn("THREE.Matrix4: .rotateY() has been removed.")
}, rotateZ: function () {
	console.warn("THREE.Matrix4: .rotateZ() has been removed.")
}, rotateByAxis: function () {
	console.warn("THREE.Matrix4: .rotateByAxis() has been removed.")
}, scale: function (e) {
	var t = this.elements, n = e.x, r = e.y;
	return e = e.z, t[0] *= n, t[4] *= r, t[8] *= e, t[1] *= n, t[5] *= r, t[9] *= e, t[2] *= n, t[6] *= r, t[10] *= e, t[3] *= n, t[7] *= r, t[11] *= e, this
}, getMaxScaleOnAxis: function () {
	var e = this.elements;
	return Math.sqrt(Math.max(e[0] * e[0] + e[1] * e[1] + e[2] * e[2], Math.max(e[4] * e[4] + e[5] * e[5] + e[6] * e[6], e[8] * e[8] + e[9] * e[9] + e[10] * e[10])))
}, makeTranslation: function (e, t, n) {
	return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
}, makeRotationX: function (e) {
	var t = Math.cos(e);
	return e = Math.sin(e), this.set(1, 0, 0, 0, 0, t, -e, 0, 0, e, t, 0, 0, 0, 0, 1), this
}, makeRotationY: function (e) {
	var t = Math.cos(e);
	return e = Math.sin(e), this.set(t, 0, e, 0, 0, 1, 0, 0, -e, 0, t, 0, 0, 0, 0, 1), this
}, makeRotationZ: function (e) {
	var t = Math.cos(e);
	return e = Math.sin(e), this.set(t, -e, 0, 0, e, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
}, makeRotationAxis: function (e, t) {
	var n = Math.cos(t), r = Math.sin(t), i = 1 - n, o = e.x, a = e.y, s = e.z, l = i * o, u = i * a;
	return this.set(l * o + n, l * a - r * s, l * s + r * a, 0, l * a + r * s, u * a + n, u * s - r * o, 0, l * s - r * a, u * s + r * o, i * s * s + n, 0, 0, 0, 0, 1), this
}, makeScale: function (e, t, n) {
	return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
}, compose: function (e, t, n) {
	return this.makeRotationFromQuaternion(t), this.scale(n), this.setPosition(e), this
}, decompose: function () {
	var e = new THREE.Vector3, t = new THREE.Matrix4;
	return function (n, r, i) {
		var o = this.elements, a = e.set(o[0], o[1], o[2]).length(), s = e.set(o[4], o[5], o[6]).length(), l = e.set(o[8], o[9], o[10]).length();
		0 > this.determinant() && (a = -a), n.x = o[12], n.y = o[13], n.z = o[14], t.elements.set(this.elements), n = 1 / a;
		var o = 1 / s, u = 1 / l;
		return t.elements[0] *= n, t.elements[1] *= n, t.elements[2] *= n, t.elements[4] *= o, t.elements[5] *= o, t.elements[6] *= o, t.elements[8] *= u, t.elements[9] *= u, t.elements[10] *= u, r.setFromRotationMatrix(t), i.x = a, i.y = s, i.z = l, this
	}
}(), makeFrustum: function (e, t, n, r, i, o) {
	var a = this.elements;
	return a[0] = 2 * i / (t - e), a[4] = 0, a[8] = (t + e) / (t - e), a[12] = 0, a[1] = 0, a[5] = 2 * i / (r - n), a[9] = (r + n) / (r - n), a[13] = 0, a[2] = 0, a[6] = 0, a[10] = -(o + i) / (o - i), a[14] = -2 * o * i / (o - i), a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
}, makePerspective: function (e, t, n, r) {
	e = n * Math.tan(THREE.Math.degToRad(.5 * e));
	var i = -e;
	return this.makeFrustum(i * t, e * t, i, e, n, r)
}, makeOrthographic: function (e, t, n, r, i, o) {
	var a = this.elements, s = t - e, l = n - r, u = o - i;
	return a[0] = 2 / s, a[4] = 0, a[8] = 0, a[12] = -((t + e) / s), a[1] = 0, a[5] = 2 / l, a[9] = 0, a[13] = -((n + r) / l), a[2] = 0, a[6] = 0, a[10] = -2 / u, a[14] = -((o + i) / u), a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
}, fromArray: function (e) {
	return this.elements.set(e), this
}, toArray: function () {
	var e = this.elements;
	return[e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]]
}, clone: function () {
	var e = this.elements;
	return new THREE.Matrix4(e[0], e[4], e[8], e[12], e[1], e[5], e[9], e[13], e[2], e[6], e[10], e[14], e[3], e[7], e[11], e[15])
}}, THREE.Ray = function (e, t) {
	this.origin = void 0 !== e ? e : new THREE.Vector3, this.direction = void 0 !== t ? t : new THREE.Vector3
}, THREE.Ray.prototype = {constructor: THREE.Ray, set: function (e, t) {
	return this.origin.copy(e), this.direction.copy(t), this
}, copy: function (e) {
	return this.origin.copy(e.origin), this.direction.copy(e.direction), this
}, at: function (e, t) {
	return(t || new THREE.Vector3).copy(this.direction).multiplyScalar(e).add(this.origin)
}, recast: function () {
	var e = new THREE.Vector3;
	return function (t) {
		return this.origin.copy(this.at(t, e)), this
	}
}(), closestPointToPoint: function (e, t) {
	var n = t || new THREE.Vector3;
	n.subVectors(e, this.origin);
	var r = n.dot(this.direction);
	return 0 > r ? n.copy(this.origin) : n.copy(this.direction).multiplyScalar(r).add(this.origin)
}, distanceToPoint: function () {
	var e = new THREE.Vector3;
	return function (t) {
		var n = e.subVectors(t, this.origin).dot(this.direction);
		return 0 > n ? this.origin.distanceTo(t) : (e.copy(this.direction).multiplyScalar(n).add(this.origin), e.distanceTo(t))
	}
}(), distanceSqToSegment: function (e, t, n, r) {
	var i = e.clone().add(t).multiplyScalar(.5), o = t.clone().sub(e).normalize(), a = .5 * e.distanceTo(t), s = this.origin.clone().sub(i);
	e = -this.direction.dot(o), t = s.dot(this.direction);
	var l, u, c = -s.dot(o), h = s.lengthSq(), f = Math.abs(1 - e * e);
	return f >= 0 ? (s = e * c - t, l = e * t - c, u = a * f, s >= 0 ? l >= -u ? u >= l ? (a = 1 / f, s *= a, l *= a, e = s * (s + e * l + 2 * t) + l * (e * s + l + 2 * c) + h) : (l = a, s = Math.max(0, -(e * l + t)), e = -s * s + l * (l + 2 * c) + h) : (l = -a, s = Math.max(0, -(e * l + t)), e = -s * s + l * (l + 2 * c) + h) : -u >= l ? (s = Math.max(0, -(-e * a + t)), l = s > 0 ? -a : Math.min(Math.max(-a, -c), a), e = -s * s + l * (l + 2 * c) + h) : u >= l ? (s = 0, l = Math.min(Math.max(-a, -c), a), e = l * (l + 2 * c) + h) : (s = Math.max(0, -(e * a + t)), l = s > 0 ? a : Math.min(Math.max(-a, -c), a), e = -s * s + l * (l + 2 * c) + h)) : (l = e > 0 ? -a : a, s = Math.max(0, -(e * l + t)), e = -s * s + l * (l + 2 * c) + h), n && n.copy(this.direction.clone().multiplyScalar(s).add(this.origin)), r && r.copy(o.clone().multiplyScalar(l).add(i)), e
}, isIntersectionSphere: function (e) {
	return this.distanceToPoint(e.center) <= e.radius
}, intersectSphere: function () {
	var e = new THREE.Vector3;
	return function (t, n) {
		e.subVectors(t.center, this.origin);
		var r = e.dot(this.direction), i = e.dot(e) - r * r, o = t.radius * t.radius;
		return i > o ? null : (o = Math.sqrt(o - i), i = r - o, r += o, 0 > i && 0 > r ? null : 0 > i ? this.at(r, n) : this.at(i, n))
	}
}(), isIntersectionPlane: function (e) {
	var t = e.distanceToPoint(this.origin);
	return 0 === t || 0 > e.normal.dot(this.direction) * t ? !0 : !1
}, distanceToPlane: function (e) {
	var t = e.normal.dot(this.direction);
	return 0 == t ? 0 == e.distanceToPoint(this.origin) ? 0 : null : (e = -(this.origin.dot(e.normal) + e.constant) / t, e >= 0 ? e : null)
}, intersectPlane: function (e, t) {
	var n = this.distanceToPlane(e);
	return null === n ? null : this.at(n, t)
}, isIntersectionBox: function () {
	var e = new THREE.Vector3;
	return function (t) {
		return null !== this.intersectBox(t, e)
	}
}(), intersectBox: function (e, t) {
	var n, r, i, o, a;
	r = 1 / this.direction.x, o = 1 / this.direction.y, a = 1 / this.direction.z;
	var s = this.origin;
	return r >= 0 ? (n = (e.min.x - s.x) * r, r *= e.max.x - s.x) : (n = (e.max.x - s.x) * r, r *= e.min.x - s.x), o >= 0 ? (i = (e.min.y - s.y) * o, o *= e.max.y - s.y) : (i = (e.max.y - s.y) * o, o *= e.min.y - s.y), n > o || i > r ? null : ((i > n || n !== n) && (n = i), (r > o || r !== r) && (r = o), a >= 0 ? (i = (e.min.z - s.z) * a, a *= e.max.z - s.z) : (i = (e.max.z - s.z) * a, a *= e.min.z - s.z), n > a || i > r ? null : ((i > n || n !== n) && (n = i), (r > a || r !== r) && (r = a), 0 > r ? null : this.at(n >= 0 ? n : r, t)))
}, intersectTriangle: function () {
	var e = new THREE.Vector3, t = new THREE.Vector3, n = new THREE.Vector3, r = new THREE.Vector3;
	return function (i, o, a, s, l) {
		if (t.subVectors(o, i), n.subVectors(a, i), r.crossVectors(t, n), o = this.direction.dot(r), o > 0) {
			if (s)return null;
			s = 1
		} else {
			if (!(0 > o))return null;
			s = -1, o = -o
		}
		return e.subVectors(this.origin, i), i = s * this.direction.dot(n.crossVectors(e, n)), 0 > i ? null : (a = s * this.direction.dot(t.cross(e)), 0 > a || i + a > o ? null : (i = -s * e.dot(r), 0 > i ? null : this.at(i / o, l)))
	}
}(), applyMatrix4: function (e) {
	return this.direction.add(this.origin).applyMatrix4(e), this.origin.applyMatrix4(e), this.direction.sub(this.origin), this.direction.normalize(), this
}, equals: function (e) {
	return e.origin.equals(this.origin) && e.direction.equals(this.direction)
}, clone: function () {
	return(new THREE.Ray).copy(this)
}}, THREE.Sphere = function (e, t) {
	this.center = void 0 !== e ? e : new THREE.Vector3, this.radius = void 0 !== t ? t : 0
}, THREE.Sphere.prototype = {constructor: THREE.Sphere, set: function (e, t) {
	return this.center.copy(e), this.radius = t, this
}, setFromPoints: function () {
	var e = new THREE.Box3;
	return function (t, n) {
		var r = this.center;
		void 0 !== n ? r.copy(n) : e.setFromPoints(t).center(r);
		for (var i = 0, o = 0, a = t.length; a > o; o++)i = Math.max(i, r.distanceToSquared(t[o]));
		return this.radius = Math.sqrt(i), this
	}
}(), copy: function (e) {
	return this.center.copy(e.center), this.radius = e.radius, this
}, empty: function () {
	return 0 >= this.radius
}, containsPoint: function (e) {
	return e.distanceToSquared(this.center) <= this.radius * this.radius
}, distanceToPoint: function (e) {
	return e.distanceTo(this.center) - this.radius
}, intersectsSphere: function (e) {
	var t = this.radius + e.radius;
	return e.center.distanceToSquared(this.center) <= t * t
}, clampPoint: function (e, t) {
	var n = this.center.distanceToSquared(e), r = t || new THREE.Vector3;
	return r.copy(e), n > this.radius * this.radius && (r.sub(this.center).normalize(), r.multiplyScalar(this.radius).add(this.center)), r
}, getBoundingBox: function (e) {
	return e = e || new THREE.Box3, e.set(this.center, this.center), e.expandByScalar(this.radius), e
}, applyMatrix4: function (e) {
	return this.center.applyMatrix4(e), this.radius *= e.getMaxScaleOnAxis(), this
}, translate: function (e) {
	return this.center.add(e), this
}, equals: function (e) {
	return e.center.equals(this.center) && e.radius === this.radius
}, clone: function () {
	return(new THREE.Sphere).copy(this)
}}, THREE.Frustum = function (e, t, n, r, i, o) {
	this.planes = [void 0 !== e ? e : new THREE.Plane, void 0 !== t ? t : new THREE.Plane, void 0 !== n ? n : new THREE.Plane, void 0 !== r ? r : new THREE.Plane, void 0 !== i ? i : new THREE.Plane, void 0 !== o ? o : new THREE.Plane]
}, THREE.Frustum.prototype = {constructor: THREE.Frustum, set: function (e, t, n, r, i, o) {
	var a = this.planes;
	return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(r), a[4].copy(i), a[5].copy(o), this
}, copy: function (e) {
	for (var t = this.planes, n = 0; 6 > n; n++)t[n].copy(e.planes[n]);
	return this
}, setFromMatrix: function (e) {
	var t = this.planes, n = e.elements;
	e = n[0];
	var r = n[1], i = n[2], o = n[3], a = n[4], s = n[5], l = n[6], u = n[7], c = n[8], h = n[9], f = n[10], d = n[11], p = n[12], m = n[13], g = n[14], n = n[15];
	return t[0].setComponents(o - e, u - a, d - c, n - p).normalize(), t[1].setComponents(o + e, u + a, d + c, n + p).normalize(), t[2].setComponents(o + r, u + s, d + h, n + m).normalize(), t[3].setComponents(o - r, u - s, d - h, n - m).normalize(), t[4].setComponents(o - i, u - l, d - f, n - g).normalize(), t[5].setComponents(o + i, u + l, d + f, n + g).normalize(), this
}, intersectsObject: function () {
	var e = new THREE.Sphere;
	return function (t) {
		var n = t.geometry;
		return null === n.boundingSphere && n.computeBoundingSphere(), e.copy(n.boundingSphere), e.applyMatrix4(t.matrixWorld), this.intersectsSphere(e)
	}
}(), intersectsSphere: function (e) {
	var t = this.planes, n = e.center;
	e = -e.radius;
	for (var r = 0; 6 > r; r++)if (t[r].distanceToPoint(n) < e)return!1;
	return!0
}, intersectsBox: function () {
	var e = new THREE.Vector3, t = new THREE.Vector3;
	return function (n) {
		for (var r = this.planes, i = 0; 6 > i; i++) {
			var o = r[i];
			e.x = 0 < o.normal.x ? n.min.x : n.max.x, t.x = 0 < o.normal.x ? n.max.x : n.min.x, e.y = 0 < o.normal.y ? n.min.y : n.max.y, t.y = 0 < o.normal.y ? n.max.y : n.min.y, e.z = 0 < o.normal.z ? n.min.z : n.max.z, t.z = 0 < o.normal.z ? n.max.z : n.min.z;
			var a = o.distanceToPoint(e), o = o.distanceToPoint(t);
			if (0 > a && 0 > o)return!1
		}
		return!0
	}
}(), containsPoint: function (e) {
	for (var t = this.planes, n = 0; 6 > n; n++)if (0 > t[n].distanceToPoint(e))return!1;
	return!0
}, clone: function () {
	return(new THREE.Frustum).copy(this)
}}, THREE.Plane = function (e, t) {
	this.normal = void 0 !== e ? e : new THREE.Vector3(1, 0, 0), this.constant = void 0 !== t ? t : 0
}, THREE.Plane.prototype = {constructor: THREE.Plane, set: function (e, t) {
	return this.normal.copy(e), this.constant = t, this
}, setComponents: function (e, t, n, r) {
	return this.normal.set(e, t, n), this.constant = r, this
}, setFromNormalAndCoplanarPoint: function (e, t) {
	return this.normal.copy(e), this.constant = -t.dot(this.normal), this
}, setFromCoplanarPoints: function () {
	var e = new THREE.Vector3, t = new THREE.Vector3;
	return function (n, r, i) {
		return r = e.subVectors(i, r).cross(t.subVectors(n, r)).normalize(), this.setFromNormalAndCoplanarPoint(r, n), this
	}
}(), copy: function (e) {
	return this.normal.copy(e.normal), this.constant = e.constant, this
}, normalize: function () {
	var e = 1 / this.normal.length();
	return this.normal.multiplyScalar(e), this.constant *= e, this
}, negate: function () {
	return this.constant *= -1, this.normal.negate(), this
}, distanceToPoint: function (e) {
	return this.normal.dot(e) + this.constant
}, distanceToSphere: function (e) {
	return this.distanceToPoint(e.center) - e.radius
}, projectPoint: function (e, t) {
	return this.orthoPoint(e, t).sub(e).negate()
}, orthoPoint: function (e, t) {
	var n = this.distanceToPoint(e);
	return(t || new THREE.Vector3).copy(this.normal).multiplyScalar(n)
}, isIntersectionLine: function (e) {
	var t = this.distanceToPoint(e.start);
	return e = this.distanceToPoint(e.end), 0 > t && e > 0 || 0 > e && t > 0
}, intersectLine: function () {
	var e = new THREE.Vector3;
	return function (t, n) {
		var r = n || new THREE.Vector3, i = t.delta(e), o = this.normal.dot(i);
		return 0 != o ? (o = -(t.start.dot(this.normal) + this.constant) / o, 0 > o || o > 1 ? void 0 : r.copy(i).multiplyScalar(o).add(t.start)) : 0 == this.distanceToPoint(t.start) ? r.copy(t.start) : void 0
	}
}(), coplanarPoint: function (e) {
	return(e || new THREE.Vector3).copy(this.normal).multiplyScalar(-this.constant)
}, applyMatrix4: function () {
	var e = new THREE.Vector3, t = new THREE.Vector3, n = new THREE.Matrix3;
	return function (r, i) {
		var o = i || n.getNormalMatrix(r), o = e.copy(this.normal).applyMatrix3(o), a = this.coplanarPoint(t);
		return a.applyMatrix4(r), this.setFromNormalAndCoplanarPoint(o, a), this
	}
}(), translate: function (e) {
	return this.constant -= e.dot(this.normal), this
}, equals: function (e) {
	return e.normal.equals(this.normal) && e.constant == this.constant
}, clone: function () {
	return(new THREE.Plane).copy(this)
}}, THREE.Math = {generateUUID: function () {
	var e, t = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), n = Array(36), r = 0;
	return function () {
		for (var i = 0; 36 > i; i++)8 == i || 13 == i || 18 == i || 23 == i ? n[i] = "-" : 14 == i ? n[i] = "4" : (2 >= r && (r = 33554432 + 16777216 * Math.random() | 0), e = 15 & r, r >>= 4, n[i] = t[19 == i ? 3 & e | 8 : e]);
		return n.join("")
	}
}(), clamp: function (e, t, n) {
	return t > e ? t : e > n ? n : e
}, clampBottom: function (e, t) {
	return t > e ? t : e
}, mapLinear: function (e, t, n, r, i) {
	return r + (e - t) * (i - r) / (n - t)
}, smoothstep: function (e, t, n) {
	return t >= e ? 0 : e >= n ? 1 : (e = (e - t) / (n - t), e * e * (3 - 2 * e))
}, smootherstep: function (e, t, n) {
	return t >= e ? 0 : e >= n ? 1 : (e = (e - t) / (n - t), e * e * e * (e * (6 * e - 15) + 10))
}, random16: function () {
	return(65280 * Math.random() + 255 * Math.random()) / 65535
}, randInt: function (e, t) {
	return e + Math.floor(Math.random() * (t - e + 1))
}, randFloat: function (e, t) {
	return e + Math.random() * (t - e)
}, randFloatSpread: function (e) {
	return e * (.5 - Math.random())
}, sign: function (e) {
	return 0 > e ? -1 : e > 0 ? 1 : 0
}, degToRad: function () {
	var e = Math.PI / 180;
	return function (t) {
		return t * e
	}
}(), radToDeg: function () {
	var e = 180 / Math.PI;
	return function (t) {
		return t * e
	}
}(), isPowerOfTwo: function (e) {
	return 0 === (e & e - 1) && 0 !== e
}}, THREE.Spline = function (e) {
	function t(e, t, n, r, i, o, a) {
		return e = .5 * (n - e), r = .5 * (r - t), (2 * (t - n) + e + r) * a + (-3 * (t - n) - 2 * e - r) * o + e * i + t
	}

	this.points = e;
	var n, r, i, o, a, s, l, u, c, h = [], f = {x: 0, y: 0, z: 0};
	this.initFromArray = function (e) {
		this.points = [];
		for (var t = 0; t < e.length; t++)this.points[t] = {x: e[t][0], y: e[t][1], z: e[t][2]}
	}, this.getPoint = function (e) {
		return n = (this.points.length - 1) * e, r = Math.floor(n), i = n - r, h[0] = 0 === r ? r : r - 1, h[1] = r, h[2] = r > this.points.length - 2 ? this.points.length - 1 : r + 1, h[3] = r > this.points.length - 3 ? this.points.length - 1 : r + 2, s = this.points[h[0]], l = this.points[h[1]], u = this.points[h[2]], c = this.points[h[3]], o = i * i, a = i * o, f.x = t(s.x, l.x, u.x, c.x, i, o, a), f.y = t(s.y, l.y, u.y, c.y, i, o, a), f.z = t(s.z, l.z, u.z, c.z, i, o, a), f
	}, this.getControlPointsArray = function () {
		var e, t, n = this.points.length, r = [];
		for (e = 0; n > e; e++)t = this.points[e], r[e] = [t.x, t.y, t.z];
		return r
	}, this.getLength = function (e) {
		var t, n, r, i = t = t = 0, o = new THREE.Vector3, a = new THREE.Vector3, s = [], l = 0;
		for (s[0] = 0, e || (e = 100), n = this.points.length * e, o.copy(this.points[0]), e = 1; n > e; e++)t = e / n, r = this.getPoint(t), a.copy(r), l += a.distanceTo(o), o.copy(r), t *= this.points.length - 1, t = Math.floor(t), t != i && (s[t] = l, i = t);
		return s[s.length] = l, {chunks: s, total: l}
	}, this.reparametrizeByArcLength = function (e) {
		var t, n, r, i, o, a, s = [], l = new THREE.Vector3, u = this.getLength();
		for (s.push(l.copy(this.points[0]).clone()), t = 1; t < this.points.length; t++) {
			for (n = u.chunks[t] - u.chunks[t - 1], a = Math.ceil(e * n / u.total), i = (t - 1) / (this.points.length - 1), o = t / (this.points.length - 1), n = 1; a - 1 > n; n++)r = i + 1 / a * n * (o - i), r = this.getPoint(r), s.push(l.copy(r).clone());
			s.push(l.copy(this.points[t]).clone())
		}
		this.points = s
	}
}, THREE.Triangle = function (e, t, n) {
	this.a = void 0 !== e ? e : new THREE.Vector3, this.b = void 0 !== t ? t : new THREE.Vector3, this.c = void 0 !== n ? n : new THREE.Vector3
}, THREE.Triangle.normal = function () {
	var e = new THREE.Vector3;
	return function (t, n, r, i) {
		return i = i || new THREE.Vector3, i.subVectors(r, n), e.subVectors(t, n), i.cross(e), t = i.lengthSq(), t > 0 ? i.multiplyScalar(1 / Math.sqrt(t)) : i.set(0, 0, 0)
	}
}(), THREE.Triangle.barycoordFromPoint = function () {
	var e = new THREE.Vector3, t = new THREE.Vector3, n = new THREE.Vector3;
	return function (r, i, o, a, s) {
		e.subVectors(a, i), t.subVectors(o, i), n.subVectors(r, i), r = e.dot(e), i = e.dot(t), o = e.dot(n);
		var l = t.dot(t);
		a = t.dot(n);
		var u = r * l - i * i;
		return s = s || new THREE.Vector3, 0 == u ? s.set(-2, -1, -1) : (u = 1 / u, l = (l * o - i * a) * u, r = (r * a - i * o) * u, s.set(1 - l - r, r, l))
	}
}(), THREE.Triangle.containsPoint = function () {
	var e = new THREE.Vector3;
	return function (t, n, r, i) {
		return t = THREE.Triangle.barycoordFromPoint(t, n, r, i, e), 0 <= t.x && 0 <= t.y && 1 >= t.x + t.y
	}
}(), THREE.Triangle.prototype = {constructor: THREE.Triangle, set: function (e, t, n) {
	return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
}, setFromPointsAndIndices: function (e, t, n, r) {
	return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this
}, copy: function (e) {
	return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
}, area: function () {
	var e = new THREE.Vector3, t = new THREE.Vector3;
	return function () {
		return e.subVectors(this.c, this.b), t.subVectors(this.a, this.b), .5 * e.cross(t).length()
	}
}(), midpoint: function (e) {
	return(e || new THREE.Vector3).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
}, normal: function (e) {
	return THREE.Triangle.normal(this.a, this.b, this.c, e)
}, plane: function (e) {
	return(e || new THREE.Plane).setFromCoplanarPoints(this.a, this.b, this.c)
}, barycoordFromPoint: function (e, t) {
	return THREE.Triangle.barycoordFromPoint(e, this.a, this.b, this.c, t)
}, containsPoint: function (e) {
	return THREE.Triangle.containsPoint(e, this.a, this.b, this.c)
}, equals: function (e) {
	return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
}, clone: function () {
	return(new THREE.Triangle).copy(this)
}}, THREE.Clock = function (e) {
	this.autoStart = void 0 !== e ? e : !0, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1
}, THREE.Clock.prototype = {constructor: THREE.Clock, start: function () {
	this.oldTime = this.startTime = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(), this.running = !0
}, stop: function () {
	this.getElapsedTime(), this.running = !1
}, getElapsedTime: function () {
	return this.getDelta(), this.elapsedTime
}, getDelta: function () {
	var e = 0;
	if (this.autoStart && !this.running && this.start(), this.running) {
		var t = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(), e = .001 * (t - this.oldTime);
		this.oldTime = t, this.elapsedTime += e
	}
	return e
}}, THREE.EventDispatcher = function () {
}, THREE.EventDispatcher.prototype = {constructor: THREE.EventDispatcher, apply: function (e) {
	e.addEventListener = THREE.EventDispatcher.prototype.addEventListener, e.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener, e.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener, e.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent
}, addEventListener: function (e, t) {
	void 0 === this._listeners && (this._listeners = {});
	var n = this._listeners;
	void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
}, hasEventListener: function (e, t) {
	if (void 0 === this._listeners)return!1;
	var n = this._listeners;
	return void 0 !== n[e] && -1 !== n[e].indexOf(t) ? !0 : !1
}, removeEventListener: function (e, t) {
	if (void 0 !== this._listeners) {
		var n = this._listeners[e];
		if (void 0 !== n) {
			var r = n.indexOf(t);
			-1 !== r && n.splice(r, 1)
		}
	}
}, dispatchEvent: function (e) {
	if (void 0 !== this._listeners) {
		var t = this._listeners[e.type];
		if (void 0 !== t) {
			e.target = this;
			for (var n = [], r = t.length, i = 0; r > i; i++)n[i] = t[i];
			for (i = 0; r > i; i++)n[i].call(this, e)
		}
	}
}}, function (e) {
	e.Raycaster = function (t, n, r, i) {
		this.ray = new e.Ray(t, n), this.near = r || 0, this.far = i || 1 / 0, this.params = {Sprite: {}, Mesh: {}, PointCloud: {threshold: 1}, LOD: {}, Line: {}}
	};
	var t = function (e, t) {
		return e.distance - t.distance
	}, n = function (e, t, r, i) {
		if (e.raycast(t, r), !0 === i) {
			e = e.children, i = 0;
			for (var o = e.length; o > i; i++)n(e[i], t, r, !0)
		}
	};
	e.Raycaster.prototype = {constructor: e.Raycaster, precision: 1e-4, linePrecision: 1, set: function (e, t) {
		this.ray.set(e, t)
	}, intersectObject: function (e, r) {
		var i = [];
		return n(e, this, i, r), i.sort(t), i
	}, intersectObjects: function (e, r) {
		for (var i = [], o = 0, a = e.length; a > o; o++)n(e[o], this, i, r);
		return i.sort(t), i
	}}
}(THREE), THREE.Object3D = function () {
	this.id = THREE.Object3DIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.parent = void 0, this.children = [], this.up = THREE.Object3D.DefaultUp.clone();
	var e = new THREE.Vector3, t = new THREE.Euler, n = new THREE.Quaternion, r = new THREE.Vector3(1, 1, 1);
	t.onChange(function () {
		n.setFromEuler(t, !1)
	}), n.onChange(function () {
		t.setFromQuaternion(n, void 0, !1)
	}), Object.defineProperties(this, {position: {enumerable: !0, value: e}, rotation: {enumerable: !0, value: t}, quaternion: {enumerable: !0, value: n}, scale: {enumerable: !0, value: r}}), this.renderDepth = null, this.rotationAutoUpdate = !0, this.matrix = new THREE.Matrix4, this.matrixWorld = new THREE.Matrix4, this.matrixAutoUpdate = !0, this.matrixWorldNeedsUpdate = !1, this.visible = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.userData = {}
}, THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0), THREE.Object3D.prototype = {constructor: THREE.Object3D, get eulerOrder() {
	return console.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order."), this.rotation.order
}, set eulerOrder(e) {
	console.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order."), this.rotation.order = e
}, get useQuaternion() {
	console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
}, set useQuaternion(e) {
	console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
}, applyMatrix: function (e) {
	this.matrix.multiplyMatrices(e, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
}, setRotationFromAxisAngle: function (e, t) {
	this.quaternion.setFromAxisAngle(e, t)
}, setRotationFromEuler: function (e) {
	this.quaternion.setFromEuler(e, !0)
}, setRotationFromMatrix: function (e) {
	this.quaternion.setFromRotationMatrix(e)
}, setRotationFromQuaternion: function (e) {
	this.quaternion.copy(e)
}, rotateOnAxis: function () {
	var e = new THREE.Quaternion;
	return function (t, n) {
		return e.setFromAxisAngle(t, n), this.quaternion.multiply(e), this
	}
}(), rotateX: function () {
	var e = new THREE.Vector3(1, 0, 0);
	return function (t) {
		return this.rotateOnAxis(e, t)
	}
}(), rotateY: function () {
	var e = new THREE.Vector3(0, 1, 0);
	return function (t) {
		return this.rotateOnAxis(e, t)
	}
}(), rotateZ: function () {
	var e = new THREE.Vector3(0, 0, 1);
	return function (t) {
		return this.rotateOnAxis(e, t)
	}
}(), translateOnAxis: function () {
	var e = new THREE.Vector3;
	return function (t, n) {
		return e.copy(t).applyQuaternion(this.quaternion), this.position.add(e.multiplyScalar(n)), this
	}
}(), translate: function (e, t) {
	return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
}, translateX: function () {
	var e = new THREE.Vector3(1, 0, 0);
	return function (t) {
		return this.translateOnAxis(e, t)
	}
}(), translateY: function () {
	var e = new THREE.Vector3(0, 1, 0);
	return function (t) {
		return this.translateOnAxis(e, t)
	}
}(), translateZ: function () {
	var e = new THREE.Vector3(0, 0, 1);
	return function (t) {
		return this.translateOnAxis(e, t)
	}
}(), localToWorld: function (e) {
	return e.applyMatrix4(this.matrixWorld)
}, worldToLocal: function () {
	var e = new THREE.Matrix4;
	return function (t) {
		return t.applyMatrix4(e.getInverse(this.matrixWorld))
	}
}(), lookAt: function () {
	var e = new THREE.Matrix4;
	return function (t) {
		e.lookAt(t, this.position, this.up), this.quaternion.setFromRotationMatrix(e)
	}
}(), add: function (e) {
	if (1 < arguments.length) {
		for (var t = 0; t < arguments.length; t++)this.add(arguments[t]);
		return this
	}
	if (e === this)return console.error("THREE.Object3D.add:", e, "can't be added as a child of itself."), this;
	if (e instanceof THREE.Object3D) {
		for (void 0 !== e.parent && e.parent.remove(e), e.parent = this, e.dispatchEvent({type: "added"}), this.children.push(e), t = this; void 0 !== t.parent;)t = t.parent;
		void 0 !== t && t instanceof THREE.Scene && t.__addObject(e)
	} else console.error("THREE.Object3D.add:", e, "is not an instance of THREE.Object3D.");
	return this
}, remove: function (e) {
	if (1 < arguments.length)for (var t = 0; t < arguments.length; t++)this.remove(arguments[t]);
	if (t = this.children.indexOf(e), -1 !== t) {
		for (e.parent = void 0, e.dispatchEvent({type: "removed"}), this.children.splice(t, 1), t = this; void 0 !== t.parent;)t = t.parent;
		void 0 !== t && t instanceof THREE.Scene && t.__removeObject(e)
	}
}, raycast: function () {
}, traverse: function (e) {
	e(this);
	for (var t = 0, n = this.children.length; n > t; t++)this.children[t].traverse(e)
}, traverseVisible: function (e) {
	if (!1 !== this.visible) {
		e(this);
		for (var t = 0, n = this.children.length; n > t; t++)this.children[t].traverseVisible(e)
	}
}, getObjectById: function (e, t) {
	for (var n = 0, r = this.children.length; r > n; n++) {
		var i = this.children[n];
		if (i.id === e || !0 === t && (i = i.getObjectById(e, t), void 0 !== i))return i
	}
}, getObjectByName: function (e, t) {
	for (var n = 0, r = this.children.length; r > n; n++) {
		var i = this.children[n];
		if (i.name === e || !0 === t && (i = i.getObjectByName(e, t), void 0 !== i))return i
	}
}, getChildByName: function (e, t) {
	return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e, t)
}, updateMatrix: function () {
	this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
}, updateMatrixWorld: function (e) {
	!0 === this.matrixAutoUpdate && this.updateMatrix(), (!0 === this.matrixWorldNeedsUpdate || !0 === e) && (void 0 === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
	for (var t = 0, n = this.children.length; n > t; t++)this.children[t].updateMatrixWorld(e)
}, clone: function (e, t) {
	if (void 0 === e && (e = new THREE.Object3D), void 0 === t && (t = !0), e.name = this.name, e.up.copy(this.up), e.position.copy(this.position), e.quaternion.copy(this.quaternion), e.scale.copy(this.scale), e.renderDepth = this.renderDepth, e.rotationAutoUpdate = this.rotationAutoUpdate, e.matrix.copy(this.matrix), e.matrixWorld.copy(this.matrixWorld), e.matrixAutoUpdate = this.matrixAutoUpdate, e.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate, e.visible = this.visible, e.castShadow = this.castShadow, e.receiveShadow = this.receiveShadow, e.frustumCulled = this.frustumCulled, e.userData = JSON.parse(JSON.stringify(this.userData)), !0 === t)for (var n = 0; n < this.children.length; n++)e.add(this.children[n].clone());
	return e
}}, THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype), THREE.Object3DIdCount = 0, THREE.Projector = function () {
	function e() {
		if (u === T) {
			var e = new THREE.RenderableVertex;
			return y.push(e), T++, u++, e
		}
		return y[u++]
	}

	function t() {
		if (h === R) {
			var e = new THREE.RenderableFace;
			return x.push(e), R++, h++, e
		}
		return x[h++]
	}

	function n() {
		if (d === _) {
			var e = new THREE.RenderableLine;
			return b.push(e), _++, d++, e
		}
		return b[d++]
	}

	function r() {
		if (m === H) {
			var e = new THREE.RenderableSprite;
			return w.push(e), H++, m++, e
		}
		return w[m++]
	}

	function i(e, t) {
		return e.z !== t.z ? t.z - e.z : e.id !== t.id ? e.id - t.id : 0
	}

	function o(e, t) {
		var n = 0, r = 1, i = e.z + e.w, o = t.z + t.w, a = -e.z + e.w, s = -t.z + t.w;
		return i >= 0 && o >= 0 && a >= 0 && s >= 0 ? !0 : 0 > i && 0 > o || 0 > a && 0 > s ? !1 : (0 > i ? n = Math.max(n, i / (i - o)) : 0 > o && (r = Math.min(r, i / (i - o))), 0 > a ? n = Math.max(n, a / (a - s)) : 0 > s && (r = Math.min(r, a / (a - s))), n > r ? !1 : (e.lerp(t, n), t.lerp(e, 1 - r), !0))
	}

	var a, s, l, u, c, h, f, d, p, m, g, E = [], v = 0, y = [], T = 0, x = [], R = 0, b = [], _ = 0, w = [], H = 0, M = {objects: [], lights: [], elements: []}, S = new THREE.Vector3, C = new THREE.Vector3, A = new THREE.Vector3, L = new THREE.Vector3, k = new THREE.Vector4, P = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1)), D = new THREE.Box3, F = Array(3), N = new THREE.Matrix4, z = new THREE.Matrix4, U = new THREE.Matrix4, V = new THREE.Matrix3, B = new THREE.Frustum, O = new THREE.Vector4, I = new THREE.Vector4;
	this.projectVector = function (e, t) {
		return t.matrixWorldInverse.getInverse(t.matrixWorld), z.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), e.applyProjection(z)
	}, this.unprojectVector = function () {
		var e = new THREE.Matrix4;
		return function (t, n) {
			return e.getInverse(n.projectionMatrix), z.multiplyMatrices(n.matrixWorld, e), t.applyProjection(z)
		}
	}(), this.pickingRay = function (e, t) {
		e.z = -1;
		var n = new THREE.Vector3(e.x, e.y, 1);
		return this.unprojectVector(e, t), this.unprojectVector(n, t), n.sub(e).normalize(), new THREE.Raycaster(e, n)
	};
	var j = new function () {
		var r = [], i = [], o = null, a = null, s = new THREE.Matrix3, u = function (e) {
			var t = e.positionWorld, n = e.positionScreen;
			t.copy(e.position).applyMatrix4(g), n.copy(t).applyMatrix4(z), t = 1 / n.w, n.x *= t, n.y *= t, n.z *= t, e.visible = -1 <= n.x && 1 >= n.x && -1 <= n.y && 1 >= n.y && -1 <= n.z && 1 >= n.z
		}, h = function (e, t, n) {
			return!0 === e.visible || !0 === t.visible || !0 === n.visible ? !0 : (F[0] = e.positionScreen, F[1] = t.positionScreen, F[2] = n.positionScreen, P.isIntersectionBox(D.setFromPoints(F)))
		}, d = function (e, t, n) {
			return 0 > (n.positionScreen.x - e.positionScreen.x) * (t.positionScreen.y - e.positionScreen.y) - (n.positionScreen.y - e.positionScreen.y) * (t.positionScreen.x - e.positionScreen.x)
		};
		return{setObject: function (e) {
			o = e, a = o.material, s.getNormalMatrix(o.matrixWorld), r.length = 0, i.length = 0
		}, projectVertex: u, checkTriangleVisibility: h, checkBackfaceCulling: d, pushVertex: function (t, n, r) {
			l = e(), l.position.set(t, n, r), u(l)
		}, pushNormal: function (e, t, n) {
			r.push(e, t, n)
		}, pushUv: function (e, t) {
			i.push(e, t)
		}, pushLine: function (e, t) {
			var r = y[e], i = y[t];
			f = n(), f.id = o.id, f.v1.copy(r), f.v2.copy(i), f.z = (r.positionScreen.z + i.positionScreen.z) / 2, f.material = o.material, M.elements.push(f)
		}, pushTriangle: function (e, n, l) {
			var u = y[e], f = y[n], p = y[l];
			if (!1 !== h(u, f, p) && (a.side === THREE.DoubleSide || !0 === d(u, f, p))) {
				for (c = t(), c.id = o.id, c.v1.copy(u), c.v2.copy(f), c.v3.copy(p), c.z = (u.positionScreen.z + f.positionScreen.z + p.positionScreen.z) / 3, u = 0; 3 > u; u++)f = 3 * arguments[u], p = c.vertexNormalsModel[u], p.set(r[f], r[f + 1], r[f + 2]), p.applyMatrix3(s).normalize(), f = 2 * arguments[u], c.uvs[u].set(i[f], i[f + 1]);
				c.vertexNormalsLength = 3, c.material = o.material, M.elements.push(c)
			}
		}}
	};
	this.projectScene = function (l, T, x, R) {
		for (m = d = h = 0, M.elements.length = 0, !0 === l.autoUpdate && l.updateMatrixWorld(), void 0 === T.parent && T.updateMatrixWorld(), N.copy(T.matrixWorldInverse.getInverse(T.matrixWorld)), z.multiplyMatrices(T.projectionMatrix, N), B.setFromMatrix(z), s = 0, M.objects.length = 0, M.lights.length = 0, l.traverseVisible(function (e) {
			if (e instanceof THREE.Light)M.lights.push(e); else if ((e instanceof THREE.Mesh || e instanceof THREE.Line || e instanceof THREE.Sprite) && (!1 === e.frustumCulled || !0 === B.intersectsObject(e))) {
				if (s === v) {
					var t = new THREE.RenderableObject;
					E.push(t), v++, s++, a = t
				} else a = E[s++];
				a.id = e.id, a.object = e, null !== e.renderDepth ? a.z = e.renderDepth : (L.setFromMatrixPosition(e.matrixWorld), L.applyProjection(z), a.z = L.z), M.objects.push(a)
			}
		}), !0 === x && M.objects.sort(i), l = 0, x = M.objects.length; x > l; l++) {
			var b = M.objects[l].object, _ = b.geometry;
			if (j.setObject(b), g = b.matrixWorld, u = 0, b instanceof THREE.Mesh) {
				if (_ instanceof THREE.BufferGeometry) {
					var w = _.attributes, b = _.offsets;
					if (void 0 !== w.position) {
						for (var H = w.position.array, _ = 0, P = H.length; P > _; _ += 3)j.pushVertex(H[_], H[_ + 1], H[_ + 2]);
						if (void 0 !== w.normal)for (var D = w.normal.array, _ = 0, P = D.length; P > _; _ += 3)j.pushNormal(D[_], D[_ + 1], D[_ + 2]);
						if (void 0 !== w.uv)for (D = w.uv.array, _ = 0, P = D.length; P > _; _ += 2)j.pushUv(D[_], D[_ + 1]);
						if (void 0 !== w.index)if (w = w.index.array, 0 < b.length)for (l = 0; l < b.length; l++)for (P = b[l], H = P.index, _ = P.start, P = P.start + P.count; P > _; _ += 3)j.pushTriangle(w[_] + H, w[_ + 1] + H, w[_ + 2] + H); else for (_ = 0, P = w.length; P > _; _ += 3)j.pushTriangle(w[_], w[_ + 1], w[_ + 2]); else for (_ = 0, P = H.length / 3; P > _; _ += 3)j.pushTriangle(_, _ + 1, _ + 2)
					}
				} else if (_ instanceof THREE.Geometry) {
					var F = _.vertices, P = _.faces, w = _.faceVertexUvs[0];
					V.getNormalMatrix(g);
					for (var H = b.material instanceof THREE.MeshFaceMaterial, D = !0 === H ? b.material : null, W = 0, G = F.length; G > W; W++) {
						var X = F[W];
						j.pushVertex(X.x, X.y, X.z)
					}
					for (F = 0, W = P.length; W > F; F++) {
						var G = P[F], q = !0 === H ? D.materials[G.materialIndex] : b.material;
						if (void 0 !== q) {
							var Y = q.side, X = y[G.a], K = y[G.b], Z = y[G.c];
							if (!0 === q.morphTargets) {
								var Q = _.morphTargets, $ = b.morphTargetInfluences, J = X.position, et = K.position, tt = Z.position;
								S.set(0, 0, 0), C.set(0, 0, 0), A.set(0, 0, 0);
								for (var nt = 0, rt = Q.length; rt > nt; nt++) {
									var it = $[nt];
									if (0 !== it) {
										var ot = Q[nt].vertices;
										S.x += (ot[G.a].x - J.x) * it, S.y += (ot[G.a].y - J.y) * it, S.z += (ot[G.a].z - J.z) * it, C.x += (ot[G.b].x - et.x) * it, C.y += (ot[G.b].y - et.y) * it, C.z += (ot[G.b].z - et.z) * it, A.x += (ot[G.c].x - tt.x) * it, A.y += (ot[G.c].y - tt.y) * it, A.z += (ot[G.c].z - tt.z) * it
									}
								}
								X.position.add(S), K.position.add(C), Z.position.add(A), j.projectVertex(X), j.projectVertex(K), j.projectVertex(Z)
							}
							if (!1 !== j.checkTriangleVisibility(X, K, Z)) {
								if (Q = j.checkBackfaceCulling(X, K, Z), Y !== THREE.DoubleSide) {
									if (Y === THREE.FrontSide && !1 === Q)continue;
									if (Y === THREE.BackSide && !0 === Q)continue
								}
								for (c = t(), c.id = b.id, c.v1.copy(X), c.v2.copy(K), c.v3.copy(Z), c.normalModel.copy(G.normal), !1 !== Q || Y !== THREE.BackSide && Y !== THREE.DoubleSide || c.normalModel.negate(), c.normalModel.applyMatrix3(V).normalize(), $ = G.vertexNormals, J = 0, et = Math.min($.length, 3); et > J; J++)tt = c.vertexNormalsModel[J], tt.copy($[J]), !1 !== Q || Y !== THREE.BackSide && Y !== THREE.DoubleSide || tt.negate(), tt.applyMatrix3(V).normalize();
								if (c.vertexNormalsLength = $.length, Y = w[F], void 0 !== Y)for (Q = 0; 3 > Q; Q++)c.uvs[Q].copy(Y[Q]);
								c.color = G.color, c.material = q, c.z = (X.positionScreen.z + K.positionScreen.z + Z.positionScreen.z) / 3, M.elements.push(c)
							}
						}
					}
				}
			} else if (b instanceof THREE.Line) {
				if (_ instanceof THREE.BufferGeometry) {
					if (w = _.attributes, void 0 !== w.position) {
						for (H = w.position.array, _ = 0, P = H.length; P > _; _ += 3)j.pushVertex(H[_], H[_ + 1], H[_ + 2]);
						if (void 0 !== w.index)for (w = w.index.array, _ = 0, P = w.length; P > _; _ += 2)j.pushLine(w[_], w[_ + 1]); else for (w = b.type === THREE.LinePieces ? 2 : 1, _ = 0, P = H.length / 3 - 1; P > _; _ += w)j.pushLine(_, _ + 1)
					}
				} else if (_ instanceof THREE.Geometry && (U.multiplyMatrices(z, g), F = b.geometry.vertices, 0 !== F.length))for (X = e(), X.positionScreen.copy(F[0]).applyMatrix4(U), w = b.type === THREE.LinePieces ? 2 : 1, W = 1, G = F.length; G > W; W++)X = e(), X.positionScreen.copy(F[W]).applyMatrix4(U), (W + 1) % w > 0 || (K = y[u - 2], O.copy(X.positionScreen), I.copy(K.positionScreen), !0 === o(O, I) && (O.multiplyScalar(1 / O.w), I.multiplyScalar(1 / I.w), f = n(), f.id = b.id, f.v1.positionScreen.copy(O), f.v2.positionScreen.copy(I), f.z = Math.max(O.z, I.z), f.material = b.material, b.material.vertexColors === THREE.VertexColors && (f.vertexColors[0].copy(b.geometry.colors[W]), f.vertexColors[1].copy(b.geometry.colors[W - 1])), M.elements.push(f)))
			} else b instanceof THREE.Sprite && (k.set(g.elements[12], g.elements[13], g.elements[14], 1), k.applyMatrix4(z), _ = 1 / k.w, k.z *= _, -1 <= k.z && 1 >= k.z && (p = r(), p.id = b.id, p.x = k.x * _, p.y = k.y * _, p.z = k.z, p.object = b, p.rotation = b.rotation, p.scale.x = b.scale.x * Math.abs(p.x - (k.x + T.projectionMatrix.elements[0]) / (k.w + T.projectionMatrix.elements[12])), p.scale.y = b.scale.y * Math.abs(p.y - (k.y + T.projectionMatrix.elements[5]) / (k.w + T.projectionMatrix.elements[13])), p.material = b.material, M.elements.push(p)))
		}
		return!0 === R && M.elements.sort(i), M
	}
}, THREE.Face3 = function (e, t, n, r, i, o) {
	this.a = e, this.b = t, this.c = n, this.normal = r instanceof THREE.Vector3 ? r : new THREE.Vector3, this.vertexNormals = r instanceof Array ? r : [], this.color = i instanceof THREE.Color ? i : new THREE.Color, this.vertexColors = i instanceof Array ? i : [], this.vertexTangents = [], this.materialIndex = void 0 !== o ? o : 0
}, THREE.Face3.prototype = {constructor: THREE.Face3, clone: function () {
	var e = new THREE.Face3(this.a, this.b, this.c);
	e.normal.copy(this.normal), e.color.copy(this.color), e.materialIndex = this.materialIndex;
	for (var t = 0, n = this.vertexNormals.length; n > t; t++)e.vertexNormals[t] = this.vertexNormals[t].clone();
	for (t = 0, n = this.vertexColors.length; n > t; t++)e.vertexColors[t] = this.vertexColors[t].clone();
	for (t = 0, n = this.vertexTangents.length; n > t; t++)e.vertexTangents[t] = this.vertexTangents[t].clone();
	return e
}}, THREE.Face4 = function (e, t, n, r, i, o, a) {
	return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new THREE.Face3(e, t, n, i, o, a)
}, THREE.BufferAttribute = function (e, t) {
	this.array = e, this.itemSize = t
}, THREE.BufferAttribute.prototype = {constructor: THREE.BufferAttribute, get length() {
	return this.array.length
}, set: function (e) {
	return this.array.set(e), this
}, setX: function (e, t) {
	return this.array[e * this.itemSize] = t, this
}, setY: function (e, t) {
	return this.array[e * this.itemSize + 1] = t, this
}, setZ: function (e, t) {
	return this.array[e * this.itemSize + 2] = t, this
}, setXY: function (e, t, n) {
	return e *= this.itemSize, this.array[e] = t, this.array[e + 1] = n, this
}, setXYZ: function (e, t, n, r) {
	return e *= this.itemSize, this.array[e] = t, this.array[e + 1] = n, this.array[e + 2] = r, this
}, setXYZW: function (e, t, n, r, i) {
	return e *= this.itemSize, this.array[e] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = i, this
}}, THREE.Int8Attribute = function (e, t) {
	return console.warn("THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
}, THREE.Uint8Attribute = function (e, t) {
	return console.warn("THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
}, THREE.Uint8ClampedAttribute = function (e, t) {
	return console.warn("THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
}, THREE.Int16Attribute = function (e, t) {
	return console.warn("THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
}, THREE.Uint16Attribute = function (e, t) {
	return console.warn("THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
}, THREE.Int32Attribute = function (e, t) {
	return console.warn("THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
}, THREE.Uint32Attribute = function (e, t) {
	return console.warn("THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
}, THREE.Float32Attribute = function (e, t) {
	return console.warn("THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
}, THREE.Float64Attribute = function (e, t) {
	return console.warn("THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
}, THREE.BufferGeometry = function () {
	this.id = THREE.GeometryIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.attributes = {}, this.offsets = this.drawcalls = [], this.boundingSphere = this.boundingBox = null
}, THREE.BufferGeometry.prototype = {constructor: THREE.BufferGeometry, addAttribute: function (e, t, n) {
	!1 == t instanceof THREE.BufferAttribute ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.attributes[e] = {array: t, itemSize: n}) : this.attributes[e] = t
}, getAttribute: function (e) {
	return this.attributes[e]
}, addDrawCall: function (e, t, n) {
	this.drawcalls.push({start: e, count: t, index: void 0 !== n ? n : 0})
}, applyMatrix: function (e) {
	var t = this.attributes.position;
	void 0 !== t && (e.applyToVector3Array(t.array), t.needsUpdate = !0), t = this.attributes.normal, void 0 !== t && ((new THREE.Matrix3).getNormalMatrix(e).applyToVector3Array(t.array), t.needsUpdate = !0)
}, fromGeometry: function (e, t) {
	t = t || {vertexColors: THREE.NoColors};
	var n = e.vertices, r = e.faces, i = e.faceVertexUvs, o = t.vertexColors, a = 0 < i[0].length, s = 3 == r[0].vertexNormals.length, l = new Float32Array(9 * r.length);
	this.addAttribute("position", new THREE.BufferAttribute(l, 3));
	var u = new Float32Array(9 * r.length);
	if (this.addAttribute("normal", new THREE.BufferAttribute(u, 3)), o !== THREE.NoColors) {
		var c = new Float32Array(9 * r.length);
		this.addAttribute("color", new THREE.BufferAttribute(c, 3))
	}
	if (!0 === a) {
		var h = new Float32Array(6 * r.length);
		this.addAttribute("uvs", new THREE.BufferAttribute(h, 2))
	}
	for (var f = 0, d = 0, p = 0; f < r.length; f++, d += 6, p += 9) {
		var m = r[f], g = n[m.a], E = n[m.b], v = n[m.c];
		l[p] = g.x, l[p + 1] = g.y, l[p + 2] = g.z, l[p + 3] = E.x, l[p + 4] = E.y, l[p + 5] = E.z, l[p + 6] = v.x, l[p + 7] = v.y, l[p + 8] = v.z, !0 === s ? (g = m.vertexNormals[0], E = m.vertexNormals[1], v = m.vertexNormals[2], u[p] = g.x, u[p + 1] = g.y, u[p + 2] = g.z, u[p + 3] = E.x, u[p + 4] = E.y, u[p + 5] = E.z, u[p + 6] = v.x, u[p + 7] = v.y, u[p + 8] = v.z) : (g = m.normal, u[p] = g.x, u[p + 1] = g.y, u[p + 2] = g.z, u[p + 3] = g.x, u[p + 4] = g.y, u[p + 5] = g.z, u[p + 6] = g.x, u[p + 7] = g.y, u[p + 8] = g.z), o === THREE.FaceColors ? (m = m.color, c[p] = m.r, c[p + 1] = m.g, c[p + 2] = m.b, c[p + 3] = m.r, c[p + 4] = m.g, c[p + 5] = m.b, c[p + 6] = m.r, c[p + 7] = m.g, c[p + 8] = m.b) : o === THREE.VertexColors && (g = m.vertexColors[0], E = m.vertexColors[1], m = m.vertexColors[2], c[p] = g.r, c[p + 1] = g.g, c[p + 2] = g.b, c[p + 3] = E.r, c[p + 4] = E.g, c[p + 5] = E.b, c[p + 6] = m.r, c[p + 7] = m.g, c[p + 8] = m.b), !0 === a && (m = i[0][f][0], g = i[0][f][1], E = i[0][f][2], h[d] = m.x, h[d + 1] = m.y, h[d + 2] = g.x, h[d + 3] = g.y, h[d + 4] = E.x, h[d + 5] = E.y)
	}
	return this.computeBoundingSphere(), this
}, computeBoundingBox: function () {
	null === this.boundingBox && (this.boundingBox = new THREE.Box3);
	var e = this.attributes.position.array;
	if (e) {
		var t = this.boundingBox;
		3 <= e.length && (t.min.x = t.max.x = e[0], t.min.y = t.max.y = e[1], t.min.z = t.max.z = e[2]);
		for (var n = 3, r = e.length; r > n; n += 3) {
			var i = e[n], o = e[n + 1], a = e[n + 2];
			i < t.min.x ? t.min.x = i : i > t.max.x && (t.max.x = i), o < t.min.y ? t.min.y = o : o > t.max.y && (t.max.y = o), a < t.min.z ? t.min.z = a : a > t.max.z && (t.max.z = a)
		}
	}
	(void 0 === e || 0 === e.length) && (this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0)), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.')
}, computeBoundingSphere: function () {
	var e = new THREE.Box3, t = new THREE.Vector3;
	return function () {
		null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
		var n = this.attributes.position.array;
		if (n) {
			e.makeEmpty();
			for (var r = this.boundingSphere.center, i = 0, o = n.length; o > i; i += 3)t.set(n[i], n[i + 1], n[i + 2]), e.expandByPoint(t);
			e.center(r);
			for (var a = 0, i = 0, o = n.length; o > i; i += 3)t.set(n[i], n[i + 1], n[i + 2]), a = Math.max(a, r.distanceToSquared(t));
			this.boundingSphere.radius = Math.sqrt(a), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.')
		}
	}
}(), computeFaceNormals: function () {
}, computeVertexNormals: function () {
	if (this.attributes.position) {
		var e, t, n, r;
		if (e = this.attributes.position.array.length, void 0 === this.attributes.normal)this.attributes.normal = {itemSize: 3, array: new Float32Array(e)}; else for (e = 0, t = this.attributes.normal.array.length; t > e; e++)this.attributes.normal.array[e] = 0;
		var i, o, a, s, l, u, c = this.attributes.position.array, h = this.attributes.normal.array, f = new THREE.Vector3, d = new THREE.Vector3, p = new THREE.Vector3, m = new THREE.Vector3, g = new THREE.Vector3;
		if (this.attributes.index) {
			var E = this.attributes.index.array, v = 0 < this.offsets.length ? this.offsets : [
				{start: 0, count: E.length, index: 0}
			];
			for (n = 0, r = v.length; r > n; ++n) {
				t = v[n].start, i = v[n].count;
				var y = v[n].index;
				for (e = t, t += i; t > e; e += 3)i = y + E[e], o = y + E[e + 1], a = y + E[e + 2], s = c[3 * i], l = c[3 * i + 1], u = c[3 * i + 2], f.set(s, l, u), s = c[3 * o], l = c[3 * o + 1], u = c[3 * o + 2], d.set(s, l, u), s = c[3 * a], l = c[3 * a + 1], u = c[3 * a + 2], p.set(s, l, u), m.subVectors(p, d), g.subVectors(f, d), m.cross(g), h[3 * i] += m.x, h[3 * i + 1] += m.y, h[3 * i + 2] += m.z, h[3 * o] += m.x, h[3 * o + 1] += m.y, h[3 * o + 2] += m.z, h[3 * a] += m.x, h[3 * a + 1] += m.y, h[3 * a + 2] += m.z
			}
		} else for (e = 0, t = c.length; t > e; e += 9)s = c[e], l = c[e + 1], u = c[e + 2], f.set(s, l, u), s = c[e + 3], l = c[e + 4], u = c[e + 5], d.set(s, l, u), s = c[e + 6], l = c[e + 7], u = c[e + 8], p.set(s, l, u), m.subVectors(p, d), g.subVectors(f, d), m.cross(g), h[e] = m.x, h[e + 1] = m.y, h[e + 2] = m.z, h[e + 3] = m.x, h[e + 4] = m.y, h[e + 5] = m.z, h[e + 6] = m.x, h[e + 7] = m.y, h[e + 8] = m.z;
		this.normalizeNormals(), this.normalsNeedUpdate = !0
	}
}, computeTangents: function () {
	function e(e, t, n) {
		h = r[3 * e], f = r[3 * e + 1], d = r[3 * e + 2], p = r[3 * t], m = r[3 * t + 1], g = r[3 * t + 2], E = r[3 * n], v = r[3 * n + 1], y = r[3 * n + 2], T = o[2 * e], x = o[2 * e + 1], R = o[2 * t], b = o[2 * t + 1], _ = o[2 * n], w = o[2 * n + 1], H = p - h, M = E - h, S = m - f, C = v - f, A = g - d, L = y - d, k = R - T, P = _ - T, D = b - x, F = w - x, N = 1 / (k * F - P * D), I.set((F * H - D * M) * N, (F * S - D * C) * N, (F * A - D * L) * N), j.set((k * M - P * H) * N, (k * C - P * S) * N, (k * L - P * A) * N), l[e].add(I), l[t].add(I), l[n].add(I), u[e].add(j), u[t].add(j), u[n].add(j)
	}

	function t(e) {
		Q.x = i[3 * e], Q.y = i[3 * e + 1], Q.z = i[3 * e + 2], $.copy(Q), q = l[e], K.copy(q), K.sub(Q.multiplyScalar(Q.dot(q))).normalize(), Z.crossVectors($, q), Y = Z.dot(u[e]), X = 0 > Y ? -1 : 1, s[4 * e] = K.x, s[4 * e + 1] = K.y, s[4 * e + 2] = K.z, s[4 * e + 3] = X
	}

	if (void 0 === this.attributes.index || void 0 === this.attributes.position || void 0 === this.attributes.normal || void 0 === this.attributes.uv)console.warn("Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()"); else {
		var n = this.attributes.index.array, r = this.attributes.position.array, i = this.attributes.normal.array, o = this.attributes.uv.array, a = r.length / 3;
		void 0 === this.attributes.tangent && (this.attributes.tangent = {itemSize: 4, array: new Float32Array(4 * a)});
		for (var s = this.attributes.tangent.array, l = [], u = [], c = 0; a > c; c++)l[c] = new THREE.Vector3, u[c] = new THREE.Vector3;
		var h, f, d, p, m, g, E, v, y, T, x, R, b, _, w, H, M, S, C, A, L, k, P, D, F, N, z, U, V, B, O, I = new THREE.Vector3, j = new THREE.Vector3, W = this.offsets, c = 0;
		for (U = W.length; U > c; ++c) {
			z = W[c].start, V = W[c].count;
			var G = W[c].index, a = z;
			for (z += V; z > a; a += 3)V = G + n[a], B = G + n[a + 1], O = G + n[a + 2], e(V, B, O)
		}
		var X, q, Y, K = new THREE.Vector3, Z = new THREE.Vector3, Q = new THREE.Vector3, $ = new THREE.Vector3, c = 0;
		for (U = W.length; U > c; ++c)for (z = W[c].start, V = W[c].count, G = W[c].index, a = z, z += V; z > a; a += 3)V = G + n[a], B = G + n[a + 1], O = G + n[a + 2], t(V), t(B), t(O)
	}
}, computeOffsets: function (e) {
	var t = e;
	void 0 === e && (t = 65535), Date.now(), e = this.attributes.index.array;
	for (var n = this.attributes.position.array, r = e.length / 3, i = new Uint16Array(e.length), o = 0, a = 0, s = [
		{start: 0, count: 0, index: 0}
	], l = s[0], u = 0, c = 0, h = new Int32Array(6), f = new Int32Array(n.length), d = new Int32Array(n.length), p = 0; p < n.length; p++)f[p] = -1, d[p] = -1;
	for (n = 0; r > n; n++) {
		for (var m = c = 0; 3 > m; m++)p = e[3 * n + m], -1 == f[p] ? (h[2 * m] = p, h[2 * m + 1] = -1, c++) : f[p] < l.index ? (h[2 * m] = p, h[2 * m + 1] = -1, u++) : (h[2 * m] = p, h[2 * m + 1] = f[p]);
		if (a + c > l.index + t)for (l = {start: o, count: 0, index: a}, s.push(l), c = 0; 6 > c; c += 2)m = h[c + 1], m > -1 && m < l.index && (h[c + 1] = -1);
		for (c = 0; 6 > c; c += 2)p = h[c], m = h[c + 1], -1 === m && (m = a++), f[p] = m, d[m] = p, i[o++] = m - l.index, l.count++
	}
	return this.reorderBuffers(i, d, a), this.offsets = s
}, merge: function () {
	console.log("BufferGeometry.merge(): TODO")
}, normalizeNormals: function () {
	for (var e, t, n, r = this.attributes.normal.array, i = 0, o = r.length; o > i; i += 3)e = r[i], t = r[i + 1], n = r[i + 2], e = 1 / Math.sqrt(e * e + t * t + n * n), r[i] *= e, r[i + 1] *= e, r[i + 2] *= e
}, reorderBuffers: function (e, t, n) {
	var r, i = {}, o = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
	for (r in this.attributes)if ("index" != r)for (var a = this.attributes[r].array, s = 0, l = o.length; l > s; s++) {
		var u = o[s];
		if (a instanceof u) {
			i[r] = new u(this.attributes[r].itemSize * n);
			break
		}
	}
	for (o = 0; n > o; o++)for (r in a = t[o], this.attributes)if ("index" != r)for (var s = this.attributes[r].array, l = this.attributes[r].itemSize, u = i[r], c = 0; l > c; c++)u[o * l + c] = s[a * l + c];
	this.attributes.index.array = e;
	for (r in this.attributes)"index" != r && (this.attributes[r].array = i[r], this.attributes[r].numItems = this.attributes[r].itemSize * n)
}, clone: function () {
	var e, t = new THREE.BufferGeometry, n = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
	for (e in this.attributes) {
		for (var r = this.attributes[e], i = r.array, o = {itemSize: r.itemSize, array: null}, r = 0, a = n.length; a > r; r++) {
			var s = n[r];
			if (i instanceof s) {
				o.array = new s(i);
				break
			}
		}
		t.attributes[e] = o
	}
	for (r = 0, a = this.offsets.length; a > r; r++)n = this.offsets[r], t.offsets.push({start: n.start, index: n.index, count: n.count});
	return t
}, dispose: function () {
	this.dispatchEvent({type: "dispose"})
}}, THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype), THREE.Geometry = function () {
	this.id = THREE.GeometryIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
		[]
	], this.morphTargets = [], this.morphColors = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.hasTangents = !1, this.dynamic = !0, this.groupsNeedUpdate = this.buffersNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.tangentsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.elementsNeedUpdate = this.verticesNeedUpdate = !1
}, THREE.Geometry.prototype = {constructor: THREE.Geometry, applyMatrix: function (e) {
	for (var t = (new THREE.Matrix3).getNormalMatrix(e), n = 0, r = this.vertices.length; r > n; n++)this.vertices[n].applyMatrix4(e);
	for (n = 0, r = this.faces.length; r > n; n++) {
		e = this.faces[n], e.normal.applyMatrix3(t).normalize();
		for (var i = 0, o = e.vertexNormals.length; o > i; i++)e.vertexNormals[i].applyMatrix3(t).normalize()
	}
	this.boundingBox instanceof THREE.Box3 && this.computeBoundingBox(), this.boundingSphere instanceof THREE.Sphere && this.computeBoundingSphere()
}, center: function () {
	this.computeBoundingBox();
	var e = new THREE.Vector3;
	return e.addVectors(this.boundingBox.min, this.boundingBox.max), e.multiplyScalar(-.5), this.applyMatrix((new THREE.Matrix4).makeTranslation(e.x, e.y, e.z)), this.computeBoundingBox(), e
}, computeFaceNormals: function () {
	for (var e = new THREE.Vector3, t = new THREE.Vector3, n = 0, r = this.faces.length; r > n; n++) {
		var i = this.faces[n], o = this.vertices[i.a], a = this.vertices[i.b];
		e.subVectors(this.vertices[i.c], a), t.subVectors(o, a), e.cross(t), e.normalize(), i.normal.copy(e)
	}
}, computeVertexNormals: function (e) {
	var t, n, r;
	for (r = Array(this.vertices.length), t = 0, n = this.vertices.length; n > t; t++)r[t] = new THREE.Vector3;
	if (e) {
		var i, o, a, s = new THREE.Vector3, l = new THREE.Vector3;
		for (new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, e = 0, t = this.faces.length; t > e; e++)n = this.faces[e], i = this.vertices[n.a], o = this.vertices[n.b], a = this.vertices[n.c], s.subVectors(a, o), l.subVectors(i, o), s.cross(l), r[n.a].add(s), r[n.b].add(s), r[n.c].add(s)
	} else for (e = 0, t = this.faces.length; t > e; e++)n = this.faces[e], r[n.a].add(n.normal), r[n.b].add(n.normal), r[n.c].add(n.normal);
	for (t = 0, n = this.vertices.length; n > t; t++)r[t].normalize();
	for (e = 0, t = this.faces.length; t > e; e++)n = this.faces[e], n.vertexNormals[0] = r[n.a].clone(), n.vertexNormals[1] = r[n.b].clone(), n.vertexNormals[2] = r[n.c].clone()
}, computeMorphNormals: function () {
	var e, t, n, r, i;
	for (n = 0, r = this.faces.length; r > n; n++)for (i = this.faces[n], i.__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : i.__originalFaceNormal = i.normal.clone(), i.__originalVertexNormals || (i.__originalVertexNormals = []), e = 0, t = i.vertexNormals.length; t > e; e++)i.__originalVertexNormals[e] ? i.__originalVertexNormals[e].copy(i.vertexNormals[e]) : i.__originalVertexNormals[e] = i.vertexNormals[e].clone();
	var o = new THREE.Geometry;
	for (o.faces = this.faces, e = 0, t = this.morphTargets.length; t > e; e++) {
		if (!this.morphNormals[e]) {
			this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [], i = this.morphNormals[e].faceNormals;
			var a, s, l = this.morphNormals[e].vertexNormals;
			for (n = 0, r = this.faces.length; r > n; n++)a = new THREE.Vector3, s = {a: new THREE.Vector3, b: new THREE.Vector3, c: new THREE.Vector3}, i.push(a), l.push(s)
		}
		for (l = this.morphNormals[e], o.vertices = this.morphTargets[e].vertices, o.computeFaceNormals(), o.computeVertexNormals(), n = 0, r = this.faces.length; r > n; n++)i = this.faces[n], a = l.faceNormals[n], s = l.vertexNormals[n], a.copy(i.normal), s.a.copy(i.vertexNormals[0]), s.b.copy(i.vertexNormals[1]), s.c.copy(i.vertexNormals[2])
	}
	for (n = 0, r = this.faces.length; r > n; n++)i = this.faces[n], i.normal = i.__originalFaceNormal, i.vertexNormals = i.__originalVertexNormals
}, computeTangents: function () {
	var e, t, n, r, i, o, a, s, l, u, c, h, f, d, p, m, g, E = [], v = [];
	n = new THREE.Vector3;
	var y = new THREE.Vector3, T = new THREE.Vector3, x = new THREE.Vector3, R = new THREE.Vector3;
	for (e = 0, t = this.vertices.length; t > e; e++)E[e] = new THREE.Vector3, v[e] = new THREE.Vector3;
	for (e = 0, t = this.faces.length; t > e; e++)i = this.faces[e], o = this.faceVertexUvs[0][e], r = i.a, g = i.b, i = i.c, a = this.vertices[r], s = this.vertices[g], l = this.vertices[i], u = o[0], c = o[1], h = o[2], o = s.x - a.x, f = l.x - a.x, d = s.y - a.y, p = l.y - a.y, s = s.z - a.z, a = l.z - a.z, l = c.x - u.x, m = h.x - u.x, c = c.y - u.y, u = h.y - u.y, h = 1 / (l * u - m * c), n.set((u * o - c * f) * h, (u * d - c * p) * h, (u * s - c * a) * h), y.set((l * f - m * o) * h, (l * p - m * d) * h, (l * a - m * s) * h), E[r].add(n), E[g].add(n), E[i].add(n), v[r].add(y), v[g].add(y), v[i].add(y);
	for (y = ["a", "b", "c", "d"], e = 0, t = this.faces.length; t > e; e++)for (i = this.faces[e], n = 0; n < Math.min(i.vertexNormals.length, 3); n++)R.copy(i.vertexNormals[n]), r = i[y[n]], g = E[r], T.copy(g), T.sub(R.multiplyScalar(R.dot(g))).normalize(), x.crossVectors(i.vertexNormals[n], g), r = x.dot(v[r]), r = 0 > r ? -1 : 1, i.vertexTangents[n] = new THREE.Vector4(T.x, T.y, T.z, r);
	this.hasTangents = !0
}, computeLineDistances: function () {
	for (var e = 0, t = this.vertices, n = 0, r = t.length; r > n; n++)n > 0 && (e += t[n].distanceTo(t[n - 1])), this.lineDistances[n] = e
}, computeBoundingBox: function () {
	null === this.boundingBox && (this.boundingBox = new THREE.Box3), this.boundingBox.setFromPoints(this.vertices)
}, computeBoundingSphere: function () {
	null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere), this.boundingSphere.setFromPoints(this.vertices)
}, merge: function (e, t, n) {
	if (!1 == e instanceof THREE.Geometry)console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e); else {
		var r, i = this.vertices.length, o = this.vertices, a = e.vertices, s = this.faces, l = e.faces, u = this.faceVertexUvs[0];
		e = e.faceVertexUvs[0], void 0 === n && (n = 0), void 0 !== t && (r = (new THREE.Matrix3).getNormalMatrix(t));
		for (var c = 0, h = a.length; h > c; c++) {
			var f = a[c].clone();
			void 0 !== t && f.applyMatrix4(t), o.push(f)
		}
		for (c = 0, h = l.length; h > c; c++) {
			var d, a = l[c], p = a.vertexNormals, m = a.vertexColors, f = new THREE.Face3(a.a + i, a.b + i, a.c + i);
			for (f.normal.copy(a.normal), void 0 !== r && f.normal.applyMatrix3(r).normalize(), t = 0, o = p.length; o > t; t++)d = p[t].clone(), void 0 !== r && d.applyMatrix3(r).normalize(), f.vertexNormals.push(d);
			for (f.color.copy(a.color), t = 0, o = m.length; o > t; t++)d = m[t], f.vertexColors.push(d.clone());
			f.materialIndex = a.materialIndex + n, s.push(f)
		}
		for (c = 0, h = e.length; h > c; c++)if (n = e[c], r = [], void 0 !== n) {
			for (t = 0, o = n.length; o > t; t++)r.push(new THREE.Vector2(n[t].x, n[t].y));
			u.push(r)
		}
	}
}, mergeVertices: function () {
	var e, t, n, r = {}, i = [], o = [], a = Math.pow(10, 4);
	for (t = 0, n = this.vertices.length; n > t; t++)e = this.vertices[t], e = Math.round(e.x * a) + "_" + Math.round(e.y * a) + "_" + Math.round(e.z * a), void 0 === r[e] ? (r[e] = t, i.push(this.vertices[t]), o[t] = i.length - 1) : o[t] = o[r[e]];
	for (r = [], t = 0, n = this.faces.length; n > t; t++)for (a = this.faces[t], a.a = o[a.a], a.b = o[a.b], a.c = o[a.c], a = [a.a, a.b, a.c], e = 0; 3 > e; e++)if (a[e] == a[(e + 1) % 3]) {
		r.push(t);
		break
	}
	for (t = r.length - 1; t >= 0; t--)for (a = r[t], this.faces.splice(a, 1), o = 0, n = this.faceVertexUvs.length; n > o; o++)this.faceVertexUvs[o].splice(a, 1);
	return t = this.vertices.length - i.length, this.vertices = i, t
}, makeGroups: function () {
	var e = 0;
	return function (t, n) {
		var r, i, o, a, s, l = {}, u = this.morphTargets.length, c = this.morphNormals.length;
		for (this.geometryGroups = {}, this.geometryGroupsList = [], r = 0, i = this.faces.length; i > r; r++)o = this.faces[r], o = t ? o.materialIndex : 0, o in l || (l[o] = {hash: o, counter: 0}), a = l[o].hash + "_" + l[o].counter, a in this.geometryGroups || (s = {id: e++, faces3: [], materialIndex: o, vertices: 0, numMorphTargets: u, numMorphNormals: c}, this.geometryGroups[a] = s, this.geometryGroupsList.push(s)), this.geometryGroups[a].vertices + 3 > n && (l[o].counter += 1, a = l[o].hash + "_" + l[o].counter, a in this.geometryGroups || (s = {id: e++, faces3: [], materialIndex: o, vertices: 0, numMorphTargets: u, numMorphNormals: c}, this.geometryGroups[a] = s, this.geometryGroupsList.push(s))), this.geometryGroups[a].faces3.push(r), this.geometryGroups[a].vertices += 3
	}
}(), clone: function () {
	for (var e = new THREE.Geometry, t = this.vertices, n = 0, r = t.length; r > n; n++)e.vertices.push(t[n].clone());
	for (t = this.faces, n = 0, r = t.length; r > n; n++)e.faces.push(t[n].clone());
	for (t = this.faceVertexUvs[0], n = 0, r = t.length; r > n; n++) {
		for (var i = t[n], o = [], a = 0, s = i.length; s > a; a++)o.push(new THREE.Vector2(i[a].x, i[a].y));
		e.faceVertexUvs[0].push(o)
	}
	return e
}, dispose: function () {
	this.dispatchEvent({type: "dispose"})
}}, THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype), THREE.GeometryIdCount = 0, THREE.Camera = function () {
	THREE.Object3D.call(this), this.matrixWorldInverse = new THREE.Matrix4, this.projectionMatrix = new THREE.Matrix4
}, THREE.Camera.prototype = Object.create(THREE.Object3D.prototype), THREE.Camera.prototype.lookAt = function () {
	var e = new THREE.Matrix4;
	return function (t) {
		e.lookAt(this.position, t, this.up), this.quaternion.setFromRotationMatrix(e)
	}
}(), THREE.Camera.prototype.clone = function (e) {
	return void 0 === e && (e = new THREE.Camera), THREE.Object3D.prototype.clone.call(this, e), e.matrixWorldInverse.copy(this.matrixWorldInverse), e.projectionMatrix.copy(this.projectionMatrix), e
}, THREE.CubeCamera = function (e, t, n) {
	THREE.Object3D.call(this);
	var r = new THREE.PerspectiveCamera(90, 1, e, t);
	r.up.set(0, -1, 0), r.lookAt(new THREE.Vector3(1, 0, 0)), this.add(r);
	var i = new THREE.PerspectiveCamera(90, 1, e, t);
	i.up.set(0, -1, 0), i.lookAt(new THREE.Vector3(-1, 0, 0)), this.add(i);
	var o = new THREE.PerspectiveCamera(90, 1, e, t);
	o.up.set(0, 0, 1), o.lookAt(new THREE.Vector3(0, 1, 0)), this.add(o);
	var a = new THREE.PerspectiveCamera(90, 1, e, t);
	a.up.set(0, 0, -1), a.lookAt(new THREE.Vector3(0, -1, 0)), this.add(a);
	var s = new THREE.PerspectiveCamera(90, 1, e, t);
	s.up.set(0, -1, 0), s.lookAt(new THREE.Vector3(0, 0, 1)), this.add(s);
	var l = new THREE.PerspectiveCamera(90, 1, e, t);
	l.up.set(0, -1, 0), l.lookAt(new THREE.Vector3(0, 0, -1)), this.add(l), this.renderTarget = new THREE.WebGLRenderTargetCube(n, n, {format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter}), this.updateCubeMap = function (e, t) {
		var n = this.renderTarget, u = n.generateMipmaps;
		n.generateMipmaps = !1, n.activeCubeFace = 0, e.render(t, r, n), n.activeCubeFace = 1, e.render(t, i, n), n.activeCubeFace = 2, e.render(t, o, n), n.activeCubeFace = 3, e.render(t, a, n), n.activeCubeFace = 4, e.render(t, s, n), n.generateMipmaps = u, n.activeCubeFace = 5, e.render(t, l, n)
	}
}, THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype), THREE.OrthographicCamera = function (e, t, n, r, i, o) {
	THREE.Camera.call(this), this.left = e, this.right = t, this.top = n, this.bottom = r, this.near = void 0 !== i ? i : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
}, THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype), THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {
	this.projectionMatrix.makeOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far)
}, THREE.OrthographicCamera.prototype.clone = function () {
	var e = new THREE.OrthographicCamera;
	return THREE.Camera.prototype.clone.call(this, e), e.left = this.left, e.right = this.right, e.top = this.top, e.bottom = this.bottom, e.near = this.near, e.far = this.far, e
}, THREE.PerspectiveCamera = function (e, t, n, r) {
	THREE.Camera.call(this), this.fov = void 0 !== e ? e : 50, this.aspect = void 0 !== t ? t : 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== r ? r : 2e3, this.updateProjectionMatrix()
}, THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype), THREE.PerspectiveCamera.prototype.setLens = function (e, t) {
	void 0 === t && (t = 24), this.fov = 2 * THREE.Math.radToDeg(Math.atan(t / (2 * e))), this.updateProjectionMatrix()
}, THREE.PerspectiveCamera.prototype.setViewOffset = function (e, t, n, r, i, o) {
	this.fullWidth = e, this.fullHeight = t, this.x = n, this.y = r, this.width = i, this.height = o, this.updateProjectionMatrix()
}, THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {
	if (this.fullWidth) {
		var e = this.fullWidth / this.fullHeight, t = Math.tan(THREE.Math.degToRad(.5 * this.fov)) * this.near, n = -t, r = e * n, e = Math.abs(e * t - r), n = Math.abs(t - n);
		this.projectionMatrix.makeFrustum(r + this.x * e / this.fullWidth, r + (this.x + this.width) * e / this.fullWidth, t - (this.y + this.height) * n / this.fullHeight, t - this.y * n / this.fullHeight, this.near, this.far)
	} else this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far)
}, THREE.PerspectiveCamera.prototype.clone = function () {
	var e = new THREE.PerspectiveCamera;
	return THREE.Camera.prototype.clone.call(this, e), e.fov = this.fov, e.aspect = this.aspect, e.near = this.near, e.far = this.far, e
}, THREE.Light = function (e) {
	THREE.Object3D.call(this), this.color = new THREE.Color(e)
}, THREE.Light.prototype = Object.create(THREE.Object3D.prototype), THREE.Light.prototype.clone = function (e) {
	return void 0 === e && (e = new THREE.Light), THREE.Object3D.prototype.clone.call(this, e), e.color.copy(this.color), e
}, THREE.AmbientLight = function (e) {
	THREE.Light.call(this, e)
}, THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype), THREE.AmbientLight.prototype.clone = function () {
	var e = new THREE.AmbientLight;
	return THREE.Light.prototype.clone.call(this, e), e
}, THREE.AreaLight = function (e, t) {
	THREE.Light.call(this, e), this.normal = new THREE.Vector3(0, -1, 0), this.right = new THREE.Vector3(1, 0, 0), this.intensity = void 0 !== t ? t : 1, this.height = this.width = 1, this.constantAttenuation = 1.5, this.linearAttenuation = .5, this.quadraticAttenuation = .1
}, THREE.AreaLight.prototype = Object.create(THREE.Light.prototype), THREE.DirectionalLight = function (e, t) {
	THREE.Light.call(this, e), this.position.set(0, 1, 0), this.target = new THREE.Object3D, this.intensity = void 0 !== t ? t : 1, this.onlyShadow = this.castShadow = !1, this.shadowCameraNear = 50, this.shadowCameraFar = 5e3, this.shadowCameraLeft = -500, this.shadowCameraTop = this.shadowCameraRight = 500, this.shadowCameraBottom = -500, this.shadowCameraVisible = !1, this.shadowBias = 0, this.shadowDarkness = .5, this.shadowMapHeight = this.shadowMapWidth = 512, this.shadowCascade = !1, this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1e3), this.shadowCascadeCount = 2, this.shadowCascadeBias = [0, 0, 0], this.shadowCascadeWidth = [512, 512, 512], this.shadowCascadeHeight = [512, 512, 512], this.shadowCascadeNearZ = [-1, .99, .998], this.shadowCascadeFarZ = [.99, .998, 1], this.shadowCascadeArray = [], this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null
}, THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype), THREE.DirectionalLight.prototype.clone = function () {
	var e = new THREE.DirectionalLight;
	return THREE.Light.prototype.clone.call(this, e), e.target = this.target.clone(), e.intensity = this.intensity, e.castShadow = this.castShadow, e.onlyShadow = this.onlyShadow, e.shadowCameraNear = this.shadowCameraNear, e.shadowCameraFar = this.shadowCameraFar, e.shadowCameraLeft = this.shadowCameraLeft, e.shadowCameraRight = this.shadowCameraRight, e.shadowCameraTop = this.shadowCameraTop, e.shadowCameraBottom = this.shadowCameraBottom, e.shadowCameraVisible = this.shadowCameraVisible, e.shadowBias = this.shadowBias, e.shadowDarkness = this.shadowDarkness, e.shadowMapWidth = this.shadowMapWidth, e.shadowMapHeight = this.shadowMapHeight, e.shadowCascade = this.shadowCascade, e.shadowCascadeOffset.copy(this.shadowCascadeOffset), e.shadowCascadeCount = this.shadowCascadeCount, e.shadowCascadeBias = this.shadowCascadeBias.slice(0), e.shadowCascadeWidth = this.shadowCascadeWidth.slice(0), e.shadowCascadeHeight = this.shadowCascadeHeight.slice(0), e.shadowCascadeNearZ = this.shadowCascadeNearZ.slice(0), e.shadowCascadeFarZ = this.shadowCascadeFarZ.slice(0), e
}, THREE.HemisphereLight = function (e, t, n) {
	THREE.Light.call(this, e), this.position.set(0, 100, 0), this.groundColor = new THREE.Color(t), this.intensity = void 0 !== n ? n : 1
}, THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype), THREE.HemisphereLight.prototype.clone = function () {
	var e = new THREE.HemisphereLight;
	return THREE.Light.prototype.clone.call(this, e), e.groundColor.copy(this.groundColor), e.intensity = this.intensity, e
}, THREE.PointLight = function (e, t, n) {
	THREE.Light.call(this, e), this.intensity = void 0 !== t ? t : 1, this.distance = void 0 !== n ? n : 0
}, THREE.PointLight.prototype = Object.create(THREE.Light.prototype), THREE.PointLight.prototype.clone = function () {
	var e = new THREE.PointLight;
	return THREE.Light.prototype.clone.call(this, e), e.intensity = this.intensity, e.distance = this.distance, e
}, THREE.SpotLight = function (e, t, n, r, i) {
	THREE.Light.call(this, e), this.position.set(0, 1, 0), this.target = new THREE.Object3D, this.intensity = void 0 !== t ? t : 1, this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== r ? r : Math.PI / 3, this.exponent = void 0 !== i ? i : 10, this.onlyShadow = this.castShadow = !1, this.shadowCameraNear = 50, this.shadowCameraFar = 5e3, this.shadowCameraFov = 50, this.shadowCameraVisible = !1, this.shadowBias = 0, this.shadowDarkness = .5, this.shadowMapHeight = this.shadowMapWidth = 512, this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null
}, THREE.SpotLight.prototype = Object.create(THREE.Light.prototype), THREE.SpotLight.prototype.clone = function () {
	var e = new THREE.SpotLight;
	return THREE.Light.prototype.clone.call(this, e), e.target = this.target.clone(), e.intensity = this.intensity, e.distance = this.distance, e.angle = this.angle, e.exponent = this.exponent, e.castShadow = this.castShadow, e.onlyShadow = this.onlyShadow, e.shadowCameraNear = this.shadowCameraNear, e.shadowCameraFar = this.shadowCameraFar, e.shadowCameraFov = this.shadowCameraFov, e.shadowCameraVisible = this.shadowCameraVisible, e.shadowBias = this.shadowBias, e.shadowDarkness = this.shadowDarkness, e.shadowMapWidth = this.shadowMapWidth, e.shadowMapHeight = this.shadowMapHeight, e
}, THREE.Cache = function () {
	this.files = {}
}, THREE.Cache.prototype = {constructor: THREE.Cache, add: function (e, t) {
	this.files[e] = t
}, get: function (e) {
	return this.files[e]
}, remove: function (e) {
	delete this.files[e]
}, clear: function () {
	this.files = {}
}}, THREE.Loader = function (e) {
	this.statusDomElement = (this.showStatus = e) ? THREE.Loader.prototype.addStatusElement() : null, this.imageLoader = new THREE.ImageLoader, this.onLoadStart = function () {
	}, this.onLoadProgress = function () {
	}, this.onLoadComplete = function () {
	}
}, THREE.Loader.prototype = {constructor: THREE.Loader, crossOrigin: void 0, addStatusElement: function () {
	var e = document.createElement("div");
	return e.style.position = "absolute", e.style.right = "0px", e.style.top = "0px", e.style.fontSize = "0.8em", e.style.textAlign = "left", e.style.background = "rgba(0,0,0,0.25)", e.style.color = "#fff", e.style.width = "120px", e.style.padding = "0.5em 0.5em 0.5em 0.5em", e.style.zIndex = 1e3, e.innerHTML = "Loading ...", e
}, updateProgress: function (e) {
	var t = "Loaded ", t = e.total ? t + ((100 * e.loaded / e.total).toFixed(0) + "%") : t + ((e.loaded / 1024).toFixed(2) + " KB");
	this.statusDomElement.innerHTML = t
}, extractUrlBase: function (e) {
	return e = e.split("/"), 1 === e.length ? "./" : (e.pop(), e.join("/") + "/")
}, initMaterials: function (e, t) {
	for (var n = [], r = 0; r < e.length; ++r)n[r] = this.createMaterial(e[r], t);
	return n
}, needsTangents: function (e) {
	for (var t = 0, n = e.length; n > t; t++)if (e[t]instanceof THREE.ShaderMaterial)return!0;
	return!1
}, createMaterial: function (e, t) {
	function n(e) {
		return e = Math.log(e) / Math.LN2, Math.pow(2, Math.round(e))
	}

	function r(e, r, i, a, s, l, u) {
		var c, h = t + i, f = THREE.Loader.Handlers.get(h);
		null !== f ? c = f.load(h) : (c = new THREE.Texture, f = o.imageLoader, f.crossOrigin = o.crossOrigin, f.load(h, function (e) {
			if (!1 === THREE.Math.isPowerOfTwo(e.width) || !1 === THREE.Math.isPowerOfTwo(e.height)) {
				var t = n(e.width), r = n(e.height), i = document.createElement("canvas");
				i.width = t, i.height = r, i.getContext("2d").drawImage(e, 0, 0, t, r), c.image = i
			} else c.image = e;
			c.needsUpdate = !0
		})), c.sourceFile = i, a && (c.repeat.set(a[0], a[1]), 1 !== a[0] && (c.wrapS = THREE.RepeatWrapping), 1 !== a[1] && (c.wrapT = THREE.RepeatWrapping)), s && c.offset.set(s[0], s[1]), l && (i = {repeat: THREE.RepeatWrapping, mirror: THREE.MirroredRepeatWrapping}, void 0 !== i[l[0]] && (c.wrapS = i[l[0]]), void 0 !== i[l[1]] && (c.wrapT = i[l[1]])), u && (c.anisotropy = u), e[r] = c
	}

	function i(e) {
		return(255 * e[0] << 16) + (255 * e[1] << 8) + 255 * e[2]
	}

	var o = this, a = "MeshLambertMaterial", s = {color: 15658734, opacity: 1, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: !1};
	if (e.shading) {
		var l = e.shading.toLowerCase();
		"phong" === l ? a = "MeshPhongMaterial" : "basic" === l && (a = "MeshBasicMaterial")
	}
	return void 0 !== e.blending && void 0 !== THREE[e.blending] && (s.blending = THREE[e.blending]), (void 0 !== e.transparent || 1 > e.opacity) && (s.transparent = e.transparent), void 0 !== e.depthTest && (s.depthTest = e.depthTest), void 0 !== e.depthWrite && (s.depthWrite = e.depthWrite), void 0 !== e.visible && (s.visible = e.visible), void 0 !== e.flipSided && (s.side = THREE.BackSide), void 0 !== e.doubleSided && (s.side = THREE.DoubleSide), void 0 !== e.wireframe && (s.wireframe = e.wireframe), void 0 !== e.vertexColors && ("face" === e.vertexColors ? s.vertexColors = THREE.FaceColors : e.vertexColors && (s.vertexColors = THREE.VertexColors)), e.colorDiffuse ? s.color = i(e.colorDiffuse) : e.DbgColor && (s.color = e.DbgColor), e.colorSpecular && (s.specular = i(e.colorSpecular)), e.colorAmbient && (s.ambient = i(e.colorAmbient)), e.colorEmissive && (s.emissive = i(e.colorEmissive)), e.transparency && (s.opacity = e.transparency), e.specularCoef && (s.shininess = e.specularCoef), e.mapDiffuse && t && r(s, "map", e.mapDiffuse, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy), e.mapLight && t && r(s, "lightMap", e.mapLight, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy), e.mapBump && t && r(s, "bumpMap", e.mapBump, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy), e.mapNormal && t && r(s, "normalMap", e.mapNormal, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy), e.mapSpecular && t && r(s, "specularMap", e.mapSpecular, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy), e.mapAlpha && t && r(s, "alphaMap", e.mapAlpha, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy), e.mapBumpScale && (s.bumpScale = e.mapBumpScale), e.mapNormal ? (a = THREE.ShaderLib.normalmap, l = THREE.UniformsUtils.clone(a.uniforms), l.tNormal.value = s.normalMap, e.mapNormalFactor && l.uNormalScale.value.set(e.mapNormalFactor, e.mapNormalFactor), s.map && (l.tDiffuse.value = s.map, l.enableDiffuse.value = !0), s.specularMap && (l.tSpecular.value = s.specularMap, l.enableSpecular.value = !0), s.lightMap && (l.tAO.value = s.lightMap, l.enableAO.value = !0), l.diffuse.value.setHex(s.color), l.specular.value.setHex(s.specular), l.ambient.value.setHex(s.ambient), l.shininess.value = s.shininess, void 0 !== s.opacity && (l.opacity.value = s.opacity), a = new THREE.ShaderMaterial({fragmentShader: a.fragmentShader, vertexShader: a.vertexShader, uniforms: l, lights: !0, fog: !0}), s.transparent && (a.transparent = !0)) : a = new THREE[a](s), void 0 !== e.DbgName && (a.name = e.DbgName), a
}}, THREE.Loader.Handlers = {handlers: [], add: function (e, t) {
	this.handlers.push(e, t)
}, get: function (e) {
	for (var t = 0, n = this.handlers.length; n > t; t += 2) {
		var r = this.handlers[t + 1];
		if (this.handlers[t].test(e))return r
	}
	return null
}}, THREE.XHRLoader = function (e) {
	this.cache = new THREE.Cache, this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
}, THREE.XHRLoader.prototype = {constructor: THREE.XHRLoader, load: function (e, t, n, r) {
	var i = this, o = i.cache.get(e);
	void 0 !== o ? t && t(o) : (o = new XMLHttpRequest, o.open("GET", e, !0), o.addEventListener("load", function () {
		i.cache.add(e, this.response), t && t(this.response), i.manager.itemEnd(e)
	}, !1), void 0 !== n && o.addEventListener("progress", function (e) {
		n(e)
	}, !1), void 0 !== r && o.addEventListener("error", function (e) {
		r(e)
	}, !1), void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), void 0 !== this.responseType && (o.responseType = this.responseType), o.send(null), i.manager.itemStart(e))
}, setResponseType: function (e) {
	this.responseType = e
}, setCrossOrigin: function (e) {
	this.crossOrigin = e
}}, THREE.ImageLoader = function (e) {
	this.cache = new THREE.Cache, this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
}, THREE.ImageLoader.prototype = {constructor: THREE.ImageLoader, load: function (e, t, n, r) {
	var i = this, o = i.cache.get(e);
	return void 0 === o ? (o = document.createElement("img"), void 0 !== t && o.addEventListener("load", function () {
		i.cache.add(e, this), t(this), i.manager.itemEnd(e)
	}, !1), void 0 !== n && o.addEventListener("progress", function (e) {
		n(e)
	}, !1), void 0 !== r && o.addEventListener("error", function (e) {
		r(e)
	}, !1), void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), o.src = e, i.manager.itemStart(e), o) : void t(o)
}, setCrossOrigin: function (e) {
	this.crossOrigin = e
}}, THREE.JSONLoader = function (e) {
	THREE.Loader.call(this, e), this.withCredentials = !1
}, THREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype), THREE.JSONLoader.prototype.load = function (e, t, n) {
	n = n && "string" == typeof n ? n : this.extractUrlBase(e), this.onLoadStart(), this.loadAjaxJSON(this, e, t, n)
}, THREE.JSONLoader.prototype.loadAjaxJSON = function (e, t, n, r, i) {
	var o = new XMLHttpRequest, a = 0;
	o.onreadystatechange = function () {
		if (o.readyState === o.DONE)if (200 === o.status || 0 === o.status) {
			if (o.responseText) {
				var s = JSON.parse(o.responseText);
				if (void 0 !== s.metadata && "scene" === s.metadata.type)return void console.error('THREE.JSONLoader: "' + t + '" seems to be a Scene. Use THREE.SceneLoader instead.');
				s = e.parse(s, r), n(s.geometry, s.materials)
			} else console.error('THREE.JSONLoader: "' + t + '" seems to be unreachable or the file is empty.');
			e.onLoadComplete()
		} else console.error("THREE.JSONLoader: Couldn't load \"" + t + '" (' + o.status + ")"); else o.readyState === o.LOADING ? i && (0 === a && (a = o.getResponseHeader("Content-Length")), i({total: a, loaded: o.responseText.length})) : o.readyState === o.HEADERS_RECEIVED && void 0 !== i && (a = o.getResponseHeader("Content-Length"))
	}, o.open("GET", t, !0), o.withCredentials = this.withCredentials, o.send(null)
}, THREE.JSONLoader.prototype.parse = function (e, t) {
	var n = new THREE.Geometry, r = void 0 !== e.scale ? 1 / e.scale : 1;
	return function (t) {
		var r, i, o, a, s, l, u, c, h, f, d, p, m, g = e.faces;
		l = e.vertices;
		var E = e.normals, v = e.colors, y = 0;
		if (void 0 !== e.uvs) {
			for (r = 0; r < e.uvs.length; r++)e.uvs[r].length && y++;
			for (r = 0; y > r; r++)n.faceVertexUvs[r] = []
		}
		for (a = 0, s = l.length; s > a;)r = new THREE.Vector3, r.x = l[a++] * t, r.y = l[a++] * t, r.z = l[a++] * t, n.vertices.push(r);
		for (a = 0, s = g.length; s > a;)if (t = g[a++], h = 1 & t, o = 2 & t, r = 8 & t, u = 16 & t, f = 32 & t, l = 64 & t, t &= 128, h) {
			if (h = new THREE.Face3, h.a = g[a], h.b = g[a + 1], h.c = g[a + 3], d = new THREE.Face3, d.a = g[a + 1], d.b = g[a + 2], d.c = g[a + 3], a += 4, o && (o = g[a++], h.materialIndex = o, d.materialIndex = o), o = n.faces.length, r)for (r = 0; y > r; r++)for (p = e.uvs[r], n.faceVertexUvs[r][o] = [], n.faceVertexUvs[r][o + 1] = [], i = 0; 4 > i; i++)c = g[a++], m = p[2 * c], c = p[2 * c + 1], m = new THREE.Vector2(m, c), 2 !== i && n.faceVertexUvs[r][o].push(m), 0 !== i && n.faceVertexUvs[r][o + 1].push(m);
			if (u && (u = 3 * g[a++], h.normal.set(E[u++], E[u++], E[u]), d.normal.copy(h.normal)), f)for (r = 0; 4 > r; r++)u = 3 * g[a++], f = new THREE.Vector3(E[u++], E[u++], E[u]), 2 !== r && h.vertexNormals.push(f), 0 !== r && d.vertexNormals.push(f);
			if (l && (l = g[a++], l = v[l], h.color.setHex(l), d.color.setHex(l)), t)for (r = 0; 4 > r; r++)l = g[a++], l = v[l], 2 !== r && h.vertexColors.push(new THREE.Color(l)), 0 !== r && d.vertexColors.push(new THREE.Color(l));
			n.faces.push(h), n.faces.push(d)
		} else {
			if (h = new THREE.Face3, h.a = g[a++], h.b = g[a++], h.c = g[a++], o && (o = g[a++], h.materialIndex = o), o = n.faces.length, r)for (r = 0; y > r; r++)for (p = e.uvs[r], n.faceVertexUvs[r][o] = [], i = 0; 3 > i; i++)c = g[a++], m = p[2 * c], c = p[2 * c + 1], m = new THREE.Vector2(m, c), n.faceVertexUvs[r][o].push(m);
			if (u && (u = 3 * g[a++], h.normal.set(E[u++], E[u++], E[u])), f)for (r = 0; 3 > r; r++)u = 3 * g[a++], f = new THREE.Vector3(E[u++], E[u++], E[u]), h.vertexNormals.push(f);
			if (l && (l = g[a++], h.color.setHex(v[l])), t)for (r = 0; 3 > r; r++)l = g[a++], h.vertexColors.push(new THREE.Color(v[l]));
			n.faces.push(h)
		}
	}(r), function () {
		var t = void 0 !== e.influencesPerVertex ? e.influencesPerVertex : 2;
		if (e.skinWeights)for (var r = 0, i = e.skinWeights.length; i > r; r += t)n.skinWeights.push(new THREE.Vector4(e.skinWeights[r], t > 1 ? e.skinWeights[r + 1] : 0, t > 2 ? e.skinWeights[r + 2] : 0, t > 3 ? e.skinWeights[r + 3] : 0));
		if (e.skinIndices)for (r = 0, i = e.skinIndices.length; i > r; r += t)n.skinIndices.push(new THREE.Vector4(e.skinIndices[r], t > 1 ? e.skinIndices[r + 1] : 0, t > 2 ? e.skinIndices[r + 2] : 0, t > 3 ? e.skinIndices[r + 3] : 0));
		n.bones = e.bones, n.bones && 0 < n.bones.length && (n.skinWeights.length !== n.skinIndices.length || n.skinIndices.length !== n.vertices.length) && console.warn("When skinning, number of vertices (" + n.vertices.length + "), skinIndices (" + n.skinIndices.length + "), and skinWeights (" + n.skinWeights.length + ") should match."), n.animation = e.animation, n.animations = e.animations
	}(), function (t) {
		if (void 0 !== e.morphTargets) {
			var r, i, o, a, s, l;
			for (r = 0, i = e.morphTargets.length; i > r; r++)for (n.morphTargets[r] = {}, n.morphTargets[r].name = e.morphTargets[r].name, n.morphTargets[r].vertices = [], s = n.morphTargets[r].vertices, l = e.morphTargets[r].vertices, o = 0, a = l.length; a > o; o += 3) {
				var u = new THREE.Vector3;
				u.x = l[o] * t, u.y = l[o + 1] * t, u.z = l[o + 2] * t, s.push(u)
			}
		}
		if (void 0 !== e.morphColors)for (r = 0, i = e.morphColors.length; i > r; r++)for (n.morphColors[r] = {}, n.morphColors[r].name = e.morphColors[r].name, n.morphColors[r].colors = [], a = n.morphColors[r].colors, s = e.morphColors[r].colors, t = 0, o = s.length; o > t; t += 3)l = new THREE.Color(16755200), l.setRGB(s[t], s[t + 1], s[t + 2]), a.push(l)
	}(r), n.computeFaceNormals(), n.computeBoundingSphere(), void 0 === e.materials || 0 === e.materials.length ? {geometry: n} : (r = this.initMaterials(e.materials, t), this.needsTangents(r) && n.computeTangents(), {geometry: n, materials: r})
}, THREE.LoadingManager = function (e, t, n) {
	var r = this, i = 0, o = 0;
	this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function () {
		o++
	}, this.itemEnd = function (e) {
		i++, void 0 !== r.onProgress && r.onProgress(e, i, o), i === o && void 0 !== r.onLoad && r.onLoad()
	}
}, THREE.DefaultLoadingManager = new THREE.LoadingManager, THREE.BufferGeometryLoader = function (e) {
	this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
}, THREE.BufferGeometryLoader.prototype = {constructor: THREE.BufferGeometryLoader, load: function (e, t, n, r) {
	var i = this, o = new THREE.XHRLoader;
	o.setCrossOrigin(this.crossOrigin), o.load(e, function (e) {
		t(i.parse(JSON.parse(e)))
	}, n, r)
}, setCrossOrigin: function (e) {
	this.crossOrigin = e
}, parse: function (e) {
	var t, n = new THREE.BufferGeometry, r = e.attributes;
	for (t in r) {
		var i = r[t];
		n.attributes[t] = {itemSize: i.itemSize, array: new self[i.type](i.array)}
	}
	return r = e.offsets, void 0 !== r && (n.offsets = JSON.parse(JSON.stringify(r))), e = e.boundingSphere, void 0 !== e && (n.boundingSphere = new THREE.Sphere((new THREE.Vector3).fromArray(void 0 !== e.center ? e.center : [0, 0, 0]), e.radius)), n
}}, THREE.MaterialLoader = function (e) {
	this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
}, THREE.MaterialLoader.prototype = {constructor: THREE.MaterialLoader, load: function (e, t, n, r) {
	var i = this, o = new THREE.XHRLoader;
	o.setCrossOrigin(this.crossOrigin), o.load(e, function (e) {
		t(i.parse(JSON.parse(e)))
	}, n, r)
}, setCrossOrigin: function (e) {
	this.crossOrigin = e
}, parse: function (e) {
	var t = new THREE[e.type];
	if (void 0 !== e.color && t.color.setHex(e.color), void 0 !== e.ambient && t.ambient.setHex(e.ambient), void 0 !== e.emissive && t.emissive.setHex(e.emissive), void 0 !== e.specular && t.specular.setHex(e.specular), void 0 !== e.shininess && (t.shininess = e.shininess), void 0 !== e.uniforms && (t.uniforms = e.uniforms), void 0 !== e.vertexShader && (t.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (t.fragmentShader = e.fragmentShader), void 0 !== e.vertexColors && (t.vertexColors = e.vertexColors), void 0 !== e.blending && (t.blending = e.blending), void 0 !== e.side && (t.side = e.side), void 0 !== e.opacity && (t.opacity = e.opacity), void 0 !== e.transparent && (t.transparent = e.transparent), void 0 !== e.wireframe && (t.wireframe = e.wireframe), void 0 !== e.materials)for (var n = 0, r = e.materials.length; r > n; n++)t.materials.push(this.parse(e.materials[n]));
	return t
}}, THREE.ObjectLoader = function (e) {
	this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
}, THREE.ObjectLoader.prototype = {constructor: THREE.ObjectLoader, load: function (e, t, n, r) {
	var i = this, o = new THREE.XHRLoader(i.manager);
	o.setCrossOrigin(this.crossOrigin), o.load(e, function (e) {
		t(i.parse(JSON.parse(e)))
	}, n, r)
}, setCrossOrigin: function (e) {
	this.crossOrigin = e
}, parse: function (e) {
	var t = this.parseGeometries(e.geometries), n = this.parseMaterials(e.materials);
	return this.parseObject(e.object, t, n)
}, parseGeometries: function (e) {
	var t = {};
	if (void 0 !== e)for (var n = new THREE.JSONLoader, r = new THREE.BufferGeometryLoader, i = 0, o = e.length; o > i; i++) {
		var a, s = e[i];
		switch (s.type) {
			case"PlaneGeometry":
				a = new THREE.PlaneGeometry(s.width, s.height, s.widthSegments, s.heightSegments);
				break;
			case"BoxGeometry":
			case"CubeGeometry":
				a = new THREE.BoxGeometry(s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
				break;
			case"CircleGeometry":
				a = new THREE.CircleGeometry(s.radius, s.segments);
				break;
			case"CylinderGeometry":
				a = new THREE.CylinderGeometry(s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded);
				break;
			case"SphereGeometry":
				a = new THREE.SphereGeometry(s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
				break;
			case"IcosahedronGeometry":
				a = new THREE.IcosahedronGeometry(s.radius, s.detail);
				break;
			case"TorusGeometry":
				a = new THREE.TorusGeometry(s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
				break;
			case"TorusKnotGeometry":
				a = new THREE.TorusKnotGeometry(s.radius, s.tube, s.radialSegments, s.tubularSegments, s.p, s.q, s.heightScale);
				break;
			case"BufferGeometry":
				a = r.parse(s.data);
				break;
			case"Geometry":
				a = n.parse(s.data).geometry
		}
		a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), t[s.uuid] = a
	}
	return t
}, parseMaterials: function (e) {
	var t = {};
	if (void 0 !== e)for (var n = new THREE.MaterialLoader, r = 0, i = e.length; i > r; r++) {
		var o = e[r], a = n.parse(o);
		a.uuid = o.uuid, void 0 !== o.name && (a.name = o.name), t[o.uuid] = a
	}
	return t
}, parseObject: function () {
	var e = new THREE.Matrix4;
	return function (t, n, r) {
		var i;
		switch (t.type) {
			case"Scene":
				i = new THREE.Scene;
				break;
			case"PerspectiveCamera":
				i = new THREE.PerspectiveCamera(t.fov, t.aspect, t.near, t.far);
				break;
			case"OrthographicCamera":
				i = new THREE.OrthographicCamera(t.left, t.right, t.top, t.bottom, t.near, t.far);
				break;
			case"AmbientLight":
				i = new THREE.AmbientLight(t.color);
				break;
			case"DirectionalLight":
				i = new THREE.DirectionalLight(t.color, t.intensity);
				break;
			case"PointLight":
				i = new THREE.PointLight(t.color, t.intensity, t.distance);
				break;
			case"SpotLight":
				i = new THREE.SpotLight(t.color, t.intensity, t.distance, t.angle, t.exponent);
				break;
			case"HemisphereLight":
				i = new THREE.HemisphereLight(t.color, t.groundColor, t.intensity);
				break;
			case"Mesh":
				i = n[t.geometry];
				var o = r[t.material];
				void 0 === i && console.error("THREE.ObjectLoader: Undefined geometry " + t.geometry), void 0 === o && console.error("THREE.ObjectLoader: Undefined material " + t.material), i = new THREE.Mesh(i, o);
				break;
			case"Sprite":
				o = r[t.material], void 0 === o && console.error("THREE.ObjectLoader: Undefined material " + t.material), i = new THREE.Sprite(o);
				break;
			default:
				i = new THREE.Object3D
		}
		if (i.uuid = t.uuid, void 0 !== t.name && (i.name = t.name), void 0 !== t.matrix ? (e.fromArray(t.matrix), e.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== t.position && i.position.fromArray(t.position), void 0 !== t.rotation && i.rotation.fromArray(t.rotation), void 0 !== t.scale && i.scale.fromArray(t.scale)), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.children)for (var a in t.children)i.add(this.parseObject(t.children[a], n, r));
		return i
	}
}()}, THREE.TextureLoader = function (e) {
	this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
}, THREE.TextureLoader.prototype = {constructor: THREE.TextureLoader, load: function (e, t, n, r) {
	var i = new THREE.ImageLoader(this.manager);
	i.setCrossOrigin(this.crossOrigin), i.load(e, function (e) {
		e = new THREE.Texture(e), e.needsUpdate = !0, void 0 !== t && t(e)
	}, n, r)
}, setCrossOrigin: function (e) {
	this.crossOrigin = e
}}, THREE.Material = function () {
	this.id = THREE.MaterialIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.side = THREE.FrontSide, this.opacity = 1, this.transparent = !1, this.blending = THREE.NormalBlending, this.blendSrc = THREE.SrcAlphaFactor, this.blendDst = THREE.OneMinusSrcAlphaFactor, this.blendEquation = THREE.AddEquation, this.depthWrite = this.depthTest = !0, this.polygonOffset = !1, this.overdraw = this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.needsUpdate = this.visible = !0
}, THREE.Material.prototype = {constructor: THREE.Material, setValues: function (e) {
	if (void 0 !== e)for (var t in e) {
		var n = e[t];
		if (void 0 === n)console.warn("THREE.Material: '" + t + "' parameter is undefined."); else if (t in this) {
			var r = this[t];
			r instanceof THREE.Color ? r.set(n) : r instanceof THREE.Vector3 && n instanceof THREE.Vector3 ? r.copy(n) : this[t] = "overdraw" == t ? Number(n) : n
		}
	}
}, clone: function (e) {
	return void 0 === e && (e = new THREE.Material), e.name = this.name, e.side = this.side, e.opacity = this.opacity, e.transparent = this.transparent, e.blending = this.blending, e.blendSrc = this.blendSrc, e.blendDst = this.blendDst, e.blendEquation = this.blendEquation, e.depthTest = this.depthTest, e.depthWrite = this.depthWrite, e.polygonOffset = this.polygonOffset, e.polygonOffsetFactor = this.polygonOffsetFactor, e.polygonOffsetUnits = this.polygonOffsetUnits, e.alphaTest = this.alphaTest, e.overdraw = this.overdraw, e.visible = this.visible, e
}, dispose: function () {
	this.dispatchEvent({type: "dispose"})
}}, THREE.EventDispatcher.prototype.apply(THREE.Material.prototype), THREE.MaterialIdCount = 0, THREE.LineBasicMaterial = function (e) {
	THREE.Material.call(this), this.color = new THREE.Color(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.vertexColors = THREE.NoColors, this.fog = !0, this.setValues(e)
}, THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype), THREE.LineBasicMaterial.prototype.clone = function () {
	var e = new THREE.LineBasicMaterial;
	return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.linewidth = this.linewidth, e.linecap = this.linecap, e.linejoin = this.linejoin, e.vertexColors = this.vertexColors, e.fog = this.fog, e
}, THREE.LineDashedMaterial = function (e) {
	THREE.Material.call(this), this.color = new THREE.Color(16777215), this.scale = this.linewidth = 1, this.dashSize = 3, this.gapSize = 1, this.vertexColors = !1, this.fog = !0, this.setValues(e)
}, THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype), THREE.LineDashedMaterial.prototype.clone = function () {
	var e = new THREE.LineDashedMaterial;
	return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.linewidth = this.linewidth, e.scale = this.scale, e.dashSize = this.dashSize, e.gapSize = this.gapSize, e.vertexColors = this.vertexColors, e.fog = this.fog, e
}, THREE.MeshBasicMaterial = function (e) {
	THREE.Material.call(this), this.color = new THREE.Color(16777215), this.envMap = this.alphaMap = this.specularMap = this.lightMap = this.map = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexColors = THREE.NoColors, this.morphTargets = this.skinning = !1, this.setValues(e)
}, THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshBasicMaterial.prototype.clone = function () {
	var e = new THREE.MeshBasicMaterial;
	return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.map = this.map, e.lightMap = this.lightMap, e.specularMap = this.specularMap, e.alphaMap = this.alphaMap, e.envMap = this.envMap, e.combine = this.combine, e.reflectivity = this.reflectivity, e.refractionRatio = this.refractionRatio, e.fog = this.fog, e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.wireframeLinecap = this.wireframeLinecap, e.wireframeLinejoin = this.wireframeLinejoin, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e
}, THREE.MeshLambertMaterial = function (e) {
	THREE.Material.call(this), this.color = new THREE.Color(16777215), this.ambient = new THREE.Color(16777215), this.emissive = new THREE.Color(0), this.wrapAround = !1, this.wrapRGB = new THREE.Vector3(1, 1, 1), this.envMap = this.alphaMap = this.specularMap = this.lightMap = this.map = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexColors = THREE.NoColors, this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
}, THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshLambertMaterial.prototype.clone = function () {
	var e = new THREE.MeshLambertMaterial;
	return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.ambient.copy(this.ambient), e.emissive.copy(this.emissive), e.wrapAround = this.wrapAround, e.wrapRGB.copy(this.wrapRGB), e.map = this.map, e.lightMap = this.lightMap, e.specularMap = this.specularMap, e.alphaMap = this.alphaMap, e.envMap = this.envMap, e.combine = this.combine, e.reflectivity = this.reflectivity, e.refractionRatio = this.refractionRatio, e.fog = this.fog, e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.wireframeLinecap = this.wireframeLinecap, e.wireframeLinejoin = this.wireframeLinejoin, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e.morphNormals = this.morphNormals, e
}, THREE.MeshPhongMaterial = function (e) {
	THREE.Material.call(this), this.color = new THREE.Color(16777215), this.ambient = new THREE.Color(16777215), this.emissive = new THREE.Color(0), this.specular = new THREE.Color(1118481), this.shininess = 30, this.wrapAround = this.metal = !1, this.wrapRGB = new THREE.Vector3(1, 1, 1), this.bumpMap = this.lightMap = this.map = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new THREE.Vector2(1, 1), this.envMap = this.alphaMap = this.specularMap = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexColors = THREE.NoColors, this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
}, THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshPhongMaterial.prototype.clone = function () {
	var e = new THREE.MeshPhongMaterial;
	return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.ambient.copy(this.ambient), e.emissive.copy(this.emissive), e.specular.copy(this.specular), e.shininess = this.shininess, e.metal = this.metal, e.wrapAround = this.wrapAround, e.wrapRGB.copy(this.wrapRGB), e.map = this.map, e.lightMap = this.lightMap, e.bumpMap = this.bumpMap, e.bumpScale = this.bumpScale, e.normalMap = this.normalMap, e.normalScale.copy(this.normalScale), e.specularMap = this.specularMap, e.alphaMap = this.alphaMap, e.envMap = this.envMap, e.combine = this.combine, e.reflectivity = this.reflectivity, e.refractionRatio = this.refractionRatio, e.fog = this.fog, e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.wireframeLinecap = this.wireframeLinecap, e.wireframeLinejoin = this.wireframeLinejoin, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e.morphNormals = this.morphNormals, e
}, THREE.MeshDepthMaterial = function (e) {
	THREE.Material.call(this), this.wireframe = this.morphTargets = !1, this.wireframeLinewidth = 1, this.setValues(e)
}, THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshDepthMaterial.prototype.clone = function () {
	var e = new THREE.MeshDepthMaterial;
	return THREE.Material.prototype.clone.call(this, e), e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e
}, THREE.MeshNormalMaterial = function (e) {
	THREE.Material.call(this, e), this.shading = THREE.FlatShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphTargets = !1, this.setValues(e)
}, THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshNormalMaterial.prototype.clone = function () {
	var e = new THREE.MeshNormalMaterial;
	return THREE.Material.prototype.clone.call(this, e), e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e
}, THREE.MeshFaceMaterial = function (e) {
	this.materials = e instanceof Array ? e : []
}, THREE.MeshFaceMaterial.prototype.clone = function () {
	for (var e = new THREE.MeshFaceMaterial, t = 0; t < this.materials.length; t++)e.materials.push(this.materials[t].clone());
	return e
}, THREE.PointCloudMaterial = function (e) {
	THREE.Material.call(this), this.color = new THREE.Color(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.vertexColors = THREE.NoColors, this.fog = !0, this.setValues(e)
}, THREE.PointCloudMaterial.prototype = Object.create(THREE.Material.prototype), THREE.PointCloudMaterial.prototype.clone = function () {
	var e = new THREE.PointCloudMaterial;
	return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.map = this.map, e.size = this.size, e.sizeAttenuation = this.sizeAttenuation, e.vertexColors = this.vertexColors, e.fog = this.fog, e
}, THREE.ParticleBasicMaterial = function (e) {
	return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial."), new THREE.PointCloudMaterial(e)
}, THREE.ParticleSystemMaterial = function (e) {
	return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial."), new THREE.PointCloudMaterial(e)
}, THREE.ShaderMaterial = function (e) {
	THREE.Material.call(this), this.defines = {}, this.uniforms = {}, this.attributes = null, this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.shading = THREE.SmoothShading, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.lights = this.fog = !1, this.vertexColors = THREE.NoColors, this.morphNormals = this.morphTargets = this.skinning = !1, this.defaultAttributeValues = {color: [1, 1, 1], uv: [0, 0], uv2: [0, 0]}, this.index0AttributeName = void 0, this.setValues(e)
}, THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype), THREE.ShaderMaterial.prototype.clone = function () {
	var e = new THREE.ShaderMaterial;
	return THREE.Material.prototype.clone.call(this, e), e.fragmentShader = this.fragmentShader, e.vertexShader = this.vertexShader, e.uniforms = THREE.UniformsUtils.clone(this.uniforms), e.attributes = this.attributes, e.defines = this.defines, e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.fog = this.fog, e.lights = this.lights, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e.morphNormals = this.morphNormals, e
}, THREE.RawShaderMaterial = function (e) {
	THREE.ShaderMaterial.call(this, e)
}, THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype), THREE.RawShaderMaterial.prototype.clone = function () {
	var e = new THREE.RawShaderMaterial;
	return THREE.ShaderMaterial.prototype.clone.call(this, e), e
}, THREE.SpriteMaterial = function (e) {
	THREE.Material.call(this), this.color = new THREE.Color(16777215), this.map = null, this.rotation = 0, this.fog = !1, this.setValues(e)
}, THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype), THREE.SpriteMaterial.prototype.clone = function () {
	var e = new THREE.SpriteMaterial;
	return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.map = this.map, e.rotation = this.rotation, e.fog = this.fog, e
}, THREE.SpriteCanvasMaterial = function (e) {
	THREE.Material.call(this), this.color = new THREE.Color(16777215), this.program = function () {
	}, this.setValues(e)
}, THREE.SpriteCanvasMaterial.prototype = Object.create(THREE.Material.prototype), THREE.SpriteCanvasMaterial.prototype.clone = function () {
	var e = new THREE.SpriteCanvasMaterial;
	return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.program = this.program, e
}, THREE.ParticleCanvasMaterial = THREE.SpriteCanvasMaterial, THREE.Texture = function (e, t, n, r, i, o, a, s, l) {
	this.id = THREE.TextureIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.image = void 0 !== e ? e : THREE.Texture.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : THREE.Texture.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : THREE.ClampToEdgeWrapping, this.wrapT = void 0 !== r ? r : THREE.ClampToEdgeWrapping, this.magFilter = void 0 !== i ? i : THREE.LinearFilter, this.minFilter = void 0 !== o ? o : THREE.LinearMipMapLinearFilter, this.anisotropy = void 0 !== l ? l : 1, this.format = void 0 !== a ? a : THREE.RGBAFormat, this.type = void 0 !== s ? s : THREE.UnsignedByteType, this.offset = new THREE.Vector2(0, 0), this.repeat = new THREE.Vector2(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this._needsUpdate = !1, this.onUpdate = null
}, THREE.Texture.DEFAULT_IMAGE = void 0, THREE.Texture.DEFAULT_MAPPING = new THREE.UVMapping, THREE.Texture.prototype = {constructor: THREE.Texture, get needsUpdate() {
	return this._needsUpdate
}, set needsUpdate(e) {
	!0 === e && this.update(), this._needsUpdate = e
}, clone: function (e) {
	return void 0 === e && (e = new THREE.Texture), e.image = this.image, e.mipmaps = this.mipmaps.slice(0), e.mapping = this.mapping, e.wrapS = this.wrapS, e.wrapT = this.wrapT, e.magFilter = this.magFilter, e.minFilter = this.minFilter, e.anisotropy = this.anisotropy, e.format = this.format, e.type = this.type, e.offset.copy(this.offset), e.repeat.copy(this.repeat), e.generateMipmaps = this.generateMipmaps, e.premultiplyAlpha = this.premultiplyAlpha, e.flipY = this.flipY, e.unpackAlignment = this.unpackAlignment, e
}, update: function () {
	this.dispatchEvent({type: "update"})
}, dispose: function () {
	this.dispatchEvent({type: "dispose"})
}}, THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype), THREE.TextureIdCount = 0, THREE.CubeTexture = function (e, t, n, r, i, o, a, s, l) {
	THREE.Texture.call(this, e, t, n, r, i, o, a, s, l), this.images = e
}, THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CubeTexture.clone = function (e) {
	return void 0 === e && (e = new THREE.CubeTexture), THREE.Texture.prototype.clone.call(this, e), e.images = this.images, e
}, THREE.CompressedTexture = function (e, t, n, r, i, o, a, s, l, u, c) {
	THREE.Texture.call(this, null, o, a, s, l, u, r, i, c), this.image = {width: t, height: n}, this.mipmaps = e, this.generateMipmaps = !1
}, THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CompressedTexture.prototype.clone = function () {
	var e = new THREE.CompressedTexture;
	return THREE.Texture.prototype.clone.call(this, e), e
}, THREE.DataTexture = function (e, t, n, r, i, o, a, s, l, u, c) {
	THREE.Texture.call(this, null, o, a, s, l, u, r, i, c), this.image = {data: e, width: t, height: n}
}, THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype), THREE.DataTexture.prototype.clone = function () {
	var e = new THREE.DataTexture;
	return THREE.Texture.prototype.clone.call(this, e), e
}, THREE.PointCloud = function (e, t) {
	THREE.Object3D.call(this), this.geometry = void 0 !== e ? e : new THREE.Geometry, this.material = void 0 !== t ? t : new THREE.PointCloudMaterial({color: 16777215 * Math.random()}), this.sortParticles = !1
}, THREE.PointCloud.prototype = Object.create(THREE.Object3D.prototype), THREE.PointCloud.prototype.raycast = function () {
	var e = new THREE.Matrix4, t = new THREE.Ray;
	return function (n, r) {
		var i = this, o = i.geometry, a = n.params.PointCloud.threshold;
		if (e.getInverse(this.matrixWorld), t.copy(n.ray).applyMatrix4(e), null === o.boundingBox || !1 !== t.isIntersectionBox(o.boundingBox)) {
			var s = a / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = new THREE.Vector3, a = function (e, o) {
				var a = t.distanceToPoint(e);
				if (s > a) {
					var l = t.closestPointToPoint(e);
					l.applyMatrix4(i.matrixWorld);
					var u = n.ray.origin.distanceTo(l);
					r.push({distance: u, distanceToRay: a, point: l.clone(), index: o, face: null, object: i})
				}
			};
			if (o instanceof THREE.BufferGeometry) {
				var u = o.attributes, c = u.position.array;
				if (void 0 !== u.index) {
					var u = u.index.array, h = o.offsets;
					0 === h.length && (h = [
						{start: 0, count: u.length, index: 0}
					]);
					for (var f = 0, d = h.length; d > f; ++f)for (var p = h[f].start, m = h[f].index, o = p, p = p + h[f].count; p > o; o++) {
						var g = m + u[o];
						l.set(c[3 * g], c[3 * g + 1], c[3 * g + 2]), a(l, g)
					}
				} else for (u = c.length / 3, o = 0; u > o; o++)l.set(c[3 * o], c[3 * o + 1], c[3 * o + 2]), a(l, o)
			} else for (l = this.geometry.vertices, o = 0; o < l.length; o++)a(l[o], o)
		}
	}
}(), THREE.PointCloud.prototype.clone = function (e) {
	return void 0 === e && (e = new THREE.PointCloud(this.geometry, this.material)), e.sortParticles = this.sortParticles, THREE.Object3D.prototype.clone.call(this, e), e
}, THREE.ParticleSystem = function (e, t) {
	return console.warn("THREE.ParticleSystem has been renamed to THREE.PointCloud."), new THREE.PointCloud(e, t)
}, THREE.Line = function (e, t, n) {
	THREE.Object3D.call(this), this.geometry = void 0 !== e ? e : new THREE.Geometry, this.material = void 0 !== t ? t : new THREE.LineBasicMaterial({color: 16777215 * Math.random()}), this.type = void 0 !== n ? n : THREE.LineStrip
}, THREE.LineStrip = 0, THREE.LinePieces = 1, THREE.Line.prototype = Object.create(THREE.Object3D.prototype), THREE.Line.prototype.raycast = function () {
	var e = new THREE.Matrix4, t = new THREE.Ray, n = new THREE.Sphere;
	return function (r, i) {
		var o = r.linePrecision, o = o * o, a = this.geometry;
		if (null === a.boundingSphere && a.computeBoundingSphere(), n.copy(a.boundingSphere), n.applyMatrix4(this.matrixWorld), !1 !== r.ray.isIntersectionSphere(n) && (e.getInverse(this.matrixWorld), t.copy(r.ray).applyMatrix4(e), a instanceof THREE.Geometry))for (var a = a.vertices, s = a.length, l = new THREE.Vector3, u = new THREE.Vector3, c = this.type === THREE.LineStrip ? 1 : 2, h = 0; s - 1 > h; h += c)if (!(t.distanceSqToSegment(a[h], a[h + 1], u, l) > o)) {
			var f = t.origin.distanceTo(u);
			f < r.near || f > r.far || i.push({distance: f, point: l.clone().applyMatrix4(this.matrixWorld), face: null, faceIndex: null, object: this})
		}
	}
}(), THREE.Line.prototype.clone = function (e) {
	return void 0 === e && (e = new THREE.Line(this.geometry, this.material, this.type)), THREE.Object3D.prototype.clone.call(this, e), e
}, THREE.Mesh = function (e, t) {
	THREE.Object3D.call(this), this.geometry = void 0 !== e ? e : new THREE.Geometry, this.material = void 0 !== t ? t : new THREE.MeshBasicMaterial({color: 16777215 * Math.random()}), this.updateMorphTargets()
}, THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype), THREE.Mesh.prototype.updateMorphTargets = function () {
	if (void 0 !== this.geometry.morphTargets && 0 < this.geometry.morphTargets.length) {
		this.morphTargetBase = -1, this.morphTargetForcedOrder = [], this.morphTargetInfluences = [], this.morphTargetDictionary = {};
		for (var e = 0, t = this.geometry.morphTargets.length; t > e; e++)this.morphTargetInfluences.push(0), this.morphTargetDictionary[this.geometry.morphTargets[e].name] = e
	}
}, THREE.Mesh.prototype.getMorphTargetIndexByName = function (e) {
	return void 0 !== this.morphTargetDictionary[e] ? this.morphTargetDictionary[e] : (console.log("THREE.Mesh.getMorphTargetIndexByName: morph target " + e + " does not exist. Returning 0."), 0)
}, THREE.Mesh.prototype.raycast = function () {
	var e = new THREE.Matrix4, t = new THREE.Ray, n = new THREE.Sphere, r = new THREE.Vector3, i = new THREE.Vector3, o = new THREE.Vector3;
	return function (a, s) {
		var l = this.geometry;
		if (null === l.boundingSphere && l.computeBoundingSphere(), n.copy(l.boundingSphere), n.applyMatrix4(this.matrixWorld), !1 !== a.ray.isIntersectionSphere(n) && (e.getInverse(this.matrixWorld), t.copy(a.ray).applyMatrix4(e), null === l.boundingBox || !1 !== t.isIntersectionBox(l.boundingBox)))if (l instanceof THREE.BufferGeometry) {
			var u = this.material;
			if (void 0 !== u) {
				var c, h, f = l.attributes, d = a.precision;
				if (void 0 !== f.index) {
					var p = f.index.array, m = f.position.array, g = l.offsets;
					0 === g.length && (g = [
						{start: 0, count: p.length, index: 0}
					]);
					for (var E = 0, v = g.length; v > E; ++E)for (var f = g[E].start, y = g[E].index, l = f, T = f + g[E].count; T > l; l += 3) {
						f = y + p[l], c = y + p[l + 1], h = y + p[l + 2], r.set(m[3 * f], m[3 * f + 1], m[3 * f + 2]), i.set(m[3 * c], m[3 * c + 1], m[3 * c + 2]), o.set(m[3 * h], m[3 * h + 1], m[3 * h + 2]);
						var x = u.side === THREE.BackSide ? t.intersectTriangle(o, i, r, !0) : t.intersectTriangle(r, i, o, u.side !== THREE.DoubleSide);
						if (null !== x) {
							x.applyMatrix4(this.matrixWorld);
							var R = a.ray.origin.distanceTo(x);
							d > R || R < a.near || R > a.far || s.push({distance: R, point: x, indices: [f, c, h], face: null, faceIndex: null, object: this})
						}
					}
				} else for (m = f.position.array, p = l = 0, T = m.length; T > l; l += 3, p += 9)f = l, c = l + 1, h = l + 2, r.set(m[p], m[p + 1], m[p + 2]), i.set(m[p + 3], m[p + 4], m[p + 5]), o.set(m[p + 6], m[p + 7], m[p + 8]), x = u.side === THREE.BackSide ? t.intersectTriangle(o, i, r, !0) : t.intersectTriangle(r, i, o, u.side !== THREE.DoubleSide), null !== x && (x.applyMatrix4(this.matrixWorld), R = a.ray.origin.distanceTo(x), d > R || R < a.near || R > a.far || s.push({distance: R, point: x, indices: [f, c, h], face: null, faceIndex: null, object: this}))
			}
		} else if (l instanceof THREE.Geometry)for (p = this.material instanceof THREE.MeshFaceMaterial, m = !0 === p ? this.material.materials : null, d = a.precision, g = l.vertices, E = 0, v = l.faces.length; v > E; E++)if (y = l.faces[E], u = !0 === p ? m[y.materialIndex] : this.material, void 0 !== u) {
			if (f = g[y.a], c = g[y.b], h = g[y.c], !0 === u.morphTargets) {
				x = l.morphTargets, R = this.morphTargetInfluences, r.set(0, 0, 0), i.set(0, 0, 0), o.set(0, 0, 0);
				for (var T = 0, b = x.length; b > T; T++) {
					var _ = R[T];
					if (0 !== _) {
						var w = x[T].vertices;
						r.x += (w[y.a].x - f.x) * _, r.y += (w[y.a].y - f.y) * _, r.z += (w[y.a].z - f.z) * _, i.x += (w[y.b].x - c.x) * _, i.y += (w[y.b].y - c.y) * _, i.z += (w[y.b].z - c.z) * _, o.x += (w[y.c].x - h.x) * _, o.y += (w[y.c].y - h.y) * _, o.z += (w[y.c].z - h.z) * _
					}
				}
				r.add(f), i.add(c), o.add(h), f = r, c = i, h = o
			}
			x = u.side === THREE.BackSide ? t.intersectTriangle(h, c, f, !0) : t.intersectTriangle(f, c, h, u.side !== THREE.DoubleSide), null !== x && (x.applyMatrix4(this.matrixWorld), R = a.ray.origin.distanceTo(x), d > R || R < a.near || R > a.far || s.push({distance: R, point: x, face: y, faceIndex: E, object: this}))
		}
	}
}(), THREE.Mesh.prototype.clone = function (e, t) {
	return void 0 === e && (e = new THREE.Mesh(this.geometry, this.material)), THREE.Object3D.prototype.clone.call(this, e, t), e
}, THREE.Bone = function (e) {
	THREE.Object3D.call(this), this.skin = e, this.accumulatedSclWeight = this.accumulatedPosWeight = this.accumulatedRotWeight = 0
}, THREE.Bone.prototype = Object.create(THREE.Object3D.prototype), THREE.Bone.prototype.updateMatrixWorld = function (e) {
	THREE.Object3D.prototype.updateMatrixWorld.call(this, e), this.accumulatedSclWeight = this.accumulatedPosWeight = this.accumulatedRotWeight = 0
}, THREE.Skeleton = function (e, t, n) {
	if (this.useVertexTexture = void 0 !== n ? n : !0, this.identityMatrix = new THREE.Matrix4, e = e || [], this.bones = e.slice(0), this.useVertexTexture ? (this.boneTextureHeight = this.boneTextureWidth = e = 256 < this.bones.length ? 64 : 64 < this.bones.length ? 32 : 16 < this.bones.length ? 16 : 8, this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType), this.boneTexture.minFilter = THREE.NearestFilter, this.boneTexture.magFilter = THREE.NearestFilter, this.boneTexture.generateMipmaps = !1, this.boneTexture.flipY = !1) : this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === t)this.calculateInverses(); else if (this.bones.length === t.length)this.boneInverses = t.slice(0); else for (console.warn("THREE.Skeleton bonInverses is the wrong length."), this.boneInverses = [], t = 0, e = this.bones.length; e > t; t++)this.boneInverses.push(new THREE.Matrix4)
}, THREE.Skeleton.prototype.calculateInverses = function () {
	this.boneInverses = [];
	for (var e = 0, t = this.bones.length; t > e; e++) {
		var n = new THREE.Matrix4;
		this.bones[e] && n.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(n)
	}
}, THREE.Skeleton.prototype.pose = function () {
	for (var e, t = 0, n = this.bones.length; n > t; t++)(e = this.bones[t]) && e.matrixWorld.getInverse(this.boneInverses[t]);
	for (t = 0, n = this.bones.length; n > t; t++)(e = this.bones[t]) && (e.parent ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
}, THREE.Skeleton.prototype.update = function () {
	for (var e = new THREE.Matrix4, t = 0, n = this.bones.length; n > t; t++)e.multiplyMatrices(this.bones[t] ? this.bones[t].matrixWorld : this.identityMatrix, this.boneInverses[t]), e.flattenToArrayOffset(this.boneMatrices, 16 * t);
	this.useVertexTexture && (this.boneTexture.needsUpdate = !0)
}, THREE.SkinnedMesh = function (e, t, n) {
	if (THREE.Mesh.call(this, e, t), this.bindMode = "attached", this.bindMatrix = new THREE.Matrix4, this.bindMatrixInverse = new THREE.Matrix4, e = [], this.geometry && void 0 !== this.geometry.bones) {
		for (var r, i, o, a, s = 0, l = this.geometry.bones.length; l > s; ++s)r = this.geometry.bones[s], i = r.pos, o = r.rotq, a = r.scl, t = new THREE.Bone(this), e.push(t), t.name = r.name, t.position.set(i[0], i[1], i[2]), t.quaternion.set(o[0], o[1], o[2], o[3]), void 0 !== a ? t.scale.set(a[0], a[1], a[2]) : t.scale.set(1, 1, 1);
		for (s = 0, l = this.geometry.bones.length; l > s; ++s)r = this.geometry.bones[s], -1 !== r.parent ? e[r.parent].add(e[s]) : this.add(e[s])
	}
	this.normalizeSkinWeights(), this.updateMatrixWorld(!0), this.bind(new THREE.Skeleton(e, void 0, n))
}, THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.SkinnedMesh.prototype.bind = function (e, t) {
	this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t)
}, THREE.SkinnedMesh.prototype.pose = function () {
	this.skeleton.pose()
}, THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {
	if (this.geometry instanceof THREE.Geometry)for (var e = 0; e < this.geometry.skinIndices.length; e++) {
		var t = this.geometry.skinWeights[e], n = 1 / t.lengthManhattan();
		1 / 0 !== n ? t.multiplyScalar(n) : t.set(1)
	}
}, THREE.SkinnedMesh.prototype.updateMatrixWorld = function () {
	THREE.Mesh.prototype.updateMatrixWorld.call(this, !0), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh unreckognized bindMode: " + this.bindMode)
}, THREE.SkinnedMesh.prototype.clone = function (e) {
	return void 0 === e && (e = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture)), THREE.Mesh.prototype.clone.call(this, e), e
}, THREE.MorphAnimMesh = function (e, t) {
	THREE.Mesh.call(this, e, t), this.duration = 1e3, this.mirroredLoop = !1, this.currentKeyframe = this.lastKeyframe = this.time = 0, this.direction = 1, this.directionBackwards = !1, this.setFrameRange(0, this.geometry.morphTargets.length - 1)
}, THREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.MorphAnimMesh.prototype.setFrameRange = function (e, t) {
	this.startKeyframe = e, this.endKeyframe = t, this.length = this.endKeyframe - this.startKeyframe + 1
}, THREE.MorphAnimMesh.prototype.setDirectionForward = function () {
	this.direction = 1, this.directionBackwards = !1
}, THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {
	this.direction = -1, this.directionBackwards = !0
}, THREE.MorphAnimMesh.prototype.parseAnimations = function () {
	var e = this.geometry;
	e.animations || (e.animations = {});
	for (var t, n = e.animations, r = /([a-z]+)_?(\d+)/, i = 0, o = e.morphTargets.length; o > i; i++) {
		var a = e.morphTargets[i].name.match(r);
		if (a && 1 < a.length) {
			a = a[1], n[a] || (n[a] = {start: 1 / 0, end: -1 / 0});
			var s = n[a];
			i < s.start && (s.start = i), i > s.end && (s.end = i), t || (t = a)
		}
	}
	e.firstAnimation = t
}, THREE.MorphAnimMesh.prototype.setAnimationLabel = function (e, t, n) {
	this.geometry.animations || (this.geometry.animations = {}), this.geometry.animations[e] = {start: t, end: n}
}, THREE.MorphAnimMesh.prototype.playAnimation = function (e, t) {
	var n = this.geometry.animations[e];
	n ? (this.setFrameRange(n.start, n.end), this.duration = (n.end - n.start) / t * 1e3, this.time = 0) : console.warn("animation[" + e + "] undefined")
}, THREE.MorphAnimMesh.prototype.updateAnimation = function (e) {
	var t = this.duration / this.length;
	this.time += this.direction * e, this.mirroredLoop ? (this.time > this.duration || 0 > this.time) && (this.direction *= -1, this.time > this.duration && (this.time = this.duration, this.directionBackwards = !0), 0 > this.time && (this.time = 0, this.directionBackwards = !1)) : (this.time %= this.duration, 0 > this.time && (this.time += this.duration)), e = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / t), 0, this.length - 1), e !== this.currentKeyframe && (this.morphTargetInfluences[this.lastKeyframe] = 0, this.morphTargetInfluences[this.currentKeyframe] = 1, this.morphTargetInfluences[e] = 0, this.lastKeyframe = this.currentKeyframe, this.currentKeyframe = e), t = this.time % t / t, this.directionBackwards && (t = 1 - t), this.morphTargetInfluences[this.currentKeyframe] = t, this.morphTargetInfluences[this.lastKeyframe] = 1 - t
}, THREE.MorphAnimMesh.prototype.interpolateTargets = function (e, t, n) {
	for (var r = this.morphTargetInfluences, i = 0, o = r.length; o > i; i++)r[i] = 0;
	e > -1 && (r[e] = 1 - n), t > -1 && (r[t] = n)
}, THREE.MorphAnimMesh.prototype.clone = function (e) {
	return void 0 === e && (e = new THREE.MorphAnimMesh(this.geometry, this.material)), e.duration = this.duration, e.mirroredLoop = this.mirroredLoop, e.time = this.time, e.lastKeyframe = this.lastKeyframe, e.currentKeyframe = this.currentKeyframe, e.direction = this.direction, e.directionBackwards = this.directionBackwards, THREE.Mesh.prototype.clone.call(this, e), e
}, THREE.LOD = function () {
	THREE.Object3D.call(this), this.objects = []
}, THREE.LOD.prototype = Object.create(THREE.Object3D.prototype), THREE.LOD.prototype.addLevel = function (e, t) {
	void 0 === t && (t = 0), t = Math.abs(t);
	for (var n = 0; n < this.objects.length && !(t < this.objects[n].distance); n++);
	this.objects.splice(n, 0, {distance: t, object: e}), this.add(e)
}, THREE.LOD.prototype.getObjectForDistance = function (e) {
	for (var t = 1, n = this.objects.length; n > t && !(e < this.objects[t].distance); t++);
	return this.objects[t - 1].object
}, THREE.LOD.prototype.raycast = function () {
	var e = new THREE.Vector3;
	return function (t, n) {
		e.setFromMatrixPosition(this.matrixWorld);
		var r = t.ray.origin.distanceTo(e);
		this.getObjectForDistance(r).raycast(t, n)
	}
}(), THREE.LOD.prototype.update = function () {
	var e = new THREE.Vector3, t = new THREE.Vector3;
	return function (n) {
		if (1 < this.objects.length) {
			e.setFromMatrixPosition(n.matrixWorld), t.setFromMatrixPosition(this.matrixWorld), n = e.distanceTo(t), this.objects[0].object.visible = !0;
			for (var r = 1, i = this.objects.length; i > r && n >= this.objects[r].distance; r++)this.objects[r - 1].object.visible = !1, this.objects[r].object.visible = !0;
			for (; i > r; r++)this.objects[r].object.visible = !1
		}
	}
}(), THREE.LOD.prototype.clone = function (e) {
	void 0 === e && (e = new THREE.LOD), THREE.Object3D.prototype.clone.call(this, e);
	for (var t = 0, n = this.objects.length; n > t; t++) {
		var r = this.objects[t].object.clone();
		r.visible = 0 === t, e.addLevel(r, this.objects[t].distance)
	}
	return e
}, THREE.Sprite = function () {
	var e = new Float32Array([-.5, -.5, 0, .5, -.5, 0, .5, .5, 0]), t = new THREE.BufferGeometry;
	return t.addAttribute("position", new THREE.BufferAttribute(e, 3)), function (e) {
		THREE.Object3D.call(this), this.geometry = t, this.material = void 0 !== e ? e : new THREE.SpriteMaterial
	}
}(), THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype), THREE.Sprite.prototype.raycast = function () {
	var e = new THREE.Vector3;
	return function (t, n) {
		e.setFromMatrixPosition(this.matrixWorld);
		var r = t.ray.distanceToPoint(e);
		r > this.scale.x || n.push({distance: r, point: this.position, face: null, object: this})
	}
}(), THREE.Sprite.prototype.updateMatrix = function () {
	this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
}, THREE.Sprite.prototype.clone = function (e) {
	return void 0 === e && (e = new THREE.Sprite(this.material)), THREE.Object3D.prototype.clone.call(this, e), e
}, THREE.Particle = THREE.Sprite, THREE.Scene = function () {
	THREE.Object3D.call(this), this.overrideMaterial = this.fog = null, this.autoUpdate = !0, this.matrixAutoUpdate = !1, this.__lights = [], this.__objectsAdded = [], this.__objectsRemoved = []
}, THREE.Scene.prototype = Object.create(THREE.Object3D.prototype), THREE.Scene.prototype.__addObject = function (e) {
	if (e instanceof THREE.Light)-1 === this.__lights.indexOf(e) && this.__lights.push(e), e.target && void 0 === e.target.parent && this.add(e.target); else if (!(e instanceof THREE.Camera || e instanceof THREE.Bone)) {
		this.__objectsAdded.push(e);
		var t = this.__objectsRemoved.indexOf(e);
		-1 !== t && this.__objectsRemoved.splice(t, 1)
	}
	for (this.dispatchEvent({type: "objectAdded", object: e}), e.dispatchEvent({type: "addedToScene", scene: this}), t = 0; t < e.children.length; t++)this.__addObject(e.children[t])
}, THREE.Scene.prototype.__removeObject = function (e) {
	if (e instanceof THREE.Light) {
		var t = this.__lights.indexOf(e);
		if (-1 !== t && this.__lights.splice(t, 1), e.shadowCascadeArray)for (t = 0; t < e.shadowCascadeArray.length; t++)this.__removeObject(e.shadowCascadeArray[t])
	} else e instanceof THREE.Camera || (this.__objectsRemoved.push(e), t = this.__objectsAdded.indexOf(e), -1 !== t && this.__objectsAdded.splice(t, 1));
	for (this.dispatchEvent({type: "objectRemoved", object: e}), e.dispatchEvent({type: "removedFromScene", scene: this}), t = 0; t < e.children.length; t++)this.__removeObject(e.children[t])
}, THREE.Scene.prototype.clone = function (e) {
	return void 0 === e && (e = new THREE.Scene), THREE.Object3D.prototype.clone.call(this, e), null !== this.fog && (e.fog = this.fog.clone()), null !== this.overrideMaterial && (e.overrideMaterial = this.overrideMaterial.clone()), e.autoUpdate = this.autoUpdate, e.matrixAutoUpdate = this.matrixAutoUpdate, e
}, THREE.Fog = function (e, t, n) {
	this.name = "", this.color = new THREE.Color(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== n ? n : 1e3
}, THREE.Fog.prototype.clone = function () {
	return new THREE.Fog(this.color.getHex(), this.near, this.far)
}, THREE.FogExp2 = function (e, t) {
	this.name = "", this.color = new THREE.Color(e), this.density = void 0 !== t ? t : 25e-5
}, THREE.FogExp2.prototype.clone = function () {
	return new THREE.FogExp2(this.color.getHex(), this.density)
}, THREE.CanvasRenderer = function (e) {
	function t(e, t, n, r) {
		u(t), c(n), h(r), f(e.getStyle()), D.stroke(), ht.expandByScalar(2 * t)
	}

	function n(e) {
		d(e.getStyle()), D.fill()
	}

	function r(e) {
		i(e.target)
	}

	function i(e) {
		if (!(e instanceof THREE.CompressedTexture)) {
			var t = e.wrapS === THREE.RepeatWrapping, n = e.wrapT === THREE.RepeatWrapping, r = e.image, i = document.createElement("canvas");
			i.width = r.width, i.height = r.height;
			var o = i.getContext("2d");
			o.setTransform(1, 0, 0, -1, 0, r.height), o.drawImage(r, 0, 0), lt[e.id] = D.createPattern(i, !0 === t && !0 === n ? "repeat" : !0 === t && !1 === n ? "repeat-x" : !1 === t && !0 === n ? "repeat-y" : "no-repeat")
		}
	}

	function o(e, t, n, o, a, s, l, u, c, h, f, p, m) {
		if (!(m instanceof THREE.DataTexture)) {
			!1 === m.hasEventListener("update", r) && (void 0 !== m.image && 0 < m.image.width && i(m), m.addEventListener("update", r));
			var g = lt[m.id];
			if (void 0 !== g) {
				d(g);
				var g = m.offset.x / m.repeat.x, E = m.offset.y / m.repeat.y, v = m.image.width * m.repeat.x;
				m = m.image.height * m.repeat.y, l = (l + g) * v, u = (u + E) * m, n -= e, o -= t, a -= e, s -= t, c = (c + g) * v - l, h = (h + E) * m - u, f = (f + g) * v - l, p = (p + E) * m - u, m = c * p - f * h, 0 !== m && (g = 1 / m, m = (p * n - h * a) * g, h = (p * o - h * s) * g, n = (c * a - f * n) * g, o = (c * s - f * o) * g, e = e - m * l - n * u, t = t - h * l - o * u, D.save(), D.transform(m, h, n, o, e, t), D.fill(), D.restore())
			} else d("rgba(0,0,0,1)"), D.fill()
		}
	}

	function a(e, t, n) {
		var r = t.x - e.x, i = t.y - e.y, o = r * r + i * i;
		0 !== o && (n /= Math.sqrt(o), r *= n, i *= n, t.x += r, t.y += i, e.x -= r, e.y -= i)
	}

	function s(e) {
		z !== e && (z = D.globalAlpha = e)
	}

	function l(e) {
		U !== e && (e === THREE.NormalBlending ? D.globalCompositeOperation = "source-over" : e === THREE.AdditiveBlending ? D.globalCompositeOperation = "lighter" : e === THREE.SubtractiveBlending && (D.globalCompositeOperation = "darker"), U = e)
	}

	function u(e) {
		O !== e && (O = D.lineWidth = e)
	}

	function c(e) {
		I !== e && (I = D.lineCap = e)
	}

	function h(e) {
		j !== e && (j = D.lineJoin = e)
	}

	function f(e) {
		V !== e && (V = D.strokeStyle = e)
	}

	function d(e) {
		B !== e && (B = D.fillStyle = e)
	}

	function p(e) {
		W.length !== e.length && (D.setLineDash(e), W = e)
	}

	console.log("THREE.CanvasRenderer", THREE.REVISION);
	var m = THREE.Math.smoothstep;
	e = e || {};
	var g, E, v, y, T, x, R, b = this, _ = new THREE.Projector, w = void 0 !== e.canvas ? e.canvas : document.createElement("canvas"), H = w.width, M = w.height, S = Math.floor(H / 2), C = Math.floor(M / 2), A = 0, L = 0, k = H, P = M, D = w.getContext("2d", {alpha: !0 === e.alpha}), F = new THREE.Color(0), N = 0, z = 1, U = 0, V = null, B = null, O = null, I = null, j = null, W = [];
	new THREE.RenderableVertex, new THREE.RenderableVertex;
	var G, X, q, Y, K, Z, Q = new THREE.Color;
	new THREE.Color, new THREE.Color, new THREE.Color, new THREE.Color;
	var $, J, et, tt, nt, rt, it, ot = new THREE.Color, at = new THREE.Color, st = new THREE.Color, lt = {}, ut = new THREE.Box2, ct = new THREE.Box2, ht = new THREE.Box2, ft = new THREE.Color, dt = new THREE.Color, pt = new THREE.Color, mt = new THREE.Vector3, gt = new THREE.Vector3, Et = new THREE.Vector3, vt = new THREE.Matrix3;
	void 0 === D.setLineDash && (D.setLineDash = function () {
	}), this.domElement = w, this.devicePixelRatio = void 0 !== e.devicePixelRatio ? e.devicePixelRatio : void 0 !== self.devicePixelRatio ? self.devicePixelRatio : 1, this.sortElements = this.sortObjects = this.autoClear = !0, this.info = {render: {vertices: 0, faces: 0}}, this.supportsVertexTextures = function () {
	}, this.setFaceCulling = function () {
	}, this.setSize = function (e, t, n) {
		H = e * this.devicePixelRatio, M = t * this.devicePixelRatio, w.width = H, w.height = M, S = Math.floor(H / 2), C = Math.floor(M / 2), !1 !== n && (w.style.width = e + "px", w.style.height = t + "px"), ut.min.set(-S, -C), ut.max.set(S, C), ct.min.set(-S, -C), ct.max.set(S, C), z = 1, U = 0, j = I = O = B = V = null, this.setViewport(0, 0, e, t)
	}, this.setViewport = function (e, t, n, r) {
		A = e * this.devicePixelRatio, L = t * this.devicePixelRatio, k = n * this.devicePixelRatio, P = r * this.devicePixelRatio
	}, this.setScissor = function () {
	}, this.enableScissorTest = function () {
	}, this.setClearColor = function (e, t) {
		F.set(e), N = void 0 !== t ? t : 1, ct.min.set(-S, -C), ct.max.set(S, C)
	}, this.setClearColorHex = function (e, t) {
		console.warn("THREE.CanvasRenderer: .setClearColorHex() is being removed. Use .setClearColor() instead."), this.setClearColor(e, t)
	}, this.getClearColor = function () {
		return F
	}, this.getClearAlpha = function () {
		return N
	}, this.getMaxAnisotropy = function () {
		return 0
	}, this.clear = function () {
		!1 === ct.empty() && (ct.intersect(ut), ct.expandByScalar(2), ct.min.x += S, ct.min.y = -ct.min.y + C, ct.max.x += S, ct.max.y = -ct.max.y + C, 1 > N && D.clearRect(0 | ct.min.x, 0 | ct.min.y, ct.max.x - ct.min.x | 0, ct.max.y - ct.min.y | 0), N > 0 && (l(THREE.NormalBlending), s(1), d("rgba(" + Math.floor(255 * F.r) + "," + Math.floor(255 * F.g) + "," + Math.floor(255 * F.b) + "," + N + ")"), D.fillRect(0 | ct.min.x, 0 | ct.min.y, ct.max.x - ct.min.x | 0, ct.max.y - ct.min.y | 0)), ct.makeEmpty())
	}, this.clearColor = function () {
	}, this.clearDepth = function () {
	}, this.clearStencil = function () {
	}, this.render = function (e, w) {
		if (!1 == w instanceof THREE.Camera)console.error("THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera."); else {
			!0 === this.autoClear && this.clear(), b.info.render.vertices = 0, b.info.render.faces = 0, D.setTransform(k / H, 0, 0, -P / M, A, M - L), D.translate(S, C), g = _.projectScene(e, w, this.sortObjects, this.sortElements), E = g.elements, v = g.lights, y = w, vt.getNormalMatrix(w.matrixWorldInverse), ft.setRGB(0, 0, 0), dt.setRGB(0, 0, 0), pt.setRGB(0, 0, 0);
			for (var F = 0, N = v.length; N > F; F++) {
				var z = v[F], U = z.color;
				z instanceof THREE.AmbientLight ? ft.add(U) : z instanceof THREE.DirectionalLight ? dt.add(U) : z instanceof THREE.PointLight && pt.add(U)
			}
			for (F = 0, N = E.length; N > F; F++) {
				var V = E[F], B = V.material;
				if (void 0 !== B && 0 !== B.opacity) {
					if (ht.makeEmpty(), V instanceof THREE.RenderableSprite) {
						T = V, T.x *= S, T.y *= C;
						var z = T, O = V, U = B;
						s(U.opacity), l(U.blending);
						var I = O.scale.x * S, O = O.scale.y * C, V = .5 * Math.sqrt(I * I + O * O);
						if (ht.min.set(z.x - V, z.y - V), ht.max.set(z.x + V, z.y + V), U instanceof THREE.SpriteMaterial) {
							var j = U.map;
							if (null !== j && void 0 !== j.image) {
								!1 === j.hasEventListener("update", r) && (0 < j.image.width && i(j), j.addEventListener("update", r)), V = lt[j.id], d(void 0 !== V ? V : "rgba( 0, 0, 0, 1 )");
								var W = j.image, V = W.width * j.offset.x, B = W.height * j.offset.y, yt = W.width * j.repeat.x, j = W.height * j.repeat.y, W = I / yt, Tt = O / j;
								D.save(), D.translate(z.x, z.y), 0 !== U.rotation && D.rotate(U.rotation), D.translate(-I / 2, -O / 2), D.scale(W, Tt), D.translate(-V, -B), D.fillRect(V, B, yt, j)
							} else d(U.color.getStyle()), D.save(), D.translate(z.x, z.y), 0 !== U.rotation && D.rotate(U.rotation), D.scale(I, -O), D.fillRect(-.5, -.5, 1, 1);
							D.restore()
						} else U instanceof THREE.SpriteCanvasMaterial && (f(U.color.getStyle()), d(U.color.getStyle()), D.save(), D.translate(z.x, z.y), 0 !== U.rotation && D.rotate(U.rotation), D.scale(I, O), U.program(D), D.restore())
					} else if (V instanceof THREE.RenderableLine) {
						if (T = V.v1, x = V.v2, T.positionScreen.x *= S, T.positionScreen.y *= C, x.positionScreen.x *= S, x.positionScreen.y *= C, ht.setFromPoints([T.positionScreen, x.positionScreen]), !0 === ut.isIntersectionBox(ht))if (z = T, U = x, I = V, O = B, s(O.opacity), l(O.blending), D.beginPath(), D.moveTo(z.positionScreen.x, z.positionScreen.y), D.lineTo(U.positionScreen.x, U.positionScreen.y), O instanceof THREE.LineBasicMaterial) {
							if (u(O.linewidth), c(O.linecap), h(O.linejoin), O.vertexColors !== THREE.VertexColors)f(O.color.getStyle()); else if (V = I.vertexColors[0].getStyle(), I = I.vertexColors[1].getStyle(), V === I)f(V); else {
								try {
									var xt = D.createLinearGradient(z.positionScreen.x, z.positionScreen.y, U.positionScreen.x, U.positionScreen.y);
									xt.addColorStop(0, V), xt.addColorStop(1, I)
								} catch (Rt) {
									xt = V
								}
								f(xt)
							}
							D.stroke(), ht.expandByScalar(2 * O.linewidth)
						} else O instanceof THREE.LineDashedMaterial && (u(O.linewidth), c(O.linecap), h(O.linejoin), f(O.color.getStyle()), p([O.dashSize, O.gapSize]), D.stroke(), ht.expandByScalar(2 * O.linewidth), p([]))
					} else if (V instanceof THREE.RenderableFace) {
						if (T = V.v1, x = V.v2, R = V.v3, -1 > T.positionScreen.z || 1 < T.positionScreen.z)continue;
						if (-1 > x.positionScreen.z || 1 < x.positionScreen.z)continue;
						if (-1 > R.positionScreen.z || 1 < R.positionScreen.z)continue;
						if (T.positionScreen.x *= S, T.positionScreen.y *= C, x.positionScreen.x *= S, x.positionScreen.y *= C, R.positionScreen.x *= S, R.positionScreen.y *= C, 0 < B.overdraw && (a(T.positionScreen, x.positionScreen, B.overdraw), a(x.positionScreen, R.positionScreen, B.overdraw), a(R.positionScreen, T.positionScreen, B.overdraw)), ht.setFromPoints([T.positionScreen, x.positionScreen, R.positionScreen]), !0 === ut.isIntersectionBox(ht)) {
							U = T, I = x, O = R, z = B, b.info.render.vertices += 3, b.info.render.faces++, s(z.opacity), l(z.blending), G = U.positionScreen.x, X = U.positionScreen.y, q = I.positionScreen.x, Y = I.positionScreen.y, K = O.positionScreen.x, Z = O.positionScreen.y;
							var B = G, yt = X, j = q, W = Y, Tt = K, bt = Z;
							if (D.beginPath(), D.moveTo(B, yt), D.lineTo(j, W), D.lineTo(Tt, bt), D.closePath(), (z instanceof THREE.MeshLambertMaterial || z instanceof THREE.MeshPhongMaterial) && null === z.map) {
								for (ot.copy(z.color), at.copy(z.emissive), z.vertexColors === THREE.FaceColors && ot.multiply(V.color), Q.copy(ft), gt.copy(U.positionWorld).add(I.positionWorld).add(O.positionWorld).divideScalar(3), U = gt, I = V.normalModel, O = Q, V = 0, B = v.length; B > V; V++)yt = v[V], st.copy(yt.color), yt instanceof THREE.DirectionalLight ? (j = mt.setFromMatrixPosition(yt.matrixWorld).normalize(), W = I.dot(j), 0 >= W || (W *= yt.intensity, O.add(st.multiplyScalar(W)))) : yt instanceof THREE.PointLight && (j = mt.setFromMatrixPosition(yt.matrixWorld), W = I.dot(mt.subVectors(j, U).normalize()), 0 >= W || (W *= 0 == yt.distance ? 1 : 1 - Math.min(U.distanceTo(j) / yt.distance, 1), 0 != W && (W *= yt.intensity, O.add(st.multiplyScalar(W)))));
								Q.multiply(ot).add(at), !0 === z.wireframe ? t(Q, z.wireframeLinewidth, z.wireframeLinecap, z.wireframeLinejoin) : n(Q)
							} else z instanceof THREE.MeshBasicMaterial || z instanceof THREE.MeshLambertMaterial || z instanceof THREE.MeshPhongMaterial ? null !== z.map ? z.map.mapping instanceof THREE.UVMapping && ($ = V.uvs, o(G, X, q, Y, K, Z, $[0].x, $[0].y, $[1].x, $[1].y, $[2].x, $[2].y, z.map)) : null !== z.envMap ? z.envMap.mapping instanceof THREE.SphericalReflectionMapping ? (Et.copy(V.vertexNormalsModel[0]).applyMatrix3(vt), J = .5 * Et.x + .5, et = .5 * Et.y + .5, Et.copy(V.vertexNormalsModel[1]).applyMatrix3(vt), tt = .5 * Et.x + .5, nt = .5 * Et.y + .5, Et.copy(V.vertexNormalsModel[2]).applyMatrix3(vt), rt = .5 * Et.x + .5, it = .5 * Et.y + .5, o(G, X, q, Y, K, Z, J, et, tt, nt, rt, it, z.envMap)) : z.envMap.mapping instanceof THREE.SphericalRefractionMapping && (Et.copy(V.vertexNormalsModel[0]).applyMatrix3(vt), J = -.5 * Et.x + .5, et = -.5 * Et.y + .5, Et.copy(V.vertexNormalsModel[1]).applyMatrix3(vt), tt = -.5 * Et.x + .5, nt = -.5 * Et.y + .5, Et.copy(V.vertexNormalsModel[2]).applyMatrix3(vt), rt = -.5 * Et.x + .5, it = -.5 * Et.y + .5, o(G, X, q, Y, K, Z, J, et, tt, nt, rt, it, z.envMap)) : (Q.copy(z.color), z.vertexColors === THREE.FaceColors && Q.multiply(V.color), !0 === z.wireframe ? t(Q, z.wireframeLinewidth, z.wireframeLinecap, z.wireframeLinejoin) : n(Q)) : (z instanceof THREE.MeshDepthMaterial ? Q.r = Q.g = Q.b = 1 - m(U.positionScreen.z * U.positionScreen.w, y.near, y.far) : z instanceof THREE.MeshNormalMaterial ? (Et.copy(V.normalModel).applyMatrix3(vt), Q.setRGB(Et.x, Et.y, Et.z).multiplyScalar(.5).addScalar(.5)) : Q.setRGB(1, 1, 1), !0 === z.wireframe ? t(Q, z.wireframeLinewidth, z.wireframeLinecap, z.wireframeLinejoin) : n(Q))
						}
					}
					ct.union(ht)
				}
			}
			D.setTransform(1, 0, 0, 1, 0, 0)
		}
	}
}, THREE.ShaderChunk = {}, THREE.ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n\n	if ( gl_FragColor.a < ALPHATEST ) discard;\n\n#endif\n", THREE.ShaderChunk.lights_lambert_vertex = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n	vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n	vec3 dirVector = normalize( lDirection.xyz );\n\n	float dotProduct = dot( transformedNormal, dirVector );\n	vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n	#ifdef DOUBLE_SIDED\n\n		vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n		#ifdef WRAP_AROUND\n\n			vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n		#endif\n\n	#endif\n\n	#ifdef WRAP_AROUND\n\n		vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n		directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n		#ifdef DOUBLE_SIDED\n\n			directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n		#endif\n\n	#endif\n\n	vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n	#ifdef DOUBLE_SIDED\n\n		vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n	#endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( pointLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n		float dotProduct = dot( transformedNormal, lVector );\n\n		vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n		#ifdef DOUBLE_SIDED\n\n			vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n			#ifdef WRAP_AROUND\n\n				vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n			#endif\n\n		#endif\n\n		#ifdef WRAP_AROUND\n\n			vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n			pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n			#ifdef DOUBLE_SIDED\n\n				pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n			#endif\n\n		#endif\n\n		vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n			float lDistance = 1.0;\n			if ( spotLightDistance[ i ] > 0.0 )\n				lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n			lVector = normalize( lVector );\n\n			float dotProduct = dot( transformedNormal, lVector );\n			vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n			#ifdef DOUBLE_SIDED\n\n				vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n				#ifdef WRAP_AROUND\n\n					vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n				#endif\n\n			#endif\n\n			#ifdef WRAP_AROUND\n\n				vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n				spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n				#ifdef DOUBLE_SIDED\n\n					spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n				#endif\n\n			#endif\n\n			vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n		vec3 lVector = normalize( lDirection.xyz );\n\n		float dotProduct = dot( transformedNormal, lVector );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n		float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n\n#endif", THREE.ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif", THREE.ShaderChunk.default_vertex = "vec4 mvPosition;\n\n#ifdef USE_SKINNING\n\n	mvPosition = modelViewMatrix * skinned;\n\n#endif\n\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\n\n	mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#endif\n\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\n\n	mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.map_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif", THREE.ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	#ifdef USE_MORPHNORMALS\n\n	vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n	#else\n\n	vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n	#endif\n\n#endif\n", THREE.ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif", THREE.ShaderChunk.lightmap_pars_vertex = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n\n#endif", THREE.ShaderChunk.lights_phong_fragment = "vec3 normal = normalize( vNormal );\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef DOUBLE_SIDED\n\n	normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	vec3 pointDiffuse = vec3( 0.0 );\n	vec3 pointSpecular = vec3( 0.0 );\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( pointLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n\n				// diffuse\n\n		float dotProduct = dot( normal, lVector );\n\n		#ifdef WRAP_AROUND\n\n			float pointDiffuseWeightFull = max( dotProduct, 0.0 );\n			float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float pointDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		pointDiffuse += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\n\n				// specular\n\n		vec3 pointHalfVector = normalize( lVector + viewPosition );\n		float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n		float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n		pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	vec3 spotDiffuse = vec3( 0.0 );\n	vec3 spotSpecular = vec3( 0.0 );\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( spotLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n					// diffuse\n\n			float dotProduct = dot( normal, lVector );\n\n			#ifdef WRAP_AROUND\n\n				float spotDiffuseWeightFull = max( dotProduct, 0.0 );\n				float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n				vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n			#else\n\n				float spotDiffuseWeight = max( dotProduct, 0.0 );\n\n			#endif\n\n			spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\n\n					// specular\n\n			vec3 spotHalfVector = normalize( lVector + viewPosition );\n			float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n			float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n			float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n			spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	vec3 dirDiffuse = vec3( 0.0 );\n	vec3 dirSpecular = vec3( 0.0 );\n\n	for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n		vec3 dirVector = normalize( lDirection.xyz );\n\n				// diffuse\n\n		float dotProduct = dot( normal, dirVector );\n\n		#ifdef WRAP_AROUND\n\n			float dirDiffuseWeightFull = max( dotProduct, 0.0 );\n			float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float dirDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		dirDiffuse += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\n\n		// specular\n\n		vec3 dirHalfVector = normalize( dirVector + viewPosition );\n		float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n		float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n		/*\n		// fresnel term from skin shader\n		const float F0 = 0.128;\n\n		float base = 1.0 - dot( viewPosition, dirHalfVector );\n		float exponential = pow( base, 5.0 );\n\n		float fresnel = exponential + F0 * ( 1.0 - exponential );\n		*/\n\n		/*\n		// fresnel term from fresnel shader\n		const float mFresnelBias = 0.08;\n		const float mFresnelScale = 0.3;\n		const float mFresnelPower = 5.0;\n\n		float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n		*/\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		// 		dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n		dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	vec3 hemiDiffuse = vec3( 0.0 );\n	vec3 hemiSpecular = vec3( 0.0 );\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n		vec3 lVector = normalize( lDirection.xyz );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lVector );\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		hemiDiffuse += diffuse * hemiColor;\n\n		// specular (sky light)\n\n		vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n		float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n		float hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n		// specular (ground light)\n\n		vec3 lVectorGround = -lVector;\n\n		vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n		float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n		float hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n		float dotProductGround = dot( normal, lVectorGround );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n		vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n		hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n	}\n\n#endif\n\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n\n#if MAX_DIR_LIGHTS > 0\n\n	totalDiffuse += dirDiffuse;\n	totalSpecular += dirSpecular;\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	totalDiffuse += hemiDiffuse;\n	totalSpecular += hemiSpecular;\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	totalDiffuse += pointDiffuse;\n	totalSpecular += pointSpecular;\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	totalDiffuse += spotDiffuse;\n	totalSpecular += spotSpecular;\n\n#endif\n\n#ifdef METAL\n\n	gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n\n#else\n\n	gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n\n#endif", THREE.ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif", THREE.ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\n	vec3 morphedNormal = vec3( 0.0 );\n\n	morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n	morphedNormal += normal;\n\n#endif", THREE.ShaderChunk.envmap_pars_fragment = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	uniform samplerCube envMap;\n	uniform float flipEnvMap;\n	uniform int combine;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\n		uniform bool useRefract;\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif", THREE.ShaderChunk.logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif", THREE.ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n			// Per-Pixel Tangent Space Normal Mapping\n			// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n", THREE.ShaderChunk.lights_phong_pars_vertex = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n", THREE.ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n	uniform sampler2D lightMap;\n\n#endif", THREE.ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif", THREE.ShaderChunk.lights_phong_vertex = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif", THREE.ShaderChunk.map_fragment = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	#ifdef GAMMA_INPUT\n\n		texelColor.xyz *= texelColor.xyz;\n\n	#endif\n\n	gl_FragColor = gl_FragColor * texelColor;\n\n#endif", THREE.ShaderChunk.lightmap_vertex = "#ifdef USE_LIGHTMAP\n\n	vUv2 = uv2;\n\n#endif", THREE.ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n\n	gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n\n#endif", THREE.ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n", THREE.ShaderChunk.color_vertex = "#ifdef USE_COLOR\n\n	#ifdef GAMMA_INPUT\n\n		vColor = color * color;\n\n	#else\n\n		vColor = color;\n\n	#endif\n\n#endif", THREE.ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n\n	#ifdef USE_MORPHTARGETS\n\n	vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n	vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n	#endif\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n", THREE.ShaderChunk.envmap_pars_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n	uniform bool useRefract;\n\n#endif\n", THREE.ShaderChunk.linear_to_gamma_fragment = "#ifdef GAMMA_OUTPUT\n\n	gl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n\n#endif", THREE.ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif", THREE.ShaderChunk.lights_lambert_pars_vertex = "uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 emissive;\n\nuniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n", THREE.ShaderChunk.map_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n", THREE.ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n\n	vec3 reflectVec;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\n		// Transforming Normal Vectors with the Inverse Transformation\n\n		vec3 worldNormal = normalize( vec3( vec4( normal, 0.0 ) * viewMatrix ) );\n\n		if ( useRefract ) {\n\n			reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		} else { \n\n			reflectVec = reflect( cameraToVertex, worldNormal );\n\n		}\n\n	#else\n\n		reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n\n		float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n		vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#else\n\n		vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#endif\n\n	#ifdef GAMMA_INPUT\n\n		cubeColor.xyz *= cubeColor.xyz;\n\n	#endif\n\n	if ( combine == 1 ) {\n\n		gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\n\n	} else if ( combine == 2 ) {\n\n		gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\n\n	} else {\n\n		gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\n\n	}\n\n#endif", THREE.ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif", THREE.ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max(1e-6, gl_Position.w + 1.0)) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif", THREE.ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif", THREE.ShaderChunk.specularmap_fragment = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif", THREE.ShaderChunk.fog_fragment = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		const float LOG2 = 1.442695;\n		float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\n		fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n\n#endif", THREE.ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n			// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n			//	http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n			// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;		// normalized\n\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif", THREE.ShaderChunk.defaultnormal_vertex = "vec3 objectNormal;\n\n#ifdef USE_SKINNING\n\n	objectNormal = skinnedNormal.xyz;\n\n#endif\n\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\n\n	objectNormal = morphedNormal;\n\n#endif\n\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\n\n	objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;", THREE.ShaderChunk.lights_phong_pars_fragment = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;", THREE.ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif", THREE.ShaderChunk.map_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif", THREE.ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n\n	gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n\n#endif", THREE.ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif", THREE.ShaderChunk.color_fragment = "#ifdef USE_COLOR\n\n	gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n\n#endif", THREE.ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\n	vec3 morphed = vec3( 0.0 );\n	morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n	morphed += position;\n\n#endif", THREE.ShaderChunk.envmap_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\n\n	vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\n	worldNormal = normalize( worldNormal );\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	if ( useRefract ) {\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	} else {\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	}\n\n#endif", THREE.ShaderChunk.shadowmap_fragment = "#ifdef USE_SHADOWMAP\n\n	#ifdef SHADOWMAP_DEBUG\n\n		vec3 frustumColors[3];\n		frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n		frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n		frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n	#endif\n\n	#ifdef SHADOWMAP_CASCADE\n\n		int inFrustumCount = 0;\n\n	#endif\n\n	float fDepth;\n	vec3 shadowColor = vec3( 1.0 );\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n				// if ( something && something ) breaks ATI OpenGL shader compiler\n				// if ( all( something, something ) ) using this instead\n\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n\n				// don't shadow pixels outside of light frustum\n				// use just first frustum (for cascades)\n				// don't shadow pixels behind far plane of light frustum\n\n		#ifdef SHADOWMAP_CASCADE\n\n			inFrustumCount += int( inFrustum );\n			bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n		#else\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n		#endif\n\n		bool frustumTest = all( frustumTestVec );\n\n		if ( frustumTest ) {\n\n			shadowCoord.z += shadowBias[ i ];\n\n			#if defined( SHADOWMAP_TYPE_PCF )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n		/*\n						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n						// must enroll loop manually\n\n				for ( float y = -1.25; y <= 1.25; y += 1.25 )\n					for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n						vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n								// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n								//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n						float fDepth = unpackDepth( rgbaDepth );\n\n						if ( fDepth < shadowCoord.z )\n							shadow += 1.0;\n\n				}\n\n				shadow /= 9.0;\n\n		*/\n\n				const float shadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.25 * xPixelOffset;\n				float dy0 = -1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.0 * xPixelOffset;\n				float dy0 = -1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n				shadowKernel[0] *= vec3(0.25);\n\n				shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n				shadowKernel[1] *= vec3(0.25);\n\n				shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n				shadowKernel[2] *= vec3(0.25);\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n				shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n				shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) );\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#else\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n\n		// spot with multiple shadows is darker\n\n					shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n		// spot with multiple shadows has the same color as single shadow spot\n\n		// 					shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n			#endif\n\n		}\n\n\n		#ifdef SHADOWMAP_DEBUG\n\n			#ifdef SHADOWMAP_CASCADE\n\n				if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n\n			#else\n\n				if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n\n			#endif\n\n		#endif\n\n	}\n\n	#ifdef GAMMA_OUTPUT\n\n		shadowColor *= shadowColor;\n\n	#endif\n\n	gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n\n#endif\n", THREE.ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#endif\n\n	#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n\n		vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n	#endif\n\n	#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n\n		vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n	#endif\n\n#endif", THREE.ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n#endif", THREE.ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n", THREE.ShaderChunk.logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		#extension GL_EXT_frag_depth : enable\n		varying float vFragDepth;\n\n	#endif\n\n#endif", THREE.ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n\n	gl_FragColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n", THREE.ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n", THREE.UniformsUtils = {merge: function (e) {
	var t, n, r, i = {};
	for (t = 0; t < e.length; t++)for (n in r = this.clone(e[t]))i[n] = r[n];
	return i
}, clone: function (e) {
	var t, n, r, i = {};
	for (t in e)for (n in i[t] = {}, e[t])r = e[t][n], i[t][n] = r instanceof THREE.Color || r instanceof THREE.Vector2 || r instanceof THREE.Vector3 || r instanceof THREE.Vector4 || r instanceof THREE.Matrix4 || r instanceof THREE.Texture ? r.clone() : r instanceof Array ? r.slice() : r;
	return i
}}, THREE.UniformsLib = {common: {diffuse: {type: "c", value: new THREE.Color(15658734)}, opacity: {type: "f", value: 1}, map: {type: "t", value: null}, offsetRepeat: {type: "v4", value: new THREE.Vector4(0, 0, 1, 1)}, lightMap: {type: "t", value: null}, specularMap: {type: "t", value: null}, alphaMap: {type: "t", value: null}, envMap: {type: "t", value: null}, flipEnvMap: {type: "f", value: -1}, useRefract: {type: "i", value: 0}, reflectivity: {type: "f", value: 1}, refractionRatio: {type: "f", value: .98}, combine: {type: "i", value: 0}, morphTargetInfluences: {type: "f", value: 0}}, bump: {bumpMap: {type: "t", value: null}, bumpScale: {type: "f", value: 1}}, normalmap: {normalMap: {type: "t", value: null}, normalScale: {type: "v2", value: new THREE.Vector2(1, 1)}}, fog: {fogDensity: {type: "f", value: 25e-5}, fogNear: {type: "f", value: 1}, fogFar: {type: "f", value: 2e3}, fogColor: {type: "c", value: new THREE.Color(16777215)}}, lights: {ambientLightColor: {type: "fv", value: []}, directionalLightDirection: {type: "fv", value: []}, directionalLightColor: {type: "fv", value: []}, hemisphereLightDirection: {type: "fv", value: []}, hemisphereLightSkyColor: {type: "fv", value: []}, hemisphereLightGroundColor: {type: "fv", value: []}, pointLightColor: {type: "fv", value: []}, pointLightPosition: {type: "fv", value: []}, pointLightDistance: {type: "fv1", value: []}, spotLightColor: {type: "fv", value: []}, spotLightPosition: {type: "fv", value: []}, spotLightDirection: {type: "fv", value: []}, spotLightDistance: {type: "fv1", value: []}, spotLightAngleCos: {type: "fv1", value: []}, spotLightExponent: {type: "fv1", value: []}}, particle: {psColor: {type: "c", value: new THREE.Color(15658734)}, opacity: {type: "f", value: 1}, size: {type: "f", value: 1}, scale: {type: "f", value: 1}, map: {type: "t", value: null}, fogDensity: {type: "f", value: 25e-5}, fogNear: {type: "f", value: 1}, fogFar: {type: "f", value: 2e3}, fogColor: {type: "c", value: new THREE.Color(16777215)}}, shadowmap: {shadowMap: {type: "tv", value: []}, shadowMapSize: {type: "v2v", value: []}, shadowBias: {type: "fv1", value: []}, shadowDarkness: {type: "fv1", value: []}, shadowMatrix: {type: "m4v", value: []}}}, THREE.ShaderLib = {basic: {uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.shadowmap]), vertexShader: [THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.skinbase_vertex, "	#ifdef USE_ENVMAP", THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "	#endif", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"), fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	gl_FragColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")}, lambert: {uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {ambient: {type: "c", value: new THREE.Color(16777215)}, emissive: {type: "c", value: new THREE.Color(0)}, wrapRGB: {type: "v3", value: new THREE.Vector3(1, 1, 1)}}]), vertexShader: ["#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif", THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_lambert_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_lambert_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"), fragmentShader: ["uniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	gl_FragColor = vec4( vec3( 1.0 ), opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, "	#ifdef DOUBLE_SIDED\n		if ( gl_FrontFacing )\n			gl_FragColor.xyz *= vLightFront;\n		else\n			gl_FragColor.xyz *= vLightBack;\n	#else\n		gl_FragColor.xyz *= vLightFront;\n	#endif", THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")}, phong: {uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.bump, THREE.UniformsLib.normalmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {ambient: {type: "c", value: new THREE.Color(16777215)}, emissive: {type: "c", value: new THREE.Color(0)}, specular: {type: "c", value: new THREE.Color(1118481)}, shininess: {type: "f", value: 30}, wrapRGB: {type: "v3", value: new THREE.Vector3(1, 1, 1)}}]), vertexShader: ["#define PHONG\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;", THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_phong_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "	vNormal = normalize( transformedNormal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "	vViewPosition = -mvPosition.xyz;", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_phong_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"), fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;\nuniform vec3 ambient;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.lights_phong_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.bumpmap_pars_fragment, THREE.ShaderChunk.normalmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	gl_FragColor = vec4( vec3( 1.0 ), opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lights_phong_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")}, particle_basic: {uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.particle, THREE.UniformsLib.shadowmap]), vertexShader: ["uniform float size;\nuniform float scale;", THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	#ifdef USE_SIZEATTENUATION\n		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );\n	#else\n		gl_PointSize = size;\n	#endif\n	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"), fragmentShader: ["uniform vec3 psColor;\nuniform float opacity;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_particle_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	gl_FragColor = vec4( psColor, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_particle_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")}, dashed: {uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, {scale: {type: "f", value: 1}, dashSize: {type: "f", value: 1}, totalSize: {type: "f", value: 2}}]), vertexShader: ["uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;", THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "	vLineDistance = scale * lineDistance;\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"), fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	gl_FragColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")}, depth: {uniforms: {mNear: {type: "f", value: 1}, mFar: {type: "f", value: 2e3}, opacity: {type: "f", value: 1}}, vertexShader: [THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"), fragmentShader: ["uniform float mNear;\nuniform float mFar;\nuniform float opacity;", THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", THREE.ShaderChunk.logdepthbuf_fragment, "	#ifdef USE_LOGDEPTHBUF_EXT\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n	#else\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n	#endif\n	float color = 1.0 - smoothstep( mNear, mFar, depth );\n	gl_FragColor = vec4( vec3( color ), opacity );\n}"].join("\n")}, normal: {uniforms: {opacity: {type: "f", value: 1}}, vertexShader: ["varying vec3 vNormal;", THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {\n	vNormal = normalize( normalMatrix * normal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"), fragmentShader: ["uniform float opacity;\nvarying vec3 vNormal;", THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")}, normalmap: {uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {enableAO: {type: "i", value: 0}, enableDiffuse: {type: "i", value: 0}, enableSpecular: {type: "i", value: 0}, enableReflection: {type: "i", value: 0}, enableDisplacement: {type: "i", value: 0}, tDisplacement: {type: "t", value: null}, tDiffuse: {type: "t", value: null}, tCube: {type: "t", value: null}, tNormal: {type: "t", value: null}, tSpecular: {type: "t", value: null}, tAO: {type: "t", value: null}, uNormalScale: {type: "v2", value: new THREE.Vector2(1, 1)}, uDisplacementBias: {type: "f", value: 0}, uDisplacementScale: {type: "f", value: 1}, diffuse: {type: "c", value: new THREE.Color(16777215)}, specular: {type: "c", value: new THREE.Color(1118481)}, ambient: {type: "c", value: new THREE.Color(16777215)}, shininess: {type: "f", value: 30}, opacity: {type: "f", value: 1}, useRefract: {type: "i", value: 0}, refractionRatio: {type: "f", value: .98}, reflectivity: {type: "f", value: .5}, uOffset: {type: "v2", value: new THREE.Vector2(0, 0)}, uRepeat: {type: "v2", value: new THREE.Vector2(1, 1)}, wrapRGB: {type: "v3", value: new THREE.Vector3(1, 1, 1)}}]), fragmentShader: ["uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\nuniform bool enableDiffuse;\nuniform bool enableSpecular;\nuniform bool enableAO;\nuniform bool enableReflection;\nuniform sampler2D tDiffuse;\nuniform sampler2D tNormal;\nuniform sampler2D tSpecular;\nuniform sampler2D tAO;\nuniform samplerCube tCube;\nuniform vec2 uNormalScale;\nuniform bool useRefract;\nuniform float refractionRatio;\nuniform float reflectivity;\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\n	uniform vec3 wrapRGB;\n#endif\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;", THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", THREE.ShaderChunk.logdepthbuf_fragment, "	gl_FragColor = vec4( vec3( 1.0 ), opacity );\n	vec3 specularTex = vec3( 1.0 );\n	vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\n	normalTex.xy *= uNormalScale;\n	normalTex = normalize( normalTex );\n	if( enableDiffuse ) {\n		#ifdef GAMMA_INPUT\n			vec4 texelColor = texture2D( tDiffuse, vUv );\n			texelColor.xyz *= texelColor.xyz;\n			gl_FragColor = gl_FragColor * texelColor;\n		#else\n			gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\n		#endif\n	}\n	if( enableAO ) {\n		#ifdef GAMMA_INPUT\n			vec4 aoColor = texture2D( tAO, vUv );\n			aoColor.xyz *= aoColor.xyz;\n			gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\n		#else\n			gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\n		#endif\n	}", THREE.ShaderChunk.alphatest_fragment, "	if( enableSpecular )\n		specularTex = texture2D( tSpecular, vUv ).xyz;\n	mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\n	vec3 finalNormal = tsb * normalTex;\n	#ifdef FLIP_SIDED\n		finalNormal = -finalNormal;\n	#endif\n	vec3 normal = normalize( finalNormal );\n	vec3 viewPosition = normalize( vViewPosition );\n	#if MAX_POINT_LIGHTS > 0\n		vec3 pointDiffuse = vec3( 0.0 );\n		vec3 pointSpecular = vec3( 0.0 );\n		for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n			vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n			vec3 pointVector = lPosition.xyz + vViewPosition.xyz;\n			float pointDistance = 1.0;\n			if ( pointLightDistance[ i ] > 0.0 )\n				pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\n			pointVector = normalize( pointVector );\n			#ifdef WRAP_AROUND\n				float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\n				float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\n				vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n			#else\n				float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\n			#endif\n			pointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;\n			vec3 pointHalfVector = normalize( pointVector + viewPosition );\n			float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n			float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n			float specularNormalization = ( shininess + 2.0 ) / 8.0;\n			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( pointVector, pointHalfVector ), 0.0 ), 5.0 );\n			pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\n		}\n	#endif\n	#if MAX_SPOT_LIGHTS > 0\n		vec3 spotDiffuse = vec3( 0.0 );\n		vec3 spotSpecular = vec3( 0.0 );\n		for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n			vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n			vec3 spotVector = lPosition.xyz + vViewPosition.xyz;\n			float spotDistance = 1.0;\n			if ( spotLightDistance[ i ] > 0.0 )\n				spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\n			spotVector = normalize( spotVector );\n			float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n			if ( spotEffect > spotLightAngleCos[ i ] ) {\n				spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n				#ifdef WRAP_AROUND\n					float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\n					float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\n					vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n				#else\n					float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\n				#endif\n				spotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;\n				vec3 spotHalfVector = normalize( spotVector + viewPosition );\n				float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n				float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n				float specularNormalization = ( shininess + 2.0 ) / 8.0;\n				vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( spotVector, spotHalfVector ), 0.0 ), 5.0 );\n				spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\n			}\n		}\n	#endif\n	#if MAX_DIR_LIGHTS > 0\n		vec3 dirDiffuse = vec3( 0.0 );\n		vec3 dirSpecular = vec3( 0.0 );\n		for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\n			vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n			vec3 dirVector = normalize( lDirection.xyz );\n			#ifdef WRAP_AROUND\n				float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\n				float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\n				vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\n			#else\n				float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\n			#endif\n			dirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;\n			vec3 dirHalfVector = normalize( dirVector + viewPosition );\n			float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n			float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n			float specularNormalization = ( shininess + 2.0 ) / 8.0;\n			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n			dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n		}\n	#endif\n	#if MAX_HEMI_LIGHTS > 0\n		vec3 hemiDiffuse = vec3( 0.0 );\n		vec3 hemiSpecular = vec3( 0.0 );\n		for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n			vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n			vec3 lVector = normalize( lDirection.xyz );\n			float dotProduct = dot( normal, lVector );\n			float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n			vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n			hemiDiffuse += diffuse * hemiColor;\n			vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n			float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n			float hemiSpecularWeightSky = specularTex.r * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n			vec3 lVectorGround = -lVector;\n			vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n			float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n			float hemiSpecularWeightGround = specularTex.r * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n			float dotProductGround = dot( normal, lVectorGround );\n			float specularNormalization = ( shininess + 2.0 ) / 8.0;\n			vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n			vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n			hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n		}\n	#endif\n	vec3 totalDiffuse = vec3( 0.0 );\n	vec3 totalSpecular = vec3( 0.0 );\n	#if MAX_DIR_LIGHTS > 0\n		totalDiffuse += dirDiffuse;\n		totalSpecular += dirSpecular;\n	#endif\n	#if MAX_HEMI_LIGHTS > 0\n		totalDiffuse += hemiDiffuse;\n		totalSpecular += hemiSpecular;\n	#endif\n	#if MAX_POINT_LIGHTS > 0\n		totalDiffuse += pointDiffuse;\n		totalSpecular += pointSpecular;\n	#endif\n	#if MAX_SPOT_LIGHTS > 0\n		totalDiffuse += spotDiffuse;\n		totalSpecular += spotSpecular;\n	#endif\n	#ifdef METAL\n		gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );\n	#else\n		gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n	#endif\n	if ( enableReflection ) {\n		vec3 vReflect;\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n		if ( useRefract ) {\n			vReflect = refract( cameraToVertex, normal, refractionRatio );\n		} else {\n			vReflect = reflect( cameraToVertex, normal );\n		}\n		vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\n		#ifdef GAMMA_INPUT\n			cubeColor.xyz *= cubeColor.xyz;\n		#endif\n		gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );\n	}", THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n"), vertexShader: ["attribute vec4 tangent;\nuniform vec2 uOffset;\nuniform vec2 uRepeat;\nuniform bool enableDisplacement;\n#ifdef VERTEX_TEXTURES\n	uniform sampler2D tDisplacement;\n	uniform float uDisplacementScale;\n	uniform float uDisplacementBias;\n#endif\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;", THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, "	#ifdef USE_SKINNING\n		vNormal = normalize( normalMatrix * skinnedNormal.xyz );\n		vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\n		vTangent = normalize( normalMatrix * skinnedTangent.xyz );\n	#else\n		vNormal = normalize( normalMatrix * normal );\n		vTangent = normalize( normalMatrix * tangent.xyz );\n	#endif\n	vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\n	vUv = uv * uRepeat + uOffset;\n	vec3 displacedPosition;\n	#ifdef VERTEX_TEXTURES\n		if ( enableDisplacement ) {\n			vec3 dv = texture2D( tDisplacement, uv ).xyz;\n			float df = uDisplacementScale * dv.x + uDisplacementBias;\n			displacedPosition = position + normalize( normal ) * df;\n		} else {\n			#ifdef USE_SKINNING\n				vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n				vec4 skinned = vec4( 0.0 );\n				skinned += boneMatX * skinVertex * skinWeight.x;\n				skinned += boneMatY * skinVertex * skinWeight.y;\n				skinned += boneMatZ * skinVertex * skinWeight.z;\n				skinned += boneMatW * skinVertex * skinWeight.w;\n				skinned  = bindMatrixInverse * skinned;\n				displacedPosition = skinned.xyz;\n			#else\n				displacedPosition = position;\n			#endif\n		}\n	#else\n		#ifdef USE_SKINNING\n			vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n			vec4 skinned = vec4( 0.0 );\n			skinned += boneMatX * skinVertex * skinWeight.x;\n			skinned += boneMatY * skinVertex * skinWeight.y;\n			skinned += boneMatZ * skinVertex * skinWeight.z;\n			skinned += boneMatW * skinVertex * skinWeight.w;\n			skinned  = bindMatrixInverse * skinned;\n			displacedPosition = skinned.xyz;\n		#else\n			displacedPosition = position;\n		#endif\n	#endif\n	vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\n	vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex, "	vWorldPosition = worldPosition.xyz;\n	vViewPosition = -mvPosition.xyz;\n	#ifdef USE_SHADOWMAP\n		for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n			vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n		}\n	#endif\n}"].join("\n")}, cube: {uniforms: {tCube: {type: "t", value: null}, tFlip: {type: "f", value: -1}}, vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {\n	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n	vWorldPosition = worldPosition.xyz;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"), fragmentShader: ["uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;", THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );", THREE.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")}, depthRGBA: {uniforms: {}, vertexShader: [THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"), fragmentShader: [THREE.ShaderChunk.logdepthbuf_pars_fragment, "vec4 pack_depth( const in float depth ) {\n	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n	res -= res.xxyz * bit_mask;\n	return res;\n}\nvoid main() {", THREE.ShaderChunk.logdepthbuf_fragment, "	#ifdef USE_LOGDEPTHBUF_EXT\n		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\n	#else\n		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n	#endif\n}"].join("\n")}}, THREE.WebGLRenderer = function (e) {
	function t(e, t) {
		var n = e.vertices.length, r = t.material;
		if (r.attributes) {
			void 0 === e.__webglCustomAttributesList && (e.__webglCustomAttributesList = []);
			for (var i in r.attributes) {
				var o = r.attributes[i];
				if (!o.__webglInitialized || o.createUniqueBuffers) {
					o.__webglInitialized = !0;
					var a = 1;
					"v2" === o.type ? a = 2 : "v3" === o.type ? a = 3 : "v4" === o.type ? a = 4 : "c" === o.type && (a = 3), o.size = a, o.array = new Float32Array(n * a), o.buffer = Q.createBuffer(), o.buffer.belongsToAttribute = i, o.needsUpdate = !0
				}
				e.__webglCustomAttributesList.push(o)
			}
		}
	}

	function n(e, t) {
		var n = t.geometry, a = e.faces3, s = 3 * a.length, l = 1 * a.length, u = 3 * a.length, a = r(t, e), c = o(a), h = i(a), f = a.vertexColors ? a.vertexColors : !1;
		if (e.__vertexArray = new Float32Array(3 * s), h && (e.__normalArray = new Float32Array(3 * s)), n.hasTangents && (e.__tangentArray = new Float32Array(4 * s)), f && (e.__colorArray = new Float32Array(3 * s)), c && (0 < n.faceVertexUvs.length && (e.__uvArray = new Float32Array(2 * s)), 1 < n.faceVertexUvs.length && (e.__uv2Array = new Float32Array(2 * s))), t.geometry.skinWeights.length && t.geometry.skinIndices.length && (e.__skinIndexArray = new Float32Array(4 * s), e.__skinWeightArray = new Float32Array(4 * s)), n = null !== nt && l > 21845 ? Uint32Array : Uint16Array, e.__typeArray = n, e.__faceArray = new n(3 * l), e.__lineArray = new n(2 * u), e.numMorphTargets)for (e.__morphTargetsArrays = [], n = 0, c = e.numMorphTargets; c > n; n++)e.__morphTargetsArrays.push(new Float32Array(3 * s));
		if (e.numMorphNormals)for (e.__morphNormalsArrays = [], n = 0, c = e.numMorphNormals; c > n; n++)e.__morphNormalsArrays.push(new Float32Array(3 * s));
		if (e.__webglFaceCount = 3 * l, e.__webglLineCount = 2 * u, a.attributes) {
			void 0 === e.__webglCustomAttributesList && (e.__webglCustomAttributesList = []);
			for (var d in a.attributes) {
				var p, l = a.attributes[d], u = {};
				for (p in l)u[p] = l[p];
				(!u.__webglInitialized || u.createUniqueBuffers) && (u.__webglInitialized = !0, n = 1, "v2" === u.type ? n = 2 : "v3" === u.type ? n = 3 : "v4" === u.type ? n = 4 : "c" === u.type && (n = 3), u.size = n, u.array = new Float32Array(s * n), u.buffer = Q.createBuffer(), u.buffer.belongsToAttribute = d, l.needsUpdate = !0, u.__original = l), e.__webglCustomAttributesList.push(u)
			}
		}
		e.__inittedArrays = !0
	}

	function r(e, t) {
		return e.material instanceof THREE.MeshFaceMaterial ? e.material.materials[t.materialIndex] : e.material
	}

	function i(e) {
		return e instanceof THREE.MeshBasicMaterial && !e.envMap || e instanceof THREE.MeshDepthMaterial ? !1 : e && void 0 !== e.shading && e.shading === THREE.SmoothShading ? THREE.SmoothShading : THREE.FlatShading
	}

	function o(e) {
		return e.map || e.lightMap || e.bumpMap || e.normalMap || e.specularMap || e.alphaMap || e instanceof THREE.ShaderMaterial ? !0 : !1
	}

	function a(e) {
		for (var t in e.attributes) {
			var n = "index" === t ? Q.ELEMENT_ARRAY_BUFFER : Q.ARRAY_BUFFER, r = e.attributes[t];
			r.buffer = Q.createBuffer(), Q.bindBuffer(n, r.buffer), Q.bufferData(n, r.array, Q.STATIC_DRAW)
		}
	}

	function s(e, t, n, r) {
		for (var i in t) {
			var o = t[i], a = n[i];
			if (o >= 0)if (a) {
				var s = a.itemSize;
				Q.bindBuffer(Q.ARRAY_BUFFER, a.buffer), u(o), Q.vertexAttribPointer(o, s, Q.FLOAT, !1, 0, r * s * 4)
			} else e.defaultAttributeValues && (2 === e.defaultAttributeValues[i].length ? Q.vertexAttrib2fv(o, e.defaultAttributeValues[i]) : 3 === e.defaultAttributeValues[i].length && Q.vertexAttrib3fv(o, e.defaultAttributeValues[i]))
		}
		c()
	}

	function l() {
		for (var e = 0, t = Ct.length; t > e; e++)Ct[e] = 0
	}

	function u(e) {
		Ct[e] = 1, 0 === At[e] && (Q.enableVertexAttribArray(e), At[e] = 1)
	}

	function c() {
		for (var e = 0, t = At.length; t > e; e++)At[e] !== Ct[e] && (Q.disableVertexAttribArray(e), At[e] = 0)
	}

	function h(e, t) {
		return e.z !== t.z ? t.z - e.z : e.id - t.id
	}

	function f(e, t) {
		return e.z !== t.z ? e.z - t.z : e.id - t.id
	}

	function d(e, t) {
		return t[0] - e[0]
	}

	function p(e, t, s) {
		if (!1 !== t.visible) {
			var l = e.__webglObjects[t.id];
			if (l && (!1 === t.frustumCulled || !0 === Lt.intersectsObject(t))) {
				var u, c, h, f = t.geometry;
				if (f instanceof THREE.BufferGeometry) {
					var m, g, E = Q.DYNAMIC_DRAW, v = f.attributes;
					for (m in v)g = v[m], g.needsUpdate && ("index" === m ? (Q.bindBuffer(Q.ELEMENT_ARRAY_BUFFER, g.buffer), Q.bufferData(Q.ELEMENT_ARRAY_BUFFER, g.array, E)) : (Q.bindBuffer(Q.ARRAY_BUFFER, g.buffer), Q.bufferData(Q.ARRAY_BUFFER, g.array, E)), g.needsUpdate = !1)
				} else if (t instanceof THREE.Mesh) {
					(f.buffersNeedUpdate || f.groupsNeedUpdate) && (f instanceof THREE.BufferGeometry ? a(f) : t instanceof THREE.Mesh && y(e, t, f));
					for (var T = 0, b = f.geometryGroupsList.length; b > T; T++)if (u = f.geometryGroupsList[T], h = r(t, u), (f.buffersNeedUpdate || f.groupsNeedUpdate) && n(u, t), c = h.attributes && x(h), f.verticesNeedUpdate || f.morphTargetsNeedUpdate || f.elementsNeedUpdate || f.uvsNeedUpdate || f.normalsNeedUpdate || f.colorsNeedUpdate || f.tangentsNeedUpdate || c) {
						var _ = u, w = t, H = Q.DYNAMIC_DRAW, M = !f.dynamic, S = h;
						if (_.__inittedArrays) {
							var C = i(S), A = S.vertexColors ? S.vertexColors : !1, L = o(S), k = C === THREE.SmoothShading, P = void 0, D = void 0, F = void 0, N = void 0, z = void 0, U = void 0, V = void 0, B = void 0, O = void 0, I = void 0, j = void 0, W = void 0, G = void 0, X = void 0, q = void 0, Y = void 0, $ = void 0, J = void 0, et = void 0, tt = void 0, nt = void 0, it = void 0, ot = void 0, at = void 0, st = void 0, lt = void 0, ut = void 0, ct = void 0, ht = void 0, ft = void 0, dt = void 0, pt = void 0, mt = void 0, gt = void 0, Et = void 0, vt = void 0, yt = void 0, Tt = void 0, xt = void 0, Rt = void 0, bt = 0, _t = 0, wt = 0, Ht = 0, Mt = 0, St = 0, Ct = 0, At = 0, Ft = 0, Nt = 0, zt = 0, Ut = 0, Vt = void 0, Bt = _.__vertexArray, Ot = _.__uvArray, It = _.__uv2Array, jt = _.__normalArray, Wt = _.__tangentArray, Gt = _.__colorArray, Xt = _.__skinIndexArray, qt = _.__skinWeightArray, Yt = _.__morphTargetsArrays, Kt = _.__morphNormalsArrays, Zt = _.__webglCustomAttributesList, Qt = void 0, $t = _.__faceArray, Jt = _.__lineArray, en = w.geometry, tn = en.elementsNeedUpdate, nn = en.uvsNeedUpdate, rn = en.normalsNeedUpdate, on = en.tangentsNeedUpdate, an = en.colorsNeedUpdate, sn = en.morphTargetsNeedUpdate, ln = en.vertices, un = _.faces3, cn = en.faces, hn = en.faceVertexUvs[0], fn = en.faceVertexUvs[1], dn = en.skinIndices, pn = en.skinWeights, mn = en.morphTargets, gn = en.morphNormals;
							if (en.verticesNeedUpdate) {
								for (P = 0, D = un.length; D > P; P++)N = cn[un[P]], W = ln[N.a], G = ln[N.b], X = ln[N.c], Bt[_t] = W.x, Bt[_t + 1] = W.y, Bt[_t + 2] = W.z, Bt[_t + 3] = G.x, Bt[_t + 4] = G.y, Bt[_t + 5] = G.z, Bt[_t + 6] = X.x, Bt[_t + 7] = X.y, Bt[_t + 8] = X.z, _t += 9;
								Q.bindBuffer(Q.ARRAY_BUFFER, _.__webglVertexBuffer), Q.bufferData(Q.ARRAY_BUFFER, Bt, H)
							}
							if (sn)for (Et = 0, vt = mn.length; vt > Et; Et++) {
								for (P = zt = 0, D = un.length; D > P; P++)xt = un[P], N = cn[xt], W = mn[Et].vertices[N.a], G = mn[Et].vertices[N.b], X = mn[Et].vertices[N.c], yt = Yt[Et], yt[zt] = W.x, yt[zt + 1] = W.y, yt[zt + 2] = W.z, yt[zt + 3] = G.x, yt[zt + 4] = G.y, yt[zt + 5] = G.z, yt[zt + 6] = X.x, yt[zt + 7] = X.y, yt[zt + 8] = X.z, S.morphNormals && (k ? (Rt = gn[Et].vertexNormals[xt], J = Rt.a, et = Rt.b, tt = Rt.c) : tt = et = J = gn[Et].faceNormals[xt], Tt = Kt[Et], Tt[zt] = J.x, Tt[zt + 1] = J.y, Tt[zt + 2] = J.z, Tt[zt + 3] = et.x, Tt[zt + 4] = et.y, Tt[zt + 5] = et.z, Tt[zt + 6] = tt.x, Tt[zt + 7] = tt.y, Tt[zt + 8] = tt.z), zt += 9;
								Q.bindBuffer(Q.ARRAY_BUFFER, _.__webglMorphTargetsBuffers[Et]), Q.bufferData(Q.ARRAY_BUFFER, Yt[Et], H), S.morphNormals && (Q.bindBuffer(Q.ARRAY_BUFFER, _.__webglMorphNormalsBuffers[Et]), Q.bufferData(Q.ARRAY_BUFFER, Kt[Et], H))
							}
							if (pn.length) {
								for (P = 0, D = un.length; D > P; P++)N = cn[un[P]], at = pn[N.a], st = pn[N.b], lt = pn[N.c], qt[Nt] = at.x, qt[Nt + 1] = at.y, qt[Nt + 2] = at.z, qt[Nt + 3] = at.w, qt[Nt + 4] = st.x, qt[Nt + 5] = st.y, qt[Nt + 6] = st.z, qt[Nt + 7] = st.w, qt[Nt + 8] = lt.x, qt[Nt + 9] = lt.y, qt[Nt + 10] = lt.z, qt[Nt + 11] = lt.w, ut = dn[N.a], ct = dn[N.b], ht = dn[N.c], Xt[Nt] = ut.x, Xt[Nt + 1] = ut.y, Xt[Nt + 2] = ut.z, Xt[Nt + 3] = ut.w, Xt[Nt + 4] = ct.x, Xt[Nt + 5] = ct.y, Xt[Nt + 6] = ct.z, Xt[Nt + 7] = ct.w, Xt[Nt + 8] = ht.x, Xt[Nt + 9] = ht.y, Xt[Nt + 10] = ht.z, Xt[Nt + 11] = ht.w, Nt += 12;
								Nt > 0 && (Q.bindBuffer(Q.ARRAY_BUFFER, _.__webglSkinIndicesBuffer), Q.bufferData(Q.ARRAY_BUFFER, Xt, H), Q.bindBuffer(Q.ARRAY_BUFFER, _.__webglSkinWeightsBuffer), Q.bufferData(Q.ARRAY_BUFFER, qt, H))
							}
							if (an && A) {
								for (P = 0, D = un.length; D > P; P++)N = cn[un[P]], V = N.vertexColors, B = N.color, 3 === V.length && A === THREE.VertexColors ? (nt = V[0], it = V[1], ot = V[2]) : ot = it = nt = B, Gt[Ft] = nt.r, Gt[Ft + 1] = nt.g, Gt[Ft + 2] = nt.b, Gt[Ft + 3] = it.r, Gt[Ft + 4] = it.g, Gt[Ft + 5] = it.b, Gt[Ft + 6] = ot.r, Gt[Ft + 7] = ot.g, Gt[Ft + 8] = ot.b, Ft += 9;
								Ft > 0 && (Q.bindBuffer(Q.ARRAY_BUFFER, _.__webglColorBuffer), Q.bufferData(Q.ARRAY_BUFFER, Gt, H))
							}
							if (on && en.hasTangents) {
								for (P = 0, D = un.length; D > P; P++)N = cn[un[P]], O = N.vertexTangents, q = O[0], Y = O[1], $ = O[2], Wt[Ct] = q.x, Wt[Ct + 1] = q.y, Wt[Ct + 2] = q.z, Wt[Ct + 3] = q.w, Wt[Ct + 4] = Y.x, Wt[Ct + 5] = Y.y, Wt[Ct + 6] = Y.z, Wt[Ct + 7] = Y.w, Wt[Ct + 8] = $.x, Wt[Ct + 9] = $.y, Wt[Ct + 10] = $.z, Wt[Ct + 11] = $.w, Ct += 12;
								Q.bindBuffer(Q.ARRAY_BUFFER, _.__webglTangentBuffer), Q.bufferData(Q.ARRAY_BUFFER, Wt, H)
							}
							if (rn && C) {
								for (P = 0, D = un.length; D > P; P++)if (N = cn[un[P]], z = N.vertexNormals, U = N.normal, 3 === z.length && k)for (ft = 0; 3 > ft; ft++)pt = z[ft], jt[St] = pt.x, jt[St + 1] = pt.y, jt[St + 2] = pt.z, St += 3; else for (ft = 0; 3 > ft; ft++)jt[St] = U.x, jt[St + 1] = U.y, jt[St + 2] = U.z, St += 3;
								Q.bindBuffer(Q.ARRAY_BUFFER, _.__webglNormalBuffer), Q.bufferData(Q.ARRAY_BUFFER, jt, H)
							}
							if (nn && hn && L) {
								for (P = 0, D = un.length; D > P; P++)if (F = un[P], I = hn[F], void 0 !== I)for (ft = 0; 3 > ft; ft++)mt = I[ft], Ot[wt] = mt.x, Ot[wt + 1] = mt.y, wt += 2;
								wt > 0 && (Q.bindBuffer(Q.ARRAY_BUFFER, _.__webglUVBuffer), Q.bufferData(Q.ARRAY_BUFFER, Ot, H))
							}
							if (nn && fn && L) {
								for (P = 0, D = un.length; D > P; P++)if (F = un[P], j = fn[F], void 0 !== j)for (ft = 0; 3 > ft; ft++)gt = j[ft], It[Ht] = gt.x, It[Ht + 1] = gt.y, Ht += 2;
								Ht > 0 && (Q.bindBuffer(Q.ARRAY_BUFFER, _.__webglUV2Buffer), Q.bufferData(Q.ARRAY_BUFFER, It, H))
							}
							if (tn) {
								for (P = 0, D = un.length; D > P; P++)$t[Mt] = bt, $t[Mt + 1] = bt + 1, $t[Mt + 2] = bt + 2, Mt += 3, Jt[At] = bt, Jt[At + 1] = bt + 1, Jt[At + 2] = bt, Jt[At + 3] = bt + 2, Jt[At + 4] = bt + 1, Jt[At + 5] = bt + 2, At += 6, bt += 3;
								Q.bindBuffer(Q.ELEMENT_ARRAY_BUFFER, _.__webglFaceBuffer), Q.bufferData(Q.ELEMENT_ARRAY_BUFFER, $t, H), Q.bindBuffer(Q.ELEMENT_ARRAY_BUFFER, _.__webglLineBuffer), Q.bufferData(Q.ELEMENT_ARRAY_BUFFER, Jt, H)
							}
							if (Zt)for (ft = 0, dt = Zt.length; dt > ft; ft++)if (Qt = Zt[ft], Qt.__original.needsUpdate) {
								if (Ut = 0, 1 === Qt.size) {
									if (void 0 === Qt.boundTo || "vertices" === Qt.boundTo)for (P = 0, D = un.length; D > P; P++)N = cn[un[P]], Qt.array[Ut] = Qt.value[N.a], Qt.array[Ut + 1] = Qt.value[N.b], Qt.array[Ut + 2] = Qt.value[N.c], Ut += 3; else if ("faces" === Qt.boundTo)for (P = 0, D = un.length; D > P; P++)Vt = Qt.value[un[P]], Qt.array[Ut] = Vt, Qt.array[Ut + 1] = Vt, Qt.array[Ut + 2] = Vt, Ut += 3
								} else if (2 === Qt.size) {
									if (void 0 === Qt.boundTo || "vertices" === Qt.boundTo)for (P = 0, D = un.length; D > P; P++)N = cn[un[P]], W = Qt.value[N.a], G = Qt.value[N.b], X = Qt.value[N.c], Qt.array[Ut] = W.x, Qt.array[Ut + 1] = W.y, Qt.array[Ut + 2] = G.x, Qt.array[Ut + 3] = G.y, Qt.array[Ut + 4] = X.x, Qt.array[Ut + 5] = X.y, Ut += 6; else if ("faces" === Qt.boundTo)for (P = 0, D = un.length; D > P; P++)X = G = W = Vt = Qt.value[un[P]], Qt.array[Ut] = W.x, Qt.array[Ut + 1] = W.y, Qt.array[Ut + 2] = G.x, Qt.array[Ut + 3] = G.y, Qt.array[Ut + 4] = X.x, Qt.array[Ut + 5] = X.y, Ut += 6
								} else if (3 === Qt.size) {
									var En;
									if (En = "c" === Qt.type ? ["r", "g", "b"] : ["x", "y", "z"], void 0 === Qt.boundTo || "vertices" === Qt.boundTo)for (P = 0, D = un.length; D > P; P++)N = cn[un[P]], W = Qt.value[N.a], G = Qt.value[N.b], X = Qt.value[N.c], Qt.array[Ut] = W[En[0]], Qt.array[Ut + 1] = W[En[1]], Qt.array[Ut + 2] = W[En[2]], Qt.array[Ut + 3] = G[En[0]], Qt.array[Ut + 4] = G[En[1]], Qt.array[Ut + 5] = G[En[2]], Qt.array[Ut + 6] = X[En[0]], Qt.array[Ut + 7] = X[En[1]], Qt.array[Ut + 8] = X[En[2]], Ut += 9; else if ("faces" === Qt.boundTo)for (P = 0, D = un.length; D > P; P++)X = G = W = Vt = Qt.value[un[P]], Qt.array[Ut] = W[En[0]], Qt.array[Ut + 1] = W[En[1]], Qt.array[Ut + 2] = W[En[2]], Qt.array[Ut + 3] = G[En[0]], Qt.array[Ut + 4] = G[En[1]], Qt.array[Ut + 5] = G[En[2]], Qt.array[Ut + 6] = X[En[0]], Qt.array[Ut + 7] = X[En[1]], Qt.array[Ut + 8] = X[En[2]], Ut += 9; else if ("faceVertices" === Qt.boundTo)for (P = 0, D = un.length; D > P; P++)Vt = Qt.value[un[P]], W = Vt[0], G = Vt[1], X = Vt[2], Qt.array[Ut] = W[En[0]], Qt.array[Ut + 1] = W[En[1]], Qt.array[Ut + 2] = W[En[2]], Qt.array[Ut + 3] = G[En[0]], Qt.array[Ut + 4] = G[En[1]], Qt.array[Ut + 5] = G[En[2]], Qt.array[Ut + 6] = X[En[0]], Qt.array[Ut + 7] = X[En[1]], Qt.array[Ut + 8] = X[En[2]], Ut += 9
								} else if (4 === Qt.size)if (void 0 === Qt.boundTo || "vertices" === Qt.boundTo)for (P = 0, D = un.length; D > P; P++)N = cn[un[P]], W = Qt.value[N.a], G = Qt.value[N.b], X = Qt.value[N.c], Qt.array[Ut] = W.x, Qt.array[Ut + 1] = W.y, Qt.array[Ut + 2] = W.z, Qt.array[Ut + 3] = W.w, Qt.array[Ut + 4] = G.x, Qt.array[Ut + 5] = G.y, Qt.array[Ut + 6] = G.z, Qt.array[Ut + 7] = G.w, Qt.array[Ut + 8] = X.x, Qt.array[Ut + 9] = X.y, Qt.array[Ut + 10] = X.z, Qt.array[Ut + 11] = X.w, Ut += 12; else if ("faces" === Qt.boundTo)for (P = 0, D = un.length; D > P; P++)X = G = W = Vt = Qt.value[un[P]], Qt.array[Ut] = W.x, Qt.array[Ut + 1] = W.y, Qt.array[Ut + 2] = W.z, Qt.array[Ut + 3] = W.w, Qt.array[Ut + 4] = G.x, Qt.array[Ut + 5] = G.y, Qt.array[Ut + 6] = G.z, Qt.array[Ut + 7] = G.w, Qt.array[Ut + 8] = X.x, Qt.array[Ut + 9] = X.y, Qt.array[Ut + 10] = X.z, Qt.array[Ut + 11] = X.w, Ut += 12; else if ("faceVertices" === Qt.boundTo)for (P = 0, D = un.length; D > P; P++)Vt = Qt.value[un[P]], W = Vt[0], G = Vt[1], X = Vt[2], Qt.array[Ut] = W.x, Qt.array[Ut + 1] = W.y, Qt.array[Ut + 2] = W.z, Qt.array[Ut + 3] = W.w, Qt.array[Ut + 4] = G.x, Qt.array[Ut + 5] = G.y, Qt.array[Ut + 6] = G.z, Qt.array[Ut + 7] = G.w, Qt.array[Ut + 8] = X.x, Qt.array[Ut + 9] = X.y, Qt.array[Ut + 10] = X.z, Qt.array[Ut + 11] = X.w, Ut += 12;
								Q.bindBuffer(Q.ARRAY_BUFFER, Qt.buffer), Q.bufferData(Q.ARRAY_BUFFER, Qt.array, H)
							}
							M && (delete _.__inittedArrays, delete _.__colorArray, delete _.__normalArray, delete _.__tangentArray, delete _.__uvArray, delete _.__uv2Array, delete _.__faceArray, delete _.__vertexArray, delete _.__lineArray, delete _.__skinIndexArray, delete _.__skinWeightArray)
						}
					}
					f.verticesNeedUpdate = !1, f.morphTargetsNeedUpdate = !1, f.elementsNeedUpdate = !1, f.uvsNeedUpdate = !1, f.normalsNeedUpdate = !1, f.colorsNeedUpdate = !1, f.tangentsNeedUpdate = !1, f.buffersNeedUpdate = !1, h.attributes && R(h)
				} else if (t instanceof THREE.Line) {
					if (h = r(t, f), c = h.attributes && x(h), f.verticesNeedUpdate || f.colorsNeedUpdate || f.lineDistancesNeedUpdate || c) {
						var vn, yn, Tn, xn, Rn, bn, _n, wn, Hn, Mn, Sn, Cn, An = Q.DYNAMIC_DRAW, Ln = f.vertices, kn = f.colors, Pn = f.lineDistances, Dn = Ln.length, Fn = kn.length, Nn = Pn.length, zn = f.__vertexArray, Un = f.__colorArray, Vn = f.__lineDistanceArray, Bn = f.colorsNeedUpdate, On = f.lineDistancesNeedUpdate, In = f.__webglCustomAttributesList;
						if (f.verticesNeedUpdate) {
							for (vn = 0; Dn > vn; vn++)xn = Ln[vn], Rn = 3 * vn, zn[Rn] = xn.x, zn[Rn + 1] = xn.y, zn[Rn + 2] = xn.z;
							Q.bindBuffer(Q.ARRAY_BUFFER, f.__webglVertexBuffer), Q.bufferData(Q.ARRAY_BUFFER, zn, An)
						}
						if (Bn) {
							for (yn = 0; Fn > yn; yn++)bn = kn[yn], Rn = 3 * yn, Un[Rn] = bn.r, Un[Rn + 1] = bn.g, Un[Rn + 2] = bn.b;
							Q.bindBuffer(Q.ARRAY_BUFFER, f.__webglColorBuffer), Q.bufferData(Q.ARRAY_BUFFER, Un, An)
						}
						if (On) {
							for (Tn = 0; Nn > Tn; Tn++)Vn[Tn] = Pn[Tn];
							Q.bindBuffer(Q.ARRAY_BUFFER, f.__webglLineDistanceBuffer), Q.bufferData(Q.ARRAY_BUFFER, Vn, An)
						}
						if (In)for (_n = 0, wn = In.length; wn > _n; _n++)if (Cn = In[_n], Cn.needsUpdate && (void 0 === Cn.boundTo || "vertices" === Cn.boundTo)) {
							if (Rn = 0, Mn = Cn.value.length, 1 === Cn.size)for (Hn = 0; Mn > Hn; Hn++)Cn.array[Hn] = Cn.value[Hn]; else if (2 === Cn.size)for (Hn = 0; Mn > Hn; Hn++)Sn = Cn.value[Hn], Cn.array[Rn] = Sn.x, Cn.array[Rn + 1] = Sn.y, Rn += 2; else if (3 === Cn.size)if ("c" === Cn.type)for (Hn = 0; Mn > Hn; Hn++)Sn = Cn.value[Hn], Cn.array[Rn] = Sn.r, Cn.array[Rn + 1] = Sn.g, Cn.array[Rn + 2] = Sn.b, Rn += 3; else for (Hn = 0; Mn > Hn; Hn++)Sn = Cn.value[Hn], Cn.array[Rn] = Sn.x, Cn.array[Rn + 1] = Sn.y, Cn.array[Rn + 2] = Sn.z, Rn += 3; else if (4 === Cn.size)for (Hn = 0; Mn > Hn; Hn++)Sn = Cn.value[Hn], Cn.array[Rn] = Sn.x, Cn.array[Rn + 1] = Sn.y, Cn.array[Rn + 2] = Sn.z, Cn.array[Rn + 3] = Sn.w, Rn += 4;
							Q.bindBuffer(Q.ARRAY_BUFFER, Cn.buffer), Q.bufferData(Q.ARRAY_BUFFER, Cn.array, An)
						}
					}
					f.verticesNeedUpdate = !1, f.colorsNeedUpdate = !1, f.lineDistancesNeedUpdate = !1, h.attributes && R(h)
				} else if (t instanceof THREE.PointCloud) {
					if (h = r(t, f), c = h.attributes && x(h), f.verticesNeedUpdate || f.colorsNeedUpdate || t.sortParticles || c) {
						var jn, Wn, Gn, Xn, qn, Yn, Kn, Zn, Qn, $n, Jn, er, tr = Q.DYNAMIC_DRAW, nr = f.vertices, rr = nr.length, ir = f.colors, or = ir.length, ar = f.__vertexArray, sr = f.__colorArray, lr = f.__sortArray, ur = f.verticesNeedUpdate, cr = f.colorsNeedUpdate, hr = f.__webglCustomAttributesList;
						if (t.sortParticles) {
							for (Pt.copy(kt), Pt.multiply(t.matrixWorld), jn = 0; rr > jn; jn++)Gn = nr[jn], Dt.copy(Gn), Dt.applyProjection(Pt), lr[jn] = [Dt.z, jn];
							for (lr.sort(d), jn = 0; rr > jn; jn++)Gn = nr[lr[jn][1]], Xn = 3 * jn, ar[Xn] = Gn.x, ar[Xn + 1] = Gn.y, ar[Xn + 2] = Gn.z;
							for (Wn = 0; or > Wn; Wn++)Xn = 3 * Wn, Yn = ir[lr[Wn][1]], sr[Xn] = Yn.r, sr[Xn + 1] = Yn.g, sr[Xn + 2] = Yn.b;
							if (hr)for (Kn = 0, Zn = hr.length; Zn > Kn; Kn++)if (er = hr[Kn], void 0 === er.boundTo || "vertices" === er.boundTo)if (Xn = 0, $n = er.value.length, 1 === er.size)for (Qn = 0; $n > Qn; Qn++)qn = lr[Qn][1], er.array[Qn] = er.value[qn]; else if (2 === er.size)for (Qn = 0; $n > Qn; Qn++)qn = lr[Qn][1], Jn = er.value[qn], er.array[Xn] = Jn.x, er.array[Xn + 1] = Jn.y, Xn += 2; else if (3 === er.size)if ("c" === er.type)for (Qn = 0; $n > Qn; Qn++)qn = lr[Qn][1], Jn = er.value[qn], er.array[Xn] = Jn.r, er.array[Xn + 1] = Jn.g, er.array[Xn + 2] = Jn.b, Xn += 3; else for (Qn = 0; $n > Qn; Qn++)qn = lr[Qn][1], Jn = er.value[qn], er.array[Xn] = Jn.x, er.array[Xn + 1] = Jn.y, er.array[Xn + 2] = Jn.z, Xn += 3; else if (4 === er.size)for (Qn = 0; $n > Qn; Qn++)qn = lr[Qn][1], Jn = er.value[qn], er.array[Xn] = Jn.x, er.array[Xn + 1] = Jn.y, er.array[Xn + 2] = Jn.z, er.array[Xn + 3] = Jn.w, Xn += 4
						} else {
							if (ur)for (jn = 0; rr > jn; jn++)Gn = nr[jn], Xn = 3 * jn, ar[Xn] = Gn.x, ar[Xn + 1] = Gn.y, ar[Xn + 2] = Gn.z;
							if (cr)for (Wn = 0; or > Wn; Wn++)Yn = ir[Wn], Xn = 3 * Wn, sr[Xn] = Yn.r, sr[Xn + 1] = Yn.g, sr[Xn + 2] = Yn.b;
							if (hr)for (Kn = 0, Zn = hr.length; Zn > Kn; Kn++)if (er = hr[Kn], er.needsUpdate && (void 0 === er.boundTo || "vertices" === er.boundTo))if ($n = er.value.length, Xn = 0, 1 === er.size)for (Qn = 0; $n > Qn; Qn++)er.array[Qn] = er.value[Qn]; else if (2 === er.size)for (Qn = 0; $n > Qn; Qn++)Jn = er.value[Qn], er.array[Xn] = Jn.x, er.array[Xn + 1] = Jn.y, Xn += 2; else if (3 === er.size)if ("c" === er.type)for (Qn = 0; $n > Qn; Qn++)Jn = er.value[Qn], er.array[Xn] = Jn.r, er.array[Xn + 1] = Jn.g, er.array[Xn + 2] = Jn.b, Xn += 3; else for (Qn = 0; $n > Qn; Qn++)Jn = er.value[Qn], er.array[Xn] = Jn.x, er.array[Xn + 1] = Jn.y, er.array[Xn + 2] = Jn.z, Xn += 3; else if (4 === er.size)for (Qn = 0; $n > Qn; Qn++)Jn = er.value[Qn], er.array[Xn] = Jn.x, er.array[Xn + 1] = Jn.y, er.array[Xn + 2] = Jn.z, er.array[Xn + 3] = Jn.w, Xn += 4
						}
						if ((ur || t.sortParticles) && (Q.bindBuffer(Q.ARRAY_BUFFER, f.__webglVertexBuffer), Q.bufferData(Q.ARRAY_BUFFER, ar, tr)), (cr || t.sortParticles) && (Q.bindBuffer(Q.ARRAY_BUFFER, f.__webglColorBuffer), Q.bufferData(Q.ARRAY_BUFFER, sr, tr)), hr)for (Kn = 0, Zn = hr.length; Zn > Kn; Kn++)er = hr[Kn], (er.needsUpdate || t.sortParticles) && (Q.bindBuffer(Q.ARRAY_BUFFER, er.buffer), Q.bufferData(Q.ARRAY_BUFFER, er.array, tr))
					}
					f.verticesNeedUpdate = !1, f.colorsNeedUpdate = !1, h.attributes && R(h)
				}
				for (var fr = 0, dr = l.length; dr > fr; fr++) {
					var pr = l[fr], mr = pr, gr = mr.object, Er = mr.buffer, vr = gr.geometry, yr = gr.material;
					yr instanceof THREE.MeshFaceMaterial ? (yr = yr.materials[vr instanceof THREE.BufferGeometry ? 0 : Er.materialIndex], yr.transparent ? (mr.material = yr, Z.push(mr)) : (mr.material = yr, K.push(mr))) : yr && (yr.transparent ? (mr.material = yr, Z.push(mr)) : (mr.material = yr, K.push(mr))), pr.render = !0, !0 === rt.sortObjects && (null !== t.renderDepth ? pr.z = t.renderDepth : (Dt.setFromMatrixPosition(t.matrixWorld), Dt.applyProjection(kt), pr.z = Dt.z))
				}
			}
			for (fr = 0, dr = t.children.length; dr > fr; fr++)p(e, t.children[fr], s)
		}
	}

	function m(e, t, n) {
		if (0 !== e.length)for (var r = 0, i = e.length; i > r; r++)ut = ot = null, st = lt = ft = ht = vt = Et = dt = -1, Nt = !0, e[r].render(t, n, Mt, St), ut = ot = null, st = lt = ft = ht = vt = Et = dt = -1, Nt = !0
	}

	function g(e, t, n, r, i, o) {
		for (var a, s, l, u = e.length - 1; -1 !== u; u--) {
			if (a = e[u], s = a.object, l = a.buffer, M(s, t), o)a = o; else {
				if (a = a.material, !a)continue;
				i && rt.setBlending(a.blending, a.blendEquation, a.blendSrc, a.blendDst), rt.setDepthTest(a.depthTest), rt.setDepthWrite(a.depthWrite), L(a.polygonOffset, a.polygonOffsetFactor, a.polygonOffsetUnits)
			}
			rt.setMaterialFaces(a), l instanceof THREE.BufferGeometry ? rt.renderBufferDirect(t, n, r, a, l, s) : rt.renderBuffer(t, n, r, a, l, s)
		}
	}

	function E(e, t, n, r, i, o, a) {
		for (var s, l, u = 0, c = e.length; c > u; u++)if (s = e[u], l = s.object, l.visible) {
			if (a)s = a; else {
				if (s = s[t], !s)continue;
				o && rt.setBlending(s.blending, s.blendEquation, s.blendSrc, s.blendDst), rt.setDepthTest(s.depthTest), rt.setDepthWrite(s.depthWrite), L(s.polygonOffset, s.polygonOffsetFactor, s.polygonOffsetUnits)
			}
			rt.renderImmediateObject(n, r, i, s, l)
		}
	}

	function v(e) {
		var t = e.object.material;
		t.transparent ? (e.transparent = t, e.opaque = null) : (e.opaque = t, e.transparent = null)
	}

	function y(e, t, r) {
		var i, o = !1;
		i = t.material, (void 0 === r.geometryGroups || r.groupsNeedUpdate) && (delete e.__webglObjects[t.id], r.makeGroups(i instanceof THREE.MeshFaceMaterial, nt ? 4294967296 : 65535), r.groupsNeedUpdate = !1);
		for (var a = 0, s = r.geometryGroupsList.length; s > a; a++) {
			if (i = r.geometryGroupsList[a], i.__webglVertexBuffer)o = !1; else {
				o = i, o.__webglVertexBuffer = Q.createBuffer(), o.__webglNormalBuffer = Q.createBuffer(), o.__webglTangentBuffer = Q.createBuffer(), o.__webglColorBuffer = Q.createBuffer(), o.__webglUVBuffer = Q.createBuffer(), o.__webglUV2Buffer = Q.createBuffer(), o.__webglSkinIndicesBuffer = Q.createBuffer(), o.__webglSkinWeightsBuffer = Q.createBuffer(), o.__webglFaceBuffer = Q.createBuffer(), o.__webglLineBuffer = Q.createBuffer();
				var l = void 0, u = void 0;
				if (o.numMorphTargets)for (o.__webglMorphTargetsBuffers = [], l = 0, u = o.numMorphTargets; u > l; l++)o.__webglMorphTargetsBuffers.push(Q.createBuffer());
				if (o.numMorphNormals)for (o.__webglMorphNormalsBuffers = [], l = 0, u = o.numMorphNormals; u > l; l++)o.__webglMorphNormalsBuffers.push(Q.createBuffer());
				rt.info.memory.geometries++, n(i, t), r.verticesNeedUpdate = !0, r.morphTargetsNeedUpdate = !0, r.elementsNeedUpdate = !0, r.uvsNeedUpdate = !0, r.normalsNeedUpdate = !0, r.tangentsNeedUpdate = !0, o = r.colorsNeedUpdate = !0
			}
			(o || void 0 === t.__webglActive) && T(e.__webglObjects, i, t)
		}
		t.__webglActive = !0
	}

	function T(e, t, n) {
		var r = n.id;
		e[r] = e[r] || [], e[r].push({id: r, buffer: t, object: n, material: null, z: 0})
	}

	function x(e) {
		for (var t in e.attributes)if (e.attributes[t].needsUpdate)return!0;
		return!1
	}

	function R(e) {
		for (var t in e.attributes)e.attributes[t].needsUpdate = !1
	}

	function b(e, t) {
		if (e instanceof THREE.Mesh || e instanceof THREE.PointCloud || e instanceof THREE.Line)delete t.__webglObjects[e.id]; else if (e instanceof THREE.ImmediateRenderObject || e.immediateRenderCallback)for (var n = t.__webglObjectsImmediate, r = n.length - 1; r >= 0; r--)n[r].object === e && n.splice(r, 1);
		delete e.__webglActive
	}

	function _(e, t, n, r, i) {
		ct = 0, r.needsUpdate && (r.program && tn(r), rt.initMaterial(r, t, n, i), r.needsUpdate = !1), r.morphTargets && !i.__webglMorphTargetInfluences && (i.__webglMorphTargetInfluences = new Float32Array(rt.maxMorphTargets));
		var o = !1, a = !1, s = !1, l = r.program, u = l.uniforms, c = r.__webglShader.uniforms;
		if (l.id !== ot && (Q.useProgram(l.program), ot = l.id, s = a = o = !0), r.id !== st && (-1 === st && (s = !0), st = r.id, a = !0), (o || e !== ut) && (Q.uniformMatrix4fv(u.projectionMatrix, !1, e.projectionMatrix.elements), X && Q.uniform1f(u.logDepthBufFC, 2 / (Math.log(e.far + 1) / Math.LN2)), e !== ut && (ut = e), (r instanceof THREE.ShaderMaterial || r instanceof THREE.MeshPhongMaterial || r.envMap) && null !== u.cameraPosition && (Dt.setFromMatrixPosition(e.matrixWorld), Q.uniform3f(u.cameraPosition, Dt.x, Dt.y, Dt.z)), (r instanceof THREE.MeshPhongMaterial || r instanceof THREE.MeshLambertMaterial || r instanceof THREE.ShaderMaterial || r.skinning) && null !== u.viewMatrix && Q.uniformMatrix4fv(u.viewMatrix, !1, e.matrixWorldInverse.elements)), r.skinning && (i.bindMatrix && null !== u.bindMatrix && Q.uniformMatrix4fv(u.bindMatrix, !1, i.bindMatrix.elements), i.bindMatrixInverse && null !== u.bindMatrixInverse && Q.uniformMatrix4fv(u.bindMatrixInverse, !1, i.bindMatrixInverse.elements), jt && i.skeleton && i.skeleton.useVertexTexture ? (null !== u.boneTexture && (o = H(), Q.uniform1i(u.boneTexture, o), rt.setTexture(i.skeleton.boneTexture, o)), null !== u.boneTextureWidth && Q.uniform1i(u.boneTextureWidth, i.skeleton.boneTextureWidth), null !== u.boneTextureHeight && Q.uniform1i(u.boneTextureHeight, i.skeleton.boneTextureHeight)) : i.skeleton && i.skeleton.boneMatrices && null !== u.boneGlobalMatrices && Q.uniformMatrix4fv(u.boneGlobalMatrices, !1, i.skeleton.boneMatrices)), a) {
			if (n && r.fog && (c.fogColor.value = n.color, n instanceof THREE.Fog ? (c.fogNear.value = n.near, c.fogFar.value = n.far) : n instanceof THREE.FogExp2 && (c.fogDensity.value = n.density)), r instanceof THREE.MeshPhongMaterial || r instanceof THREE.MeshLambertMaterial || r.lights) {
				if (Nt) {
					var h, f, d, p, s = !0, m = o = 0, g = 0, E = zt, v = E.directional.colors, y = E.directional.positions, T = E.point.colors, x = E.point.positions, R = E.point.distances, b = E.spot.colors, _ = E.spot.positions, M = E.spot.distances, A = E.spot.directions, L = E.spot.anglesCos, P = E.spot.exponents, D = E.hemi.skyColors, F = E.hemi.groundColors, U = E.hemi.positions, V = 0, B = 0, O = 0, I = 0, j = 0, W = 0, G = 0, q = 0, Y = h = 0;
					for (n = p = Y = 0, a = t.length; a > n; n++)h = t[n], h.onlyShadow || (f = h.color, d = h.intensity, p = h.distance, h instanceof THREE.AmbientLight ? h.visible && (rt.gammaInput ? (o += f.r * f.r, m += f.g * f.g, g += f.b * f.b) : (o += f.r, m += f.g, g += f.b)) : h instanceof THREE.DirectionalLight ? (j += 1, h.visible && (Ft.setFromMatrixPosition(h.matrixWorld), Dt.setFromMatrixPosition(h.target.matrixWorld), Ft.sub(Dt), Ft.normalize(), h = 3 * V, y[h] = Ft.x, y[h + 1] = Ft.y, y[h + 2] = Ft.z, rt.gammaInput ? S(v, h, f, d * d) : C(v, h, f, d), V += 1)) : h instanceof THREE.PointLight ? (W += 1, h.visible && (Y = 3 * B, rt.gammaInput ? S(T, Y, f, d * d) : C(T, Y, f, d), Dt.setFromMatrixPosition(h.matrixWorld), x[Y] = Dt.x, x[Y + 1] = Dt.y, x[Y + 2] = Dt.z, R[B] = p, B += 1)) : h instanceof THREE.SpotLight ? (G += 1, h.visible && (Y = 3 * O, rt.gammaInput ? S(b, Y, f, d * d) : C(b, Y, f, d), Dt.setFromMatrixPosition(h.matrixWorld), _[Y] = Dt.x, _[Y + 1] = Dt.y, _[Y + 2] = Dt.z, M[O] = p, Ft.copy(Dt), Dt.setFromMatrixPosition(h.target.matrixWorld), Ft.sub(Dt), Ft.normalize(), A[Y] = Ft.x, A[Y + 1] = Ft.y, A[Y + 2] = Ft.z, L[O] = Math.cos(h.angle), P[O] = h.exponent, O += 1)) : h instanceof THREE.HemisphereLight && (q += 1, h.visible && (Ft.setFromMatrixPosition(h.matrixWorld), Ft.normalize(), p = 3 * I, U[p] = Ft.x, U[p + 1] = Ft.y, U[p + 2] = Ft.z, f = h.color, h = h.groundColor, rt.gammaInput ? (d *= d, S(D, p, f, d), S(F, p, h, d)) : (C(D, p, f, d), C(F, p, h, d)), I += 1)));
					for (n = 3 * V, a = Math.max(v.length, 3 * j); a > n; n++)v[n] = 0;
					for (n = 3 * B, a = Math.max(T.length, 3 * W); a > n; n++)T[n] = 0;
					for (n = 3 * O, a = Math.max(b.length, 3 * G); a > n; n++)b[n] = 0;
					for (n = 3 * I, a = Math.max(D.length, 3 * q); a > n; n++)D[n] = 0;
					for (n = 3 * I, a = Math.max(F.length, 3 * q); a > n; n++)F[n] = 0;
					E.directional.length = V, E.point.length = B, E.spot.length = O, E.hemi.length = I, E.ambient[0] = o, E.ambient[1] = m, E.ambient[2] = g, Nt = !1
				}
				s ? (s = zt, c.ambientLightColor.value = s.ambient, c.directionalLightColor.value = s.directional.colors, c.directionalLightDirection.value = s.directional.positions, c.pointLightColor.value = s.point.colors, c.pointLightPosition.value = s.point.positions, c.pointLightDistance.value = s.point.distances, c.spotLightColor.value = s.spot.colors, c.spotLightPosition.value = s.spot.positions, c.spotLightDistance.value = s.spot.distances, c.spotLightDirection.value = s.spot.directions, c.spotLightAngleCos.value = s.spot.anglesCos, c.spotLightExponent.value = s.spot.exponents, c.hemisphereLightSkyColor.value = s.hemi.skyColors, c.hemisphereLightGroundColor.value = s.hemi.groundColors, c.hemisphereLightDirection.value = s.hemi.positions, w(c, !0)) : w(c, !1)
			}
			if (r instanceof THREE.MeshBasicMaterial || r instanceof THREE.MeshLambertMaterial || r instanceof THREE.MeshPhongMaterial) {
				c.opacity.value = r.opacity, rt.gammaInput ? c.diffuse.value.copyGammaToLinear(r.color) : c.diffuse.value = r.color, c.map.value = r.map, c.lightMap.value = r.lightMap, c.specularMap.value = r.specularMap, c.alphaMap.value = r.alphaMap, r.bumpMap && (c.bumpMap.value = r.bumpMap, c.bumpScale.value = r.bumpScale), r.normalMap && (c.normalMap.value = r.normalMap, c.normalScale.value.copy(r.normalScale));
				var K;
				r.map ? K = r.map : r.specularMap ? K = r.specularMap : r.normalMap ? K = r.normalMap : r.bumpMap ? K = r.bumpMap : r.alphaMap && (K = r.alphaMap), void 0 !== K && (s = K.offset, K = K.repeat, c.offsetRepeat.value.set(s.x, s.y, K.x, K.y)), c.envMap.value = r.envMap, c.flipEnvMap.value = r.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1, c.reflectivity.value = r.reflectivity, c.refractionRatio.value = r.refractionRatio, c.combine.value = r.combine, c.useRefract.value = r.envMap && r.envMap.mapping instanceof THREE.CubeRefractionMapping
			}
			if (r instanceof THREE.LineBasicMaterial ? (c.diffuse.value = r.color, c.opacity.value = r.opacity) : r instanceof THREE.LineDashedMaterial ? (c.diffuse.value = r.color, c.opacity.value = r.opacity, c.dashSize.value = r.dashSize, c.totalSize.value = r.dashSize + r.gapSize, c.scale.value = r.scale) : r instanceof THREE.PointCloudMaterial ? (c.psColor.value = r.color, c.opacity.value = r.opacity, c.size.value = r.size, c.scale.value = z.height / 2, c.map.value = r.map) : r instanceof THREE.MeshPhongMaterial ? (c.shininess.value = r.shininess, rt.gammaInput ? (c.ambient.value.copyGammaToLinear(r.ambient), c.emissive.value.copyGammaToLinear(r.emissive), c.specular.value.copyGammaToLinear(r.specular)) : (c.ambient.value = r.ambient, c.emissive.value = r.emissive, c.specular.value = r.specular), r.wrapAround && c.wrapRGB.value.copy(r.wrapRGB)) : r instanceof THREE.MeshLambertMaterial ? (rt.gammaInput ? (c.ambient.value.copyGammaToLinear(r.ambient), c.emissive.value.copyGammaToLinear(r.emissive)) : (c.ambient.value = r.ambient, c.emissive.value = r.emissive), r.wrapAround && c.wrapRGB.value.copy(r.wrapRGB)) : r instanceof THREE.MeshDepthMaterial ? (c.mNear.value = e.near, c.mFar.value = e.far, c.opacity.value = r.opacity) : r instanceof THREE.MeshNormalMaterial && (c.opacity.value = r.opacity), i.receiveShadow && !r._shadowPass && c.shadowMatrix)for (K = e = 0, s = t.length; s > K; K++)n = t[K], n.castShadow && (n instanceof THREE.SpotLight || n instanceof THREE.DirectionalLight && !n.shadowCascade) && (c.shadowMap.value[e] = n.shadowMap, c.shadowMapSize.value[e] = n.shadowMapSize, c.shadowMatrix.value[e] = n.shadowMatrix, c.shadowDarkness.value[e] = n.shadowDarkness, c.shadowBias.value[e] = n.shadowBias, e++);
			for (t = r.uniformsList, r = 0, c = t.length; c > r; r++)if (e = t[r][0], !1 !== e.needsUpdate)switch (n = e.type, s = e.value, K = t[r][1], n) {
				case"1i":
					Q.uniform1i(K, s);
					break;
				case"1f":
					Q.uniform1f(K, s);
					break;
				case"2f":
					Q.uniform2f(K, s[0], s[1]);
					break;
				case"3f":
					Q.uniform3f(K, s[0], s[1], s[2]);
					break;
				case"4f":
					Q.uniform4f(K, s[0], s[1], s[2], s[3]);
					break;
				case"1iv":
					Q.uniform1iv(K, s);
					break;
				case"3iv":
					Q.uniform3iv(K, s);
					break;
				case"1fv":
					Q.uniform1fv(K, s);
					break;
				case"2fv":
					Q.uniform2fv(K, s);
					break;
				case"3fv":
					Q.uniform3fv(K, s);
					break;
				case"4fv":
					Q.uniform4fv(K, s);
					break;
				case"Matrix3fv":
					Q.uniformMatrix3fv(K, !1, s);
					break;
				case"Matrix4fv":
					Q.uniformMatrix4fv(K, !1, s);
					break;
				case"i":
					Q.uniform1i(K, s);
					break;
				case"f":
					Q.uniform1f(K, s);
					break;
				case"v2":
					Q.uniform2f(K, s.x, s.y);
					break;
				case"v3":
					Q.uniform3f(K, s.x, s.y, s.z);
					break;
				case"v4":
					Q.uniform4f(K, s.x, s.y, s.z, s.w);
					break;
				case"c":
					Q.uniform3f(K, s.r, s.g, s.b);
					break;
				case"iv1":
					Q.uniform1iv(K, s);
					break;
				case"iv":
					Q.uniform3iv(K, s);
					break;
				case"fv1":
					Q.uniform1fv(K, s);
					break;
				case"fv":
					Q.uniform3fv(K, s);
					break;
				case"v2v":
					for (void 0 === e._array && (e._array = new Float32Array(2 * s.length)), n = 0, a = s.length; a > n; n++)o = 2 * n, e._array[o] = s[n].x, e._array[o + 1] = s[n].y;
					Q.uniform2fv(K, e._array);
					break;
				case"v3v":
					for (void 0 === e._array && (e._array = new Float32Array(3 * s.length)), n = 0, a = s.length; a > n; n++)o = 3 * n, e._array[o] = s[n].x, e._array[o + 1] = s[n].y, e._array[o + 2] = s[n].z;
					Q.uniform3fv(K, e._array);
					break;
				case"v4v":
					for (void 0 === e._array && (e._array = new Float32Array(4 * s.length)), n = 0, a = s.length; a > n; n++)o = 4 * n, e._array[o] = s[n].x, e._array[o + 1] = s[n].y, e._array[o + 2] = s[n].z, e._array[o + 3] = s[n].w;
					Q.uniform4fv(K, e._array);
					break;
				case"m3":
					Q.uniformMatrix3fv(K, !1, s.elements);
					break;
				case"m3v":
					for (void 0 === e._array && (e._array = new Float32Array(9 * s.length)), n = 0, a = s.length; a > n; n++)s[n].flattenToArrayOffset(e._array, 9 * n);
					Q.uniformMatrix3fv(K, !1, e._array);
					break;
				case"m4":
					Q.uniformMatrix4fv(K, !1, s.elements);
					break;
				case"m4v":
					for (void 0 === e._array && (e._array = new Float32Array(16 * s.length)), n = 0, a = s.length; a > n; n++)s[n].flattenToArrayOffset(e._array, 16 * n);
					Q.uniformMatrix4fv(K, !1, e._array);
					break;
				case"t":
					if (o = s, s = H(), Q.uniform1i(K, s), !o)continue;
					if (o instanceof THREE.CubeTexture || o.image instanceof Array && 6 === o.image.length) {
						if (e = o, K = s, 6 === e.image.length)if (e.needsUpdate) {
							for (e.image.__webglTextureCube || (e.addEventListener("dispose", Qt), e.image.__webglTextureCube = Q.createTexture(), rt.info.memory.textures++), Q.activeTexture(Q.TEXTURE0 + K), Q.bindTexture(Q.TEXTURE_CUBE_MAP, e.image.__webglTextureCube), Q.pixelStorei(Q.UNPACK_FLIP_Y_WEBGL, e.flipY), K = e instanceof THREE.CompressedTexture, s = [], n = 0; 6 > n; n++)rt.autoScaleCubemaps && !K ? (a = s, o = n, m = e.image[n], E = Bt, m.width <= E && m.height <= E || (v = Math.max(m.width, m.height), g = Math.floor(m.width * E / v), E = Math.floor(m.height * E / v), v = document.createElement("canvas"), v.width = g, v.height = E, v.getContext("2d").drawImage(m, 0, 0, m.width, m.height, 0, 0, g, E), m = v), a[o] = m) : s[n] = e.image[n];
							for (n = s[0], a = THREE.Math.isPowerOfTwo(n.width) && THREE.Math.isPowerOfTwo(n.height), o = N(e.format), m = N(e.type), k(Q.TEXTURE_CUBE_MAP, e, a), n = 0; 6 > n; n++)if (K)for (E = s[n].mipmaps, v = 0, y = E.length; y > v; v++)g = E[v], e.format !== THREE.RGBAFormat ? Q.compressedTexImage2D(Q.TEXTURE_CUBE_MAP_POSITIVE_X + n, v, o, g.width, g.height, 0, g.data) : Q.texImage2D(Q.TEXTURE_CUBE_MAP_POSITIVE_X + n, v, o, g.width, g.height, 0, o, m, g.data); else Q.texImage2D(Q.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0, o, o, m, s[n]);
							e.generateMipmaps && a && Q.generateMipmap(Q.TEXTURE_CUBE_MAP), e.needsUpdate = !1, e.onUpdate && e.onUpdate()
						} else Q.activeTexture(Q.TEXTURE0 + K), Q.bindTexture(Q.TEXTURE_CUBE_MAP, e.image.__webglTextureCube)
					} else o instanceof THREE.WebGLRenderTargetCube ? (e = o, Q.activeTexture(Q.TEXTURE0 + s), Q.bindTexture(Q.TEXTURE_CUBE_MAP, e.__webglTexture)) : rt.setTexture(o, s);
					break;
				case"tv":
					for (void 0 === e._array && (e._array = []), n = 0, a = e.value.length; a > n; n++)e._array[n] = H();
					for (Q.uniform1iv(K, e._array), n = 0, a = e.value.length; a > n; n++)o = e.value[n], s = e._array[n], o && rt.setTexture(o, s);
					break;
				default:
					console.warn("THREE.WebGLRenderer: Unknown uniform type: " + n)
			}
		}
		return Q.uniformMatrix4fv(u.modelViewMatrix, !1, i._modelViewMatrix.elements), u.normalMatrix && Q.uniformMatrix3fv(u.normalMatrix, !1, i._normalMatrix.elements), null !== u.modelMatrix && Q.uniformMatrix4fv(u.modelMatrix, !1, i.matrixWorld.elements), l
	}

	function w(e, t) {
		e.ambientLightColor.needsUpdate = t, e.directionalLightColor.needsUpdate = t, e.directionalLightDirection.needsUpdate = t, e.pointLightColor.needsUpdate = t, e.pointLightPosition.needsUpdate = t, e.pointLightDistance.needsUpdate = t, e.spotLightColor.needsUpdate = t, e.spotLightPosition.needsUpdate = t, e.spotLightDistance.needsUpdate = t, e.spotLightDirection.needsUpdate = t, e.spotLightAngleCos.needsUpdate = t, e.spotLightExponent.needsUpdate = t, e.hemisphereLightSkyColor.needsUpdate = t, e.hemisphereLightGroundColor.needsUpdate = t, e.hemisphereLightDirection.needsUpdate = t
	}

	function H() {
		var e = ct;
		return e >= Ut && console.warn("WebGLRenderer: trying to use " + e + " texture units while this GPU supports only " + Ut), ct += 1, e
	}

	function M(e, t) {
		e._modelViewMatrix.multiplyMatrices(t.matrixWorldInverse, e.matrixWorld), e._normalMatrix.getNormalMatrix(e._modelViewMatrix)
	}

	function S(e, t, n, r) {
		e[t] = n.r * n.r * r, e[t + 1] = n.g * n.g * r, e[t + 2] = n.b * n.b * r
	}

	function C(e, t, n, r) {
		e[t] = n.r * r, e[t + 1] = n.g * r, e[t + 2] = n.b * r
	}

	function A(e) {
		e !== Rt && (Q.lineWidth(e), Rt = e)
	}

	function L(e, t, n) {
		yt !== e && (e ? Q.enable(Q.POLYGON_OFFSET_FILL) : Q.disable(Q.POLYGON_OFFSET_FILL), yt = e), !e || Tt === t && xt === n || (Q.polygonOffset(t, n), Tt = t, xt = n)
	}

	function k(e, t, n) {
		n ? (Q.texParameteri(e, Q.TEXTURE_WRAP_S, N(t.wrapS)), Q.texParameteri(e, Q.TEXTURE_WRAP_T, N(t.wrapT)), Q.texParameteri(e, Q.TEXTURE_MAG_FILTER, N(t.magFilter)), Q.texParameteri(e, Q.TEXTURE_MIN_FILTER, N(t.minFilter))) : (Q.texParameteri(e, Q.TEXTURE_WRAP_S, Q.CLAMP_TO_EDGE), Q.texParameteri(e, Q.TEXTURE_WRAP_T, Q.CLAMP_TO_EDGE), Q.texParameteri(e, Q.TEXTURE_MAG_FILTER, F(t.magFilter)), Q.texParameteri(e, Q.TEXTURE_MIN_FILTER, F(t.minFilter))), et && t.type !== THREE.FloatType && (1 < t.anisotropy || t.__oldAnisotropy) && (Q.texParameterf(e, et.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t.anisotropy, Ot)), t.__oldAnisotropy = t.anisotropy)
	}

	function P(e, t) {
		Q.bindRenderbuffer(Q.RENDERBUFFER, e), t.depthBuffer && !t.stencilBuffer ? (Q.renderbufferStorage(Q.RENDERBUFFER, Q.DEPTH_COMPONENT16, t.width, t.height), Q.framebufferRenderbuffer(Q.FRAMEBUFFER, Q.DEPTH_ATTACHMENT, Q.RENDERBUFFER, e)) : t.depthBuffer && t.stencilBuffer ? (Q.renderbufferStorage(Q.RENDERBUFFER, Q.DEPTH_STENCIL, t.width, t.height), Q.framebufferRenderbuffer(Q.FRAMEBUFFER, Q.DEPTH_STENCIL_ATTACHMENT, Q.RENDERBUFFER, e)) : Q.renderbufferStorage(Q.RENDERBUFFER, Q.RGBA4, t.width, t.height)
	}

	function D(e) {
		e instanceof THREE.WebGLRenderTargetCube ? (Q.bindTexture(Q.TEXTURE_CUBE_MAP, e.__webglTexture), Q.generateMipmap(Q.TEXTURE_CUBE_MAP), Q.bindTexture(Q.TEXTURE_CUBE_MAP, null)) : (Q.bindTexture(Q.TEXTURE_2D, e.__webglTexture), Q.generateMipmap(Q.TEXTURE_2D), Q.bindTexture(Q.TEXTURE_2D, null))
	}

	function F(e) {
		return e === THREE.NearestFilter || e === THREE.NearestMipMapNearestFilter || e === THREE.NearestMipMapLinearFilter ? Q.NEAREST : Q.LINEAR
	}

	function N(e) {
		if (e === THREE.RepeatWrapping)return Q.REPEAT;
		if (e === THREE.ClampToEdgeWrapping)return Q.CLAMP_TO_EDGE;
		if (e === THREE.MirroredRepeatWrapping)return Q.MIRRORED_REPEAT;
		if (e === THREE.NearestFilter)return Q.NEAREST;
		if (e === THREE.NearestMipMapNearestFilter)return Q.NEAREST_MIPMAP_NEAREST;
		if (e === THREE.NearestMipMapLinearFilter)return Q.NEAREST_MIPMAP_LINEAR;
		if (e === THREE.LinearFilter)return Q.LINEAR;
		if (e === THREE.LinearMipMapNearestFilter)return Q.LINEAR_MIPMAP_NEAREST;
		if (e === THREE.LinearMipMapLinearFilter)return Q.LINEAR_MIPMAP_LINEAR;
		if (e === THREE.UnsignedByteType)return Q.UNSIGNED_BYTE;
		if (e === THREE.UnsignedShort4444Type)return Q.UNSIGNED_SHORT_4_4_4_4;
		if (e === THREE.UnsignedShort5551Type)return Q.UNSIGNED_SHORT_5_5_5_1;
		if (e === THREE.UnsignedShort565Type)return Q.UNSIGNED_SHORT_5_6_5;
		if (e === THREE.ByteType)return Q.BYTE;
		if (e === THREE.ShortType)return Q.SHORT;
		if (e === THREE.UnsignedShortType)return Q.UNSIGNED_SHORT;
		if (e === THREE.IntType)return Q.INT;
		if (e === THREE.UnsignedIntType)return Q.UNSIGNED_INT;
		if (e === THREE.FloatType)return Q.FLOAT;
		if (e === THREE.AlphaFormat)return Q.ALPHA;
		if (e === THREE.RGBFormat)return Q.RGB;
		if (e === THREE.RGBAFormat)return Q.RGBA;
		if (e === THREE.LuminanceFormat)return Q.LUMINANCE;
		if (e === THREE.LuminanceAlphaFormat)return Q.LUMINANCE_ALPHA;
		if (e === THREE.AddEquation)return Q.FUNC_ADD;
		if (e === THREE.SubtractEquation)return Q.FUNC_SUBTRACT;
		if (e === THREE.ReverseSubtractEquation)return Q.FUNC_REVERSE_SUBTRACT;
		if (e === THREE.ZeroFactor)return Q.ZERO;
		if (e === THREE.OneFactor)return Q.ONE;
		if (e === THREE.SrcColorFactor)return Q.SRC_COLOR;
		if (e === THREE.OneMinusSrcColorFactor)return Q.ONE_MINUS_SRC_COLOR;
		if (e === THREE.SrcAlphaFactor)return Q.SRC_ALPHA;
		if (e === THREE.OneMinusSrcAlphaFactor)return Q.ONE_MINUS_SRC_ALPHA;
		if (e === THREE.DstAlphaFactor)return Q.DST_ALPHA;
		if (e === THREE.OneMinusDstAlphaFactor)return Q.ONE_MINUS_DST_ALPHA;
		if (e === THREE.DstColorFactor)return Q.DST_COLOR;
		if (e === THREE.OneMinusDstColorFactor)return Q.ONE_MINUS_DST_COLOR;
		if (e === THREE.SrcAlphaSaturateFactor)return Q.SRC_ALPHA_SATURATE;
		if (void 0 !== tt) {
			if (e === THREE.RGB_S3TC_DXT1_Format)return tt.COMPRESSED_RGB_S3TC_DXT1_EXT;
			if (e === THREE.RGBA_S3TC_DXT1_Format)return tt.COMPRESSED_RGBA_S3TC_DXT1_EXT;
			if (e === THREE.RGBA_S3TC_DXT3_Format)return tt.COMPRESSED_RGBA_S3TC_DXT3_EXT;
			if (e === THREE.RGBA_S3TC_DXT5_Format)return tt.COMPRESSED_RGBA_S3TC_DXT5_EXT
		}
		return 0
	}

	console.log("THREE.WebGLRenderer", THREE.REVISION), e = e || {};
	var z = void 0 !== e.canvas ? e.canvas : document.createElement("canvas"), U = void 0 !== e.context ? e.context : null, V = void 0 !== e.precision ? e.precision : "highp", B = void 0 !== e.alpha ? e.alpha : !1, O = void 0 !== e.depth ? e.depth : !0, I = void 0 !== e.stencil ? e.stencil : !0, j = void 0 !== e.antialias ? e.antialias : !1, W = void 0 !== e.premultipliedAlpha ? e.premultipliedAlpha : !0, G = void 0 !== e.preserveDrawingBuffer ? e.preserveDrawingBuffer : !1, X = void 0 !== e.logarithmicDepthBuffer ? e.logarithmicDepthBuffer : !1, q = new THREE.Color(0), Y = 0, K = [], Z = [];
	this.domElement = z, this.context = null, this.devicePixelRatio = void 0 !== e.devicePixelRatio ? e.devicePixelRatio : void 0 !== self.devicePixelRatio ? self.devicePixelRatio : 1, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.shadowMapEnabled = this.gammaOutput = this.gammaInput = !1, this.shadowMapAutoUpdate = !0, this.shadowMapType = THREE.PCFShadowMap, this.shadowMapCullFace = THREE.CullFaceFront, this.shadowMapCascade = this.shadowMapDebug = !1, this.maxMorphTargets = 8, this.maxMorphNormals = 4, this.autoScaleCubemaps = !0, this.renderPluginsPre = [], this.renderPluginsPost = [], this.info = {memory: {programs: 0, geometries: 0, textures: 0}, render: {calls: 0, vertices: 0, faces: 0, points: 0}};
	var Q, $, J, et, tt, nt, rt = this, it = [], ot = null, at = null, st = -1, lt = null, ut = null, ct = 0, ht = -1, ft = -1, dt = -1, pt = -1, mt = -1, gt = -1, Et = -1, vt = -1, yt = null, Tt = null, xt = null, Rt = null, bt = 0, _t = 0, wt = z.width, Ht = z.height, Mt = 0, St = 0, Ct = new Uint8Array(16), At = new Uint8Array(16), Lt = new THREE.Frustum, kt = new THREE.Matrix4, Pt = new THREE.Matrix4, Dt = new THREE.Vector3, Ft = new THREE.Vector3, Nt = !0, zt = {ambient: [0, 0, 0], directional: {length: 0, colors: [], positions: []}, point: {length: 0, colors: [], positions: [], distances: []}, spot: {length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: []}, hemi: {length: 0, skyColors: [], groundColors: [], positions: []}};
	!function () {
		try {
			var e = {alpha: B, depth: O, stencil: I, antialias: j, premultipliedAlpha: W, preserveDrawingBuffer: G};
			if (Q = U || z.getContext("webgl", e) || z.getContext("experimental-webgl", e), null === Q)throw"Error creating WebGL context."
		} catch (t) {
			console.error(t)
		}
		$ = Q.getExtension("OES_texture_float"), Q.getExtension("OES_texture_float_linear"), J = Q.getExtension("OES_standard_derivatives"), et = Q.getExtension("EXT_texture_filter_anisotropic") || Q.getExtension("MOZ_EXT_texture_filter_anisotropic") || Q.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), tt = Q.getExtension("WEBGL_compressed_texture_s3tc") || Q.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || Q.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"), nt = Q.getExtension("OES_element_index_uint"), null === $ && console.log("THREE.WebGLRenderer: Float textures not supported."), null === J && console.log("THREE.WebGLRenderer: Standard derivatives not supported."), null === et && console.log("THREE.WebGLRenderer: Anisotropic texture filtering not supported."), null === tt && console.log("THREE.WebGLRenderer: S3TC compressed textures not supported."), null === nt && console.log("THREE.WebGLRenderer: elementindex as unsigned integer not supported."), void 0 === Q.getShaderPrecisionFormat && (Q.getShaderPrecisionFormat = function () {
			return{rangeMin: 1, rangeMax: 1, precision: 1}
		}), X && Q.getExtension("EXT_frag_depth")
	}(), Q.clearColor(0, 0, 0, 1), Q.clearDepth(1), Q.clearStencil(0), Q.enable(Q.DEPTH_TEST), Q.depthFunc(Q.LEQUAL), Q.frontFace(Q.CCW), Q.cullFace(Q.BACK), Q.enable(Q.CULL_FACE), Q.enable(Q.BLEND), Q.blendEquation(Q.FUNC_ADD), Q.blendFunc(Q.SRC_ALPHA, Q.ONE_MINUS_SRC_ALPHA), Q.viewport(bt, _t, wt, Ht), Q.clearColor(q.r, q.g, q.b, Y), this.context = Q;
	var Ut = Q.getParameter(Q.MAX_TEXTURE_IMAGE_UNITS), Vt = Q.getParameter(Q.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
	Q.getParameter(Q.MAX_TEXTURE_SIZE);
	var Bt = Q.getParameter(Q.MAX_CUBE_MAP_TEXTURE_SIZE), Ot = et ? Q.getParameter(et.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0, It = Vt > 0, jt = It && $;
	tt && Q.getParameter(Q.COMPRESSED_TEXTURE_FORMATS);
	var Wt = Q.getShaderPrecisionFormat(Q.VERTEX_SHADER, Q.HIGH_FLOAT), Gt = Q.getShaderPrecisionFormat(Q.VERTEX_SHADER, Q.MEDIUM_FLOAT);
	Q.getShaderPrecisionFormat(Q.VERTEX_SHADER, Q.LOW_FLOAT);
	var Xt = Q.getShaderPrecisionFormat(Q.FRAGMENT_SHADER, Q.HIGH_FLOAT), qt = Q.getShaderPrecisionFormat(Q.FRAGMENT_SHADER, Q.MEDIUM_FLOAT);
	Q.getShaderPrecisionFormat(Q.FRAGMENT_SHADER, Q.LOW_FLOAT);
	var Yt = 0 < Wt.precision && 0 < Xt.precision, Kt = 0 < Gt.precision && 0 < qt.precision;
	"highp" !== V || Yt || (Kt ? (V = "mediump", console.warn("THREE.WebGLRenderer: highp not supported, using mediump.")) : (V = "lowp", console.warn("THREE.WebGLRenderer: highp and mediump not supported, using lowp."))), "mediump" !== V || Kt || (V = "lowp", console.warn("THREE.WebGLRenderer: mediump not supported, using lowp.")), this.getContext = function () {
		return Q
	}, this.supportsVertexTextures = function () {
		return It
	}, this.supportsFloatTextures = function () {
		return $
	}, this.supportsStandardDerivatives = function () {
		return J
	}, this.supportsCompressedTextureS3TC = function () {
		return tt
	}, this.getMaxAnisotropy = function () {
		return Ot
	}, this.getPrecision = function () {
		return V
	}, this.setSize = function (e, t, n) {
		z.width = e * this.devicePixelRatio, z.height = t * this.devicePixelRatio, !1 !== n && (z.style.width = e + "px", z.style.height = t + "px"), this.setViewport(0, 0, e, t)
	}, this.setViewport = function (e, t, n, r) {
		bt = e * this.devicePixelRatio, _t = t * this.devicePixelRatio, wt = n * this.devicePixelRatio, Ht = r * this.devicePixelRatio, Q.viewport(bt, _t, wt, Ht)
	}, this.setScissor = function (e, t, n, r) {
		Q.scissor(e * this.devicePixelRatio, t * this.devicePixelRatio, n * this.devicePixelRatio, r * this.devicePixelRatio)
	}, this.enableScissorTest = function (e) {
		e ? Q.enable(Q.SCISSOR_TEST) : Q.disable(Q.SCISSOR_TEST)
	}, this.setClearColor = function (e, t) {
		q.set(e), Y = void 0 !== t ? t : 1, Q.clearColor(q.r, q.g, q.b, Y)
	}, this.setClearColorHex = function (e, t) {
		console.warn("THREE.WebGLRenderer: .setClearColorHex() is being removed. Use .setClearColor() instead."), this.setClearColor(e, t)
	}, this.getClearColor = function () {
		return q
	}, this.getClearAlpha = function () {
		return Y
	}, this.clear = function (e, t, n) {
		var r = 0;
		(void 0 === e || e) && (r |= Q.COLOR_BUFFER_BIT), (void 0 === t || t) && (r |= Q.DEPTH_BUFFER_BIT), (void 0 === n || n) && (r |= Q.STENCIL_BUFFER_BIT), Q.clear(r)
	}, this.clearColor = function () {
		Q.clear(Q.COLOR_BUFFER_BIT)
	}, this.clearDepth = function () {
		Q.clear(Q.DEPTH_BUFFER_BIT)
	}, this.clearStencil = function () {
		Q.clear(Q.STENCIL_BUFFER_BIT)
	}, this.clearTarget = function (e, t, n, r) {
		this.setRenderTarget(e), this.clear(t, n, r)
	}, this.addPostPlugin = function (e) {
		e.init(this), this.renderPluginsPost.push(e)
	}, this.addPrePlugin = function (e) {
		e.init(this), this.renderPluginsPre.push(e)
	}, this.updateShadowMap = function (e, t) {
		ot = null, st = lt = vt = Et = dt = -1, Nt = !0, ft = ht = -1, nn(e), this.shadowMapPlugin.update(e, t)
	};
	var Zt = function (e) {
		if (e = e.target, e.removeEventListener("dispose", Zt), e.__webglInit = void 0, e instanceof THREE.BufferGeometry) {
			e = e.attributes;
			for (var t in e)void 0 !== e[t].buffer && Q.deleteBuffer(e[t].buffer);
			rt.info.memory.geometries--
		} else if (void 0 !== e.geometryGroups) {
			t = 0;
			for (var n = e.geometryGroupsList.length; n > t; t++) {
				var r = e.geometryGroupsList[t];
				if (void 0 !== r.numMorphTargets)for (var i = 0, o = r.numMorphTargets; o > i; i++)Q.deleteBuffer(r.__webglMorphTargetsBuffers[i]);
				if (void 0 !== r.numMorphNormals)for (i = 0, o = r.numMorphNormals; o > i; i++)Q.deleteBuffer(r.__webglMorphNormalsBuffers[i]);
				en(r)
			}
		} else en(e)
	}, Qt = function (e) {
		e = e.target, e.removeEventListener("dispose", Qt), e.image && e.image.__webglTextureCube ? Q.deleteTexture(e.image.__webglTextureCube) : e.__webglInit && (e.__webglInit = !1, Q.deleteTexture(e.__webglTexture)), rt.info.memory.textures--
	}, $t = function (e) {
		if (e = e.target, e.removeEventListener("dispose", $t), e && e.__webglTexture)if (Q.deleteTexture(e.__webglTexture), e instanceof THREE.WebGLRenderTargetCube)for (var t = 0; 6 > t; t++)Q.deleteFramebuffer(e.__webglFramebuffer[t]), Q.deleteRenderbuffer(e.__webglRenderbuffer[t]); else Q.deleteFramebuffer(e.__webglFramebuffer), Q.deleteRenderbuffer(e.__webglRenderbuffer);
		rt.info.memory.textures--
	}, Jt = function (e) {
		e = e.target, e.removeEventListener("dispose", Jt), tn(e)
	}, en = function (e) {
		if (void 0 !== e.__webglVertexBuffer && Q.deleteBuffer(e.__webglVertexBuffer), void 0 !== e.__webglNormalBuffer && Q.deleteBuffer(e.__webglNormalBuffer), void 0 !== e.__webglTangentBuffer && Q.deleteBuffer(e.__webglTangentBuffer), void 0 !== e.__webglColorBuffer && Q.deleteBuffer(e.__webglColorBuffer), void 0 !== e.__webglUVBuffer && Q.deleteBuffer(e.__webglUVBuffer), void 0 !== e.__webglUV2Buffer && Q.deleteBuffer(e.__webglUV2Buffer), void 0 !== e.__webglSkinIndicesBuffer && Q.deleteBuffer(e.__webglSkinIndicesBuffer), void 0 !== e.__webglSkinWeightsBuffer && Q.deleteBuffer(e.__webglSkinWeightsBuffer), void 0 !== e.__webglFaceBuffer && Q.deleteBuffer(e.__webglFaceBuffer), void 0 !== e.__webglLineBuffer && Q.deleteBuffer(e.__webglLineBuffer), void 0 !== e.__webglLineDistanceBuffer && Q.deleteBuffer(e.__webglLineDistanceBuffer), void 0 !== e.__webglCustomAttributesList)for (var t in e.__webglCustomAttributesList)Q.deleteBuffer(e.__webglCustomAttributesList[t].buffer);
		rt.info.memory.geometries--
	}, tn = function (e) {
		var t = e.program.program;
		if (void 0 !== t) {
			e.program = void 0;
			var n, r, i = !1;
			for (e = 0, n = it.length; n > e; e++)if (r = it[e], r.program === t) {
				r.usedTimes--, 0 === r.usedTimes && (i = !0);
				break
			}
			if (!0 === i) {
				for (i = [], e = 0, n = it.length; n > e; e++)r = it[e], r.program !== t && i.push(r);
				it = i, Q.deleteProgram(t), rt.info.memory.programs--
			}
		}
	};
	this.renderBufferImmediate = function (e, t, n) {
		if (l(), e.hasPositions && !e.__webglVertexBuffer && (e.__webglVertexBuffer = Q.createBuffer()), e.hasNormals && !e.__webglNormalBuffer && (e.__webglNormalBuffer = Q.createBuffer()), e.hasUvs && !e.__webglUvBuffer && (e.__webglUvBuffer = Q.createBuffer()), e.hasColors && !e.__webglColorBuffer && (e.__webglColorBuffer = Q.createBuffer()), e.hasPositions && (Q.bindBuffer(Q.ARRAY_BUFFER, e.__webglVertexBuffer), Q.bufferData(Q.ARRAY_BUFFER, e.positionArray, Q.DYNAMIC_DRAW), u(t.attributes.position), Q.vertexAttribPointer(t.attributes.position, 3, Q.FLOAT, !1, 0, 0)), e.hasNormals) {
			if (Q.bindBuffer(Q.ARRAY_BUFFER, e.__webglNormalBuffer), n.shading === THREE.FlatShading) {
				var r, i, o, a, s, h, f, d, p, m, g, E = 3 * e.count;
				for (g = 0; E > g; g += 9)m = e.normalArray, r = m[g], i = m[g + 1], o = m[g + 2], a = m[g + 3], h = m[g + 4], d = m[g + 5], s = m[g + 6], f = m[g + 7], p = m[g + 8], r = (r + a + s) / 3, i = (i + h + f) / 3, o = (o + d + p) / 3, m[g] = r, m[g + 1] = i, m[g + 2] = o, m[g + 3] = r, m[g + 4] = i, m[g + 5] = o, m[g + 6] = r, m[g + 7] = i, m[g + 8] = o
			}
			Q.bufferData(Q.ARRAY_BUFFER, e.normalArray, Q.DYNAMIC_DRAW), u(t.attributes.normal), Q.vertexAttribPointer(t.attributes.normal, 3, Q.FLOAT, !1, 0, 0)
		}
		e.hasUvs && n.map && (Q.bindBuffer(Q.ARRAY_BUFFER, e.__webglUvBuffer), Q.bufferData(Q.ARRAY_BUFFER, e.uvArray, Q.DYNAMIC_DRAW), u(t.attributes.uv), Q.vertexAttribPointer(t.attributes.uv, 2, Q.FLOAT, !1, 0, 0)), e.hasColors && n.vertexColors !== THREE.NoColors && (Q.bindBuffer(Q.ARRAY_BUFFER, e.__webglColorBuffer), Q.bufferData(Q.ARRAY_BUFFER, e.colorArray, Q.DYNAMIC_DRAW), u(t.attributes.color), Q.vertexAttribPointer(t.attributes.color, 3, Q.FLOAT, !1, 0, 0)), c(), Q.drawArrays(Q.TRIANGLES, 0, e.count), e.count = 0
	}, this.renderBufferDirect = function (e, t, n, r, i, o) {
		if (!1 !== r.visible) {
			var a = _(e, t, n, r, o);
			if (e = a.attributes, t = i.attributes, n = !1, a = 16777215 * i.id + 2 * a.id + (r.wireframe ? 1 : 0), a !== lt && (lt = a, n = !0), n && l(), o instanceof THREE.Mesh)if (a = t.index) {
				var u, c;
				if (a.array instanceof Uint32Array ? (u = Q.UNSIGNED_INT, c = 4) : (u = Q.UNSIGNED_SHORT, c = 2), i = i.offsets, 0 === i.length)n && (s(r, e, t, 0), Q.bindBuffer(Q.ELEMENT_ARRAY_BUFFER, a.buffer)), Q.drawElements(Q.TRIANGLES, a.array.length, u, 0), rt.info.render.calls++, rt.info.render.vertices += a.array.length, rt.info.render.faces += a.array.length / 3; else {
					n = !0;
					for (var h = 0, f = i.length; f > h; h++) {
						var d = i[h].index;
						n && (s(r, e, t, d), Q.bindBuffer(Q.ELEMENT_ARRAY_BUFFER, a.buffer)), Q.drawElements(Q.TRIANGLES, i[h].count, u, i[h].start * c), rt.info.render.calls++, rt.info.render.vertices += i[h].count, rt.info.render.faces += i[h].count / 3
					}
				}
			} else n && s(r, e, t, 0), r = i.attributes.position, Q.drawArrays(Q.TRIANGLES, 0, r.array.length / 3), rt.info.render.calls++, rt.info.render.vertices += r.array.length / 3, rt.info.render.faces += r.array.length / 9; else if (o instanceof THREE.PointCloud)n && s(r, e, t, 0), r = t.position, Q.drawArrays(Q.POINTS, 0, r.array.length / 3), rt.info.render.calls++, rt.info.render.points += r.array.length / 3; else if (o instanceof THREE.Line)if (o = o.type === THREE.LineStrip ? Q.LINE_STRIP : Q.LINES, A(r.linewidth), a = t.index)if (a.array instanceof Uint32Array ? (u = Q.UNSIGNED_INT, c = 4) : (u = Q.UNSIGNED_SHORT, c = 2), i = i.offsets, 0 === i.length)n && (s(r, e, t, 0), Q.bindBuffer(Q.ELEMENT_ARRAY_BUFFER, a.buffer)), Q.drawElements(o, a.array.length, u, 0), rt.info.render.calls++, rt.info.render.vertices += a.array.length; else for (1 < i.length && (n = !0), h = 0, f = i.length; f > h; h++)d = i[h].index, n && (s(r, e, t, d), Q.bindBuffer(Q.ELEMENT_ARRAY_BUFFER, a.buffer)), Q.drawElements(o, i[h].count, u, i[h].start * c), rt.info.render.calls++, rt.info.render.vertices += i[h].count; else n && s(r, e, t, 0), r = t.position, Q.drawArrays(o, 0, r.array.length / 3), rt.info.render.calls++, rt.info.render.points += r.array.length / 3
		}
	}, this.renderBuffer = function (e, t, n, r, i, o) {
		if (!1 !== r.visible) {
			var a, s;
			if (n = _(e, t, n, r, o), t = n.attributes, e = !1, n = 16777215 * i.id + 2 * n.id + (r.wireframe ? 1 : 0), n !== lt && (lt = n, e = !0), e && l(), !r.morphTargets && 0 <= t.position)e && (Q.bindBuffer(Q.ARRAY_BUFFER, i.__webglVertexBuffer), u(t.position), Q.vertexAttribPointer(t.position, 3, Q.FLOAT, !1, 0, 0)); else if (o.morphTargetBase) {
				if (n = r.program.attributes, -1 !== o.morphTargetBase && 0 <= n.position ? (Q.bindBuffer(Q.ARRAY_BUFFER, i.__webglMorphTargetsBuffers[o.morphTargetBase]), u(n.position), Q.vertexAttribPointer(n.position, 3, Q.FLOAT, !1, 0, 0)) : 0 <= n.position && (Q.bindBuffer(Q.ARRAY_BUFFER, i.__webglVertexBuffer), u(n.position), Q.vertexAttribPointer(n.position, 3, Q.FLOAT, !1, 0, 0)), o.morphTargetForcedOrder.length) {
					var h = 0;
					for (s = o.morphTargetForcedOrder, a = o.morphTargetInfluences; h < r.numSupportedMorphTargets && h < s.length;)0 <= n["morphTarget" + h] && (Q.bindBuffer(Q.ARRAY_BUFFER, i.__webglMorphTargetsBuffers[s[h]]), u(n["morphTarget" + h]), Q.vertexAttribPointer(n["morphTarget" + h], 3, Q.FLOAT, !1, 0, 0)), 0 <= n["morphNormal" + h] && r.morphNormals && (Q.bindBuffer(Q.ARRAY_BUFFER, i.__webglMorphNormalsBuffers[s[h]]), u(n["morphNormal" + h]), Q.vertexAttribPointer(n["morphNormal" + h], 3, Q.FLOAT, !1, 0, 0)), o.__webglMorphTargetInfluences[h] = a[s[h]], h++
				} else {
					s = [], a = o.morphTargetInfluences;
					var f, p = a.length;
					for (f = 0; p > f; f++)h = a[f], h > 0 && s.push([h, f]);
					for (s.length > r.numSupportedMorphTargets ? (s.sort(d), s.length = r.numSupportedMorphTargets) : s.length > r.numSupportedMorphNormals ? s.sort(d) : 0 === s.length && s.push([0, 0]), h = 0; h < r.numSupportedMorphTargets;)s[h] ? (f = s[h][1], 0 <= n["morphTarget" + h] && (Q.bindBuffer(Q.ARRAY_BUFFER, i.__webglMorphTargetsBuffers[f]), u(n["morphTarget" + h]), Q.vertexAttribPointer(n["morphTarget" + h], 3, Q.FLOAT, !1, 0, 0)), 0 <= n["morphNormal" + h] && r.morphNormals && (Q.bindBuffer(Q.ARRAY_BUFFER, i.__webglMorphNormalsBuffers[f]), u(n["morphNormal" + h]), Q.vertexAttribPointer(n["morphNormal" + h], 3, Q.FLOAT, !1, 0, 0)), o.__webglMorphTargetInfluences[h] = a[f]) : o.__webglMorphTargetInfluences[h] = 0, h++
				}
				null !== r.program.uniforms.morphTargetInfluences && Q.uniform1fv(r.program.uniforms.morphTargetInfluences, o.__webglMorphTargetInfluences)
			}
			if (e) {
				if (i.__webglCustomAttributesList)for (a = 0, s = i.__webglCustomAttributesList.length; s > a; a++)n = i.__webglCustomAttributesList[a], 0 <= t[n.buffer.belongsToAttribute] && (Q.bindBuffer(Q.ARRAY_BUFFER, n.buffer), u(t[n.buffer.belongsToAttribute]), Q.vertexAttribPointer(t[n.buffer.belongsToAttribute], n.size, Q.FLOAT, !1, 0, 0));
				0 <= t.color && (0 < o.geometry.colors.length || 0 < o.geometry.faces.length ? (Q.bindBuffer(Q.ARRAY_BUFFER, i.__webglColorBuffer), u(t.color), Q.vertexAttribPointer(t.color, 3, Q.FLOAT, !1, 0, 0)) : r.defaultAttributeValues && Q.vertexAttrib3fv(t.color, r.defaultAttributeValues.color)), 0 <= t.normal && (Q.bindBuffer(Q.ARRAY_BUFFER, i.__webglNormalBuffer), u(t.normal), Q.vertexAttribPointer(t.normal, 3, Q.FLOAT, !1, 0, 0)), 0 <= t.tangent && (Q.bindBuffer(Q.ARRAY_BUFFER, i.__webglTangentBuffer), u(t.tangent), Q.vertexAttribPointer(t.tangent, 4, Q.FLOAT, !1, 0, 0)), 0 <= t.uv && (o.geometry.faceVertexUvs[0] ? (Q.bindBuffer(Q.ARRAY_BUFFER, i.__webglUVBuffer), u(t.uv), Q.vertexAttribPointer(t.uv, 2, Q.FLOAT, !1, 0, 0)) : r.defaultAttributeValues && Q.vertexAttrib2fv(t.uv, r.defaultAttributeValues.uv)), 0 <= t.uv2 && (o.geometry.faceVertexUvs[1] ? (Q.bindBuffer(Q.ARRAY_BUFFER, i.__webglUV2Buffer), u(t.uv2), Q.vertexAttribPointer(t.uv2, 2, Q.FLOAT, !1, 0, 0)) : r.defaultAttributeValues && Q.vertexAttrib2fv(t.uv2, r.defaultAttributeValues.uv2)), r.skinning && 0 <= t.skinIndex && 0 <= t.skinWeight && (Q.bindBuffer(Q.ARRAY_BUFFER, i.__webglSkinIndicesBuffer), u(t.skinIndex), Q.vertexAttribPointer(t.skinIndex, 4, Q.FLOAT, !1, 0, 0), Q.bindBuffer(Q.ARRAY_BUFFER, i.__webglSkinWeightsBuffer), u(t.skinWeight), Q.vertexAttribPointer(t.skinWeight, 4, Q.FLOAT, !1, 0, 0)), 0 <= t.lineDistance && (Q.bindBuffer(Q.ARRAY_BUFFER, i.__webglLineDistanceBuffer), u(t.lineDistance), Q.vertexAttribPointer(t.lineDistance, 1, Q.FLOAT, !1, 0, 0))
			}
			c(), o instanceof THREE.Mesh ? (o = i.__typeArray === Uint32Array ? Q.UNSIGNED_INT : Q.UNSIGNED_SHORT, r.wireframe ? (A(r.wireframeLinewidth), e && Q.bindBuffer(Q.ELEMENT_ARRAY_BUFFER, i.__webglLineBuffer), Q.drawElements(Q.LINES, i.__webglLineCount, o, 0)) : (e && Q.bindBuffer(Q.ELEMENT_ARRAY_BUFFER, i.__webglFaceBuffer), Q.drawElements(Q.TRIANGLES, i.__webglFaceCount, o, 0)), rt.info.render.calls++, rt.info.render.vertices += i.__webglFaceCount, rt.info.render.faces += i.__webglFaceCount / 3) : o instanceof THREE.Line ? (o = o.type === THREE.LineStrip ? Q.LINE_STRIP : Q.LINES, A(r.linewidth), Q.drawArrays(o, 0, i.__webglLineCount), rt.info.render.calls++) : o instanceof THREE.PointCloud && (Q.drawArrays(Q.POINTS, 0, i.__webglParticleCount), rt.info.render.calls++, rt.info.render.points += i.__webglParticleCount)
		}
	}, this.render = function (e, t, n, r) {
		function i(e) {
			e instanceof THREE.SkinnedMesh && e.skeleton.update();
			for (var t = 0, n = e.children.length; n > t; t++)i(e.children[t])
		}

		if (!1 == t instanceof THREE.Camera)console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); else {
			var o, a, s, l, u = e.__lights, c = e.fog;
			for (st = -1, ut = null, Nt = !0, !0 === e.autoUpdate && e.updateMatrixWorld(), void 0 === t.parent && t.updateMatrixWorld(), i(e), t.matrixWorldInverse.getInverse(t.matrixWorld), kt.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), Lt.setFromMatrix(kt), nn(e), K.length = 0, Z.length = 0, p(e, e, t), !0 === rt.sortObjects && (K.sort(h), Z.sort(f)), m(this.renderPluginsPre, e, t), rt.info.render.calls = 0, rt.info.render.vertices = 0, rt.info.render.faces = 0, rt.info.render.points = 0, this.setRenderTarget(n), (this.autoClear || r) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil), l = e.__webglObjectsImmediate, r = 0, o = l.length; o > r; r++)a = l[r], s = a.object, s.visible && (M(s, t), v(a));
			e.overrideMaterial ? (r = e.overrideMaterial, this.setBlending(r.blending, r.blendEquation, r.blendSrc, r.blendDst), this.setDepthTest(r.depthTest), this.setDepthWrite(r.depthWrite), L(r.polygonOffset, r.polygonOffsetFactor, r.polygonOffsetUnits), g(K, t, u, c, !0, r), g(Z, t, u, c, !0, r), E(e.__webglObjectsImmediate, "", t, u, c, !1, r)) : (r = null, this.setBlending(THREE.NoBlending), g(K, t, u, c, !1, r), E(e.__webglObjectsImmediate, "opaque", t, u, c, !1, r), g(Z, t, u, c, !0, r), E(e.__webglObjectsImmediate, "transparent", t, u, c, !0, r)), m(this.renderPluginsPost, e, t), n && n.generateMipmaps && n.minFilter !== THREE.NearestFilter && n.minFilter !== THREE.LinearFilter && D(n), this.setDepthTest(!0), this.setDepthWrite(!0)
		}
	}, this.renderImmediateObject = function (e, t, n, r, i) {
		var o = _(e, t, n, r, i);
		lt = -1, rt.setMaterialFaces(r), i.immediateRenderCallback ? i.immediateRenderCallback(o, Q, Lt) : i.render(function (e) {
			rt.renderBufferImmediate(e, o, r)
		})
	};
	var nn = function (e) {
		for (e.__webglObjects || (e.__webglObjects = {}, e.__webglObjectsImmediate = []); e.__objectsAdded.length;) {
			var n = e.__objectsAdded[0], r = e, i = void 0, o = void 0;
			if (void 0 === n.__webglInit && (n.__webglInit = !0, n._modelViewMatrix = new THREE.Matrix4, n._normalMatrix = new THREE.Matrix3), i = n.geometry, void 0 !== i && void 0 === i.__webglInit)if (i.__webglInit = !0, i.addEventListener("dispose", Zt), i instanceof THREE.BufferGeometry)a(i); else if (n instanceof THREE.Mesh)void 0 !== n.__webglActive && b(n, r), y(r, n, i); else if (n instanceof THREE.Line) {
				if (!i.__webglVertexBuffer) {
					o = i, o.__webglVertexBuffer = Q.createBuffer(), o.__webglColorBuffer = Q.createBuffer(), o.__webglLineDistanceBuffer = Q.createBuffer(), rt.info.memory.geometries++;
					var o = i, s = n, l = o.vertices.length;
					o.__vertexArray = new Float32Array(3 * l), o.__colorArray = new Float32Array(3 * l), o.__lineDistanceArray = new Float32Array(1 * l), o.__webglLineCount = l, t(o, s), i.verticesNeedUpdate = !0, i.colorsNeedUpdate = !0, i.lineDistancesNeedUpdate = !0
				}
			} else n instanceof THREE.PointCloud && !i.__webglVertexBuffer && (o = i, o.__webglVertexBuffer = Q.createBuffer(), o.__webglColorBuffer = Q.createBuffer(), rt.info.memory.geometries++, o = i, s = n, l = o.vertices.length, o.__vertexArray = new Float32Array(3 * l), o.__colorArray = new Float32Array(3 * l), o.__sortArray = [], o.__webglParticleCount = l, t(o, s), i.verticesNeedUpdate = !0, i.colorsNeedUpdate = !0);
			if (void 0 === n.__webglActive) {
				if (n instanceof THREE.Mesh) {
					if (i = n.geometry, i instanceof THREE.BufferGeometry)T(r.__webglObjects, i, n); else if (i instanceof THREE.Geometry)for (s = 0, l = i.geometryGroupsList.length; l > s; s++)o = i.geometryGroupsList[s], T(r.__webglObjects, o, n)
				} else n instanceof THREE.Line || n instanceof THREE.PointCloud ? (i = n.geometry, T(r.__webglObjects, i, n)) : (n instanceof THREE.ImmediateRenderObject || n.immediateRenderCallback) && r.__webglObjectsImmediate.push({id: null, object: n, opaque: null, transparent: null, z: 0});
				n.__webglActive = !0
			}
			e.__objectsAdded.splice(0, 1)
		}
		for (; e.__objectsRemoved.length;)b(e.__objectsRemoved[0], e), e.__objectsRemoved.splice(0, 1)
	};
	this.initMaterial = function (e, t, n, r) {
		var i, o, a, s;
		e.addEventListener("dispose", Jt);
		var l, u, c, h;
		e instanceof THREE.MeshDepthMaterial ? h = "depth" : e instanceof THREE.MeshNormalMaterial ? h = "normal" : e instanceof THREE.MeshBasicMaterial ? h = "basic" : e instanceof THREE.MeshLambertMaterial ? h = "lambert" : e instanceof THREE.MeshPhongMaterial ? h = "phong" : e instanceof THREE.LineBasicMaterial ? h = "basic" : e instanceof THREE.LineDashedMaterial ? h = "dashed" : e instanceof THREE.PointCloudMaterial && (h = "particle_basic"), h ? (i = THREE.ShaderLib[h], e.__webglShader = {uniforms: THREE.UniformsUtils.clone(i.uniforms), vertexShader: i.vertexShader, fragmentShader: i.fragmentShader}) : e.__webglShader = {uniforms: e.uniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader}, c = s = a = o = i = 0;
		for (var f = t.length; f > c; c++) {
			var d = t[c];
			d.onlyShadow || !1 === d.visible || (d instanceof THREE.DirectionalLight && i++, d instanceof THREE.PointLight && o++, d instanceof THREE.SpotLight && a++, d instanceof THREE.HemisphereLight && s++)
		}
		for (f = c = 0, d = t.length; d > f; f++) {
			var p = t[f];
			p.castShadow && (p instanceof THREE.SpotLight && c++, p instanceof THREE.DirectionalLight && !p.shadowCascade && c++)
		}
		t = c, jt && r && r.skeleton && r.skeleton.useVertexTexture ? c = 1024 : (c = Q.getParameter(Q.MAX_VERTEX_UNIFORM_VECTORS), c = Math.floor((c - 20) / 4), void 0 !== r && r instanceof THREE.SkinnedMesh && (c = Math.min(r.skeleton.bones.length, c), c < r.skeleton.bones.length && console.warn("WebGLRenderer: too many bones - " + r.skeleton.bones.length + ", this GPU supports just " + c + " (try OpenGL instead of ANGLE)"))), n = {precision: V, supportsVertexTextures: It, map: !!e.map, envMap: !!e.envMap, lightMap: !!e.lightMap, bumpMap: !!e.bumpMap, normalMap: !!e.normalMap, specularMap: !!e.specularMap, alphaMap: !!e.alphaMap, vertexColors: e.vertexColors, fog: n, useFog: e.fog, fogExp: n instanceof THREE.FogExp2, sizeAttenuation: e.sizeAttenuation, logarithmicDepthBuffer: X, skinning: e.skinning, maxBones: c, useVertexTexture: jt && r && r.skeleton && r.skeleton.useVertexTexture, morphTargets: e.morphTargets, morphNormals: e.morphNormals, maxMorphTargets: this.maxMorphTargets, maxMorphNormals: this.maxMorphNormals, maxDirLights: i, maxPointLights: o, maxSpotLights: a, maxHemiLights: s, maxShadows: t, shadowMapEnabled: this.shadowMapEnabled && r.receiveShadow && t > 0, shadowMapType: this.shadowMapType, shadowMapDebug: this.shadowMapDebug, shadowMapCascade: this.shadowMapCascade, alphaTest: e.alphaTest, metal: e.metal, wrapAround: e.wrapAround, doubleSided: e.side === THREE.DoubleSide, flipSided: e.side === THREE.BackSide}, r = [], h ? r.push(h) : (r.push(e.fragmentShader), r.push(e.vertexShader));
		for (var m in e.defines)r.push(m), r.push(e.defines[m]);
		for (u in n)r.push(u), r.push(n[u]);
		h = r.join();
		var g;
		for (u = 0, m = it.length; m > u; u++)if (r = it[u], r.code === h) {
			g = r, g.usedTimes++;
			break
		}
		if (void 0 === g && (g = new THREE.WebGLProgram(this, h, e, n), it.push(g), rt.info.memory.programs = it.length), e.program = g, g = e.program.attributes, e.morphTargets)for (e.numSupportedMorphTargets = 0, m = "morphTarget", u = 0; u < this.maxMorphTargets; u++)h = m + u, 0 <= g[h] && e.numSupportedMorphTargets++;
		if (e.morphNormals)for (e.numSupportedMorphNormals = 0, m = "morphNormal", u = 0; u < this.maxMorphNormals; u++)h = m + u, 0 <= g[h] && e.numSupportedMorphNormals++;
		e.uniformsList = [];
		for (l in e.__webglShader.uniforms)(u = e.program.uniforms[l]) && e.uniformsList.push([e.__webglShader.uniforms[l], u])
	}, this.setFaceCulling = function (e, t) {
		e === THREE.CullFaceNone ? Q.disable(Q.CULL_FACE) : (Q.frontFace(t === THREE.FrontFaceDirectionCW ? Q.CW : Q.CCW), Q.cullFace(e === THREE.CullFaceBack ? Q.BACK : e === THREE.CullFaceFront ? Q.FRONT : Q.FRONT_AND_BACK), Q.enable(Q.CULL_FACE))
	}, this.setMaterialFaces = function (e) {
		var t = e.side === THREE.DoubleSide;
		e = e.side === THREE.BackSide, ht !== t && (t ? Q.disable(Q.CULL_FACE) : Q.enable(Q.CULL_FACE), ht = t), ft !== e && (Q.frontFace(e ? Q.CW : Q.CCW), ft = e)
	}, this.setDepthTest = function (e) {
		Et !== e && (e ? Q.enable(Q.DEPTH_TEST) : Q.disable(Q.DEPTH_TEST), Et = e)
	}, this.setDepthWrite = function (e) {
		vt !== e && (Q.depthMask(e), vt = e)
	}, this.setBlending = function (e, t, n, r) {
		e !== dt && (e === THREE.NoBlending ? Q.disable(Q.BLEND) : e === THREE.AdditiveBlending ? (Q.enable(Q.BLEND), Q.blendEquation(Q.FUNC_ADD), Q.blendFunc(Q.SRC_ALPHA, Q.ONE)) : e === THREE.SubtractiveBlending ? (Q.enable(Q.BLEND), Q.blendEquation(Q.FUNC_ADD), Q.blendFunc(Q.ZERO, Q.ONE_MINUS_SRC_COLOR)) : e === THREE.MultiplyBlending ? (Q.enable(Q.BLEND), Q.blendEquation(Q.FUNC_ADD), Q.blendFunc(Q.ZERO, Q.SRC_COLOR)) : e === THREE.CustomBlending ? Q.enable(Q.BLEND) : (Q.enable(Q.BLEND), Q.blendEquationSeparate(Q.FUNC_ADD, Q.FUNC_ADD), Q.blendFuncSeparate(Q.SRC_ALPHA, Q.ONE_MINUS_SRC_ALPHA, Q.ONE, Q.ONE_MINUS_SRC_ALPHA)), dt = e), e === THREE.CustomBlending ? (t !== pt && (Q.blendEquation(N(t)), pt = t), (n !== mt || r !== gt) && (Q.blendFunc(N(n), N(r)), mt = n, gt = r)) : gt = mt = pt = null
	}, this.setTexture = function (e, t) {
		if (e.needsUpdate) {
			e.__webglInit || (e.__webglInit = !0, e.addEventListener("dispose", Qt), e.__webglTexture = Q.createTexture(), rt.info.memory.textures++), Q.activeTexture(Q.TEXTURE0 + t), Q.bindTexture(Q.TEXTURE_2D, e.__webglTexture), Q.pixelStorei(Q.UNPACK_FLIP_Y_WEBGL, e.flipY), Q.pixelStorei(Q.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.premultiplyAlpha), Q.pixelStorei(Q.UNPACK_ALIGNMENT, e.unpackAlignment);
			var n = e.image, r = THREE.Math.isPowerOfTwo(n.width) && THREE.Math.isPowerOfTwo(n.height), i = N(e.format), o = N(e.type);
			k(Q.TEXTURE_2D, e, r);
			var a = e.mipmaps;
			if (e instanceof THREE.DataTexture)if (0 < a.length && r) {
				for (var s = 0, l = a.length; l > s; s++)n = a[s], Q.texImage2D(Q.TEXTURE_2D, s, i, n.width, n.height, 0, i, o, n.data);
				e.generateMipmaps = !1
			} else Q.texImage2D(Q.TEXTURE_2D, 0, i, n.width, n.height, 0, i, o, n.data); else if (e instanceof THREE.CompressedTexture)for (s = 0, l = a.length; l > s; s++)n = a[s], e.format !== THREE.RGBAFormat ? Q.compressedTexImage2D(Q.TEXTURE_2D, s, i, n.width, n.height, 0, n.data) : Q.texImage2D(Q.TEXTURE_2D, s, i, n.width, n.height, 0, i, o, n.data); else if (0 < a.length && r) {
				for (s = 0, l = a.length; l > s; s++)n = a[s], Q.texImage2D(Q.TEXTURE_2D, s, i, i, o, n);
				e.generateMipmaps = !1
			} else Q.texImage2D(Q.TEXTURE_2D, 0, i, i, o, e.image);
			e.generateMipmaps && r && Q.generateMipmap(Q.TEXTURE_2D), e.needsUpdate = !1, e.onUpdate && e.onUpdate()
		} else Q.activeTexture(Q.TEXTURE0 + t), Q.bindTexture(Q.TEXTURE_2D, e.__webglTexture)
	}, this.setRenderTarget = function (e) {
		var t = e instanceof THREE.WebGLRenderTargetCube;
		if (e && !e.__webglFramebuffer) {
			void 0 === e.depthBuffer && (e.depthBuffer = !0), void 0 === e.stencilBuffer && (e.stencilBuffer = !0), e.addEventListener("dispose", $t), e.__webglTexture = Q.createTexture(), rt.info.memory.textures++;
			var n = THREE.Math.isPowerOfTwo(e.width) && THREE.Math.isPowerOfTwo(e.height), r = N(e.format), i = N(e.type);
			if (t) {
				e.__webglFramebuffer = [], e.__webglRenderbuffer = [], Q.bindTexture(Q.TEXTURE_CUBE_MAP, e.__webglTexture), k(Q.TEXTURE_CUBE_MAP, e, n);
				for (var o = 0; 6 > o; o++) {
					e.__webglFramebuffer[o] = Q.createFramebuffer(), e.__webglRenderbuffer[o] = Q.createRenderbuffer(), Q.texImage2D(Q.TEXTURE_CUBE_MAP_POSITIVE_X + o, 0, r, e.width, e.height, 0, r, i, null);
					var a = e, s = Q.TEXTURE_CUBE_MAP_POSITIVE_X + o;
					Q.bindFramebuffer(Q.FRAMEBUFFER, e.__webglFramebuffer[o]), Q.framebufferTexture2D(Q.FRAMEBUFFER, Q.COLOR_ATTACHMENT0, s, a.__webglTexture, 0), P(e.__webglRenderbuffer[o], e)
				}
				n && Q.generateMipmap(Q.TEXTURE_CUBE_MAP)
			} else e.__webglFramebuffer = Q.createFramebuffer(), e.__webglRenderbuffer = e.shareDepthFrom ? e.shareDepthFrom.__webglRenderbuffer : Q.createRenderbuffer(), Q.bindTexture(Q.TEXTURE_2D, e.__webglTexture), k(Q.TEXTURE_2D, e, n), Q.texImage2D(Q.TEXTURE_2D, 0, r, e.width, e.height, 0, r, i, null), r = Q.TEXTURE_2D, Q.bindFramebuffer(Q.FRAMEBUFFER, e.__webglFramebuffer), Q.framebufferTexture2D(Q.FRAMEBUFFER, Q.COLOR_ATTACHMENT0, r, e.__webglTexture, 0), e.shareDepthFrom ? e.depthBuffer && !e.stencilBuffer ? Q.framebufferRenderbuffer(Q.FRAMEBUFFER, Q.DEPTH_ATTACHMENT, Q.RENDERBUFFER, e.__webglRenderbuffer) : e.depthBuffer && e.stencilBuffer && Q.framebufferRenderbuffer(Q.FRAMEBUFFER, Q.DEPTH_STENCIL_ATTACHMENT, Q.RENDERBUFFER, e.__webglRenderbuffer) : P(e.__webglRenderbuffer, e), n && Q.generateMipmap(Q.TEXTURE_2D);
			t ? Q.bindTexture(Q.TEXTURE_CUBE_MAP, null) : Q.bindTexture(Q.TEXTURE_2D, null), Q.bindRenderbuffer(Q.RENDERBUFFER, null), Q.bindFramebuffer(Q.FRAMEBUFFER, null)
		}
		e ? (t = t ? e.__webglFramebuffer[e.activeCubeFace] : e.__webglFramebuffer, n = e.width, e = e.height, i = r = 0) : (t = null, n = wt, e = Ht, r = bt, i = _t), t !== at && (Q.bindFramebuffer(Q.FRAMEBUFFER, t), Q.viewport(r, i, n, e), at = t), Mt = n, St = e
	}, this.shadowMapPlugin = new THREE.ShadowMapPlugin, this.addPrePlugin(this.shadowMapPlugin), this.addPostPlugin(new THREE.SpritePlugin), this.addPostPlugin(new THREE.LensFlarePlugin)
}, THREE.WebGLRenderTarget = function (e, t, n) {
	this.width = e, this.height = t, n = n || {}, this.wrapS = void 0 !== n.wrapS ? n.wrapS : THREE.ClampToEdgeWrapping, this.wrapT = void 0 !== n.wrapT ? n.wrapT : THREE.ClampToEdgeWrapping, this.magFilter = void 0 !== n.magFilter ? n.magFilter : THREE.LinearFilter, this.minFilter = void 0 !== n.minFilter ? n.minFilter : THREE.LinearMipMapLinearFilter, this.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, this.offset = new THREE.Vector2(0, 0), this.repeat = new THREE.Vector2(1, 1), this.format = void 0 !== n.format ? n.format : THREE.RGBAFormat, this.type = void 0 !== n.type ? n.type : THREE.UnsignedByteType, this.depthBuffer = void 0 !== n.depthBuffer ? n.depthBuffer : !0, this.stencilBuffer = void 0 !== n.stencilBuffer ? n.stencilBuffer : !0, this.generateMipmaps = !0, this.shareDepthFrom = null
}, THREE.WebGLRenderTarget.prototype = {constructor: THREE.WebGLRenderTarget, setSize: function (e, t) {
	this.width = e, this.height = t
}, clone: function () {
	var e = new THREE.WebGLRenderTarget(this.width, this.height);
	return e.wrapS = this.wrapS, e.wrapT = this.wrapT, e.magFilter = this.magFilter, e.minFilter = this.minFilter, e.anisotropy = this.anisotropy, e.offset.copy(this.offset), e.repeat.copy(this.repeat), e.format = this.format, e.type = this.type, e.depthBuffer = this.depthBuffer, e.stencilBuffer = this.stencilBuffer, e.generateMipmaps = this.generateMipmaps, e.shareDepthFrom = this.shareDepthFrom, e
}, dispose: function () {
	this.dispatchEvent({type: "dispose"})
}}, THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype), THREE.WebGLRenderTargetCube = function (e, t, n) {
	THREE.WebGLRenderTarget.call(this, e, t, n), this.activeCubeFace = 0
}, THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype), THREE.WebGLProgram = function () {
	var e = 0;
	return function (t, n, r, i) {
		var o = t.context, a = r.defines, s = r.__webglShader.uniforms, l = r.attributes, u = r.__webglShader.vertexShader, c = r.__webglShader.fragmentShader, h = r.index0AttributeName;
		void 0 === h && !0 === i.morphTargets && (h = "position");
		var f = "SHADOWMAP_TYPE_BASIC";
		i.shadowMapType === THREE.PCFShadowMap ? f = "SHADOWMAP_TYPE_PCF" : i.shadowMapType === THREE.PCFSoftShadowMap && (f = "SHADOWMAP_TYPE_PCF_SOFT");
		var d, p;
		d = [];
		for (var m in a)p = a[m], !1 !== p && (p = "#define " + m + " " + p, d.push(p));
		d = d.join("\n"), a = o.createProgram(), r instanceof THREE.RawShaderMaterial ? t = r = "" : (r = ["precision " + i.precision + " float;", "precision " + i.precision + " int;", d, i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", t.gammaInput ? "#define GAMMA_INPUT" : "", t.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define MAX_DIR_LIGHTS " + i.maxDirLights, "#define MAX_POINT_LIGHTS " + i.maxPointLights, "#define MAX_SPOT_LIGHTS " + i.maxSpotLights, "#define MAX_HEMI_LIGHTS " + i.maxHemiLights, "#define MAX_SHADOWS " + i.maxShadows, "#define MAX_BONES " + i.maxBones, i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.vertexColors ? "#define USE_COLOR" : "", i.skinning ? "#define USE_SKINNING" : "", i.useVertexTexture ? "#define BONE_TEXTURE" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals ? "#define USE_MORPHNORMALS" : "", i.wrapAround ? "#define WRAP_AROUND" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + f : "", i.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", i.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#ifdef USE_COLOR\n	attribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\n	attribute vec3 morphTarget0;\n	attribute vec3 morphTarget1;\n	attribute vec3 morphTarget2;\n	attribute vec3 morphTarget3;\n	#ifdef USE_MORPHNORMALS\n		attribute vec3 morphNormal0;\n		attribute vec3 morphNormal1;\n		attribute vec3 morphNormal2;\n		attribute vec3 morphNormal3;\n	#else\n		attribute vec3 morphTarget4;\n		attribute vec3 morphTarget5;\n		attribute vec3 morphTarget6;\n		attribute vec3 morphTarget7;\n	#endif\n#endif\n#ifdef USE_SKINNING\n	attribute vec4 skinIndex;\n	attribute vec4 skinWeight;\n#endif\n"].join("\n"), t = ["precision " + i.precision + " float;", "precision " + i.precision + " int;", i.bumpMap || i.normalMap ? "#extension GL_OES_standard_derivatives : enable" : "", d, "#define MAX_DIR_LIGHTS " + i.maxDirLights, "#define MAX_POINT_LIGHTS " + i.maxPointLights, "#define MAX_SPOT_LIGHTS " + i.maxSpotLights, "#define MAX_HEMI_LIGHTS " + i.maxHemiLights, "#define MAX_SHADOWS " + i.maxShadows, i.alphaTest ? "#define ALPHATEST " + i.alphaTest : "", t.gammaInput ? "#define GAMMA_INPUT" : "", t.gammaOutput ? "#define GAMMA_OUTPUT" : "", i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.vertexColors ? "#define USE_COLOR" : "", i.metal ? "#define METAL" : "", i.wrapAround ? "#define WRAP_AROUND" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + f : "", i.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", i.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n"].join("\n")), u = new THREE.WebGLShader(o, o.VERTEX_SHADER, r + u), c = new THREE.WebGLShader(o, o.FRAGMENT_SHADER, t + c), o.attachShader(a, u), o.attachShader(a, c), void 0 !== h && o.bindAttribLocation(a, 0, h), o.linkProgram(a), !1 === o.getProgramParameter(a, o.LINK_STATUS) && (console.error("THREE.WebGLProgram: Could not initialise shader."), console.error("gl.VALIDATE_STATUS", o.getProgramParameter(a, o.VALIDATE_STATUS)), console.error("gl.getError()", o.getError())), "" !== o.getProgramInfoLog(a) && console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", o.getProgramInfoLog(a)), o.deleteShader(u), o.deleteShader(c), h = "viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition morphTargetInfluences bindMatrix bindMatrixInverse".split(" "), i.useVertexTexture ? (h.push("boneTexture"), h.push("boneTextureWidth"), h.push("boneTextureHeight")) : h.push("boneGlobalMatrices"), i.logarithmicDepthBuffer && h.push("logDepthBufFC");
		for (var g in s)h.push(g);
		for (s = h, g = {}, h = 0, t = s.length; t > h; h++)f = s[h], g[f] = o.getUniformLocation(a, f);
		for (this.uniforms = g, h = "position normal uv uv2 tangent color skinIndex skinWeight lineDistance".split(" "), s = 0; s < i.maxMorphTargets; s++)h.push("morphTarget" + s);
		for (s = 0; s < i.maxMorphNormals; s++)h.push("morphNormal" + s);
		for (var E in l)h.push(E);
		for (i = h, l = {}, E = 0, s = i.length; s > E; E++)g = i[E], l[g] = o.getAttribLocation(a, g);
		return this.attributes = l, this.id = e++, this.code = n, this.usedTimes = 1, this.program = a, this.vertexShader = u, this.fragmentShader = c, this
	}
}(), THREE.WebGLShader = function () {
	var e = function (e) {
		e = e.split("\n");
		for (var t = 0; t < e.length; t++)e[t] = t + 1 + ": " + e[t];
		return e.join("\n")
	};
	return function (t, n, r) {
		return n = t.createShader(n), t.shaderSource(n, r), t.compileShader(n), !1 === t.getShaderParameter(n, t.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(n) && (console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", t.getShaderInfoLog(n)), console.warn(e(r))), n
	}
}(), THREE.RenderableVertex = function () {
	this.position = new THREE.Vector3, this.positionWorld = new THREE.Vector3, this.positionScreen = new THREE.Vector4, this.visible = !0
}, THREE.RenderableVertex.prototype.copy = function (e) {
	this.positionWorld.copy(e.positionWorld), this.positionScreen.copy(e.positionScreen)
}, THREE.RenderableFace = function () {
	this.id = 0, this.v1 = new THREE.RenderableVertex, this.v2 = new THREE.RenderableVertex, this.v3 = new THREE.RenderableVertex, this.normalModel = new THREE.Vector3, this.vertexNormalsModel = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3], this.vertexNormalsLength = 0, this.color = new THREE.Color, this.material = null, this.uvs = [new THREE.Vector2, new THREE.Vector2, new THREE.Vector2], this.z = 0
}, THREE.RenderableObject = function () {
	this.id = 0, this.object = null, this.z = 0
}, THREE.RenderableSprite = function () {
	this.id = 0, this.object = null, this.rotation = this.z = this.y = this.x = 0, this.scale = new THREE.Vector2, this.material = null
}, THREE.RenderableLine = function () {
	this.id = 0, this.v1 = new THREE.RenderableVertex, this.v2 = new THREE.RenderableVertex, this.vertexColors = [new THREE.Color, new THREE.Color], this.material = null, this.z = 0
}, THREE.GeometryUtils = {merge: function (e, t, n) {
	console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
	var r;
	t instanceof THREE.Mesh && (t.matrixAutoUpdate && t.updateMatrix(), r = t.matrix, t = t.geometry), e.merge(t, r, n)
}, center: function (e) {
	return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center()
}}, THREE.ImageUtils = {crossOrigin: void 0, loadTexture: function (e, t, n, r) {
	var i = new THREE.ImageLoader;
	i.crossOrigin = this.crossOrigin;
	var o = new THREE.Texture(void 0, t);
	return i.load(e, function (e) {
		o.image = e, o.needsUpdate = !0, n && n(o)
	}, void 0, function (e) {
		r && r(e)
	}), o.sourceFile = e, o
}, loadTextureCube: function (e, t, n, r) {
	var i = new THREE.ImageLoader;
	i.crossOrigin = this.crossOrigin;
	var o = new THREE.CubeTexture([], t);
	o.flipY = !1;
	var a = 0;
	t = function (t) {
		i.load(e[t], function (e) {
			o.images[t] = e, a += 1, 6 === a && (o.needsUpdate = !0, n && n(o))
		})
	}, r = 0;
	for (var s = e.length; s > r; ++r)t(r);
	return o
}, loadCompressedTexture: function () {
	console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
}, loadCompressedTextureCube: function () {
	console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
}, getNormalMap: function (e, t) {
	var n = function (e) {
		var t = Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
		return[e[0] / t, e[1] / t, e[2] / t]
	};
	t |= 1;
	var r = e.width, i = e.height, o = document.createElement("canvas");
	o.width = r, o.height = i;
	var a = o.getContext("2d");
	a.drawImage(e, 0, 0);
	for (var s = a.getImageData(0, 0, r, i).data, l = a.createImageData(r, i), u = l.data, c = 0; r > c; c++)for (var h = 0; i > h; h++) {
		var f = 0 > h - 1 ? 0 : h - 1, d = h + 1 > i - 1 ? i - 1 : h + 1, p = 0 > c - 1 ? 0 : c - 1, m = c + 1 > r - 1 ? r - 1 : c + 1, g = [], E = [0, 0, s[4 * (h * r + c)] / 255 * t];
		for (g.push([-1, 0, s[4 * (h * r + p)] / 255 * t]), g.push([-1, -1, s[4 * (f * r + p)] / 255 * t]), g.push([0, -1, s[4 * (f * r + c)] / 255 * t]), g.push([1, -1, s[4 * (f * r + m)] / 255 * t]), g.push([1, 0, s[4 * (h * r + m)] / 255 * t]), g.push([1, 1, s[4 * (d * r + m)] / 255 * t]), g.push([0, 1, s[4 * (d * r + c)] / 255 * t]), g.push([-1, 1, s[4 * (d * r + p)] / 255 * t]), f = [], p = g.length, d = 0; p > d; d++) {
			var m = g[d], v = g[(d + 1) % p], m = [m[0] - E[0], m[1] - E[1], m[2] - E[2]], v = [v[0] - E[0], v[1] - E[1], v[2] - E[2]];
			f.push(n([m[1] * v[2] - m[2] * v[1], m[2] * v[0] - m[0] * v[2], m[0] * v[1] - m[1] * v[0]]))
		}
		for (g = [0, 0, 0], d = 0; d < f.length; d++)g[0] += f[d][0], g[1] += f[d][1], g[2] += f[d][2];
		g[0] /= f.length, g[1] /= f.length, g[2] /= f.length, E = 4 * (h * r + c), u[E] = (g[0] + 1) / 2 * 255 | 0, u[E + 1] = (g[1] + 1) / 2 * 255 | 0, u[E + 2] = 255 * g[2] | 0, u[E + 3] = 255
	}
	return a.putImageData(l, 0, 0), o
}, generateDataTexture: function (e, t, n) {
	var r = e * t, i = new Uint8Array(3 * r), o = Math.floor(255 * n.r), a = Math.floor(255 * n.g);
	n = Math.floor(255 * n.b);
	for (var s = 0; r > s; s++)i[3 * s] = o, i[3 * s + 1] = a, i[3 * s + 2] = n;
	return e = new THREE.DataTexture(i, e, t, THREE.RGBFormat), e.needsUpdate = !0, e
}}, THREE.SceneUtils = {createMultiMaterialObject: function (e, t) {
	for (var n = new THREE.Object3D, r = 0, i = t.length; i > r; r++)n.add(new THREE.Mesh(e, t[r]));
	return n
}, detach: function (e, t, n) {
	e.applyMatrix(t.matrixWorld), t.remove(e), n.add(e)
}, attach: function (e, t, n) {
	var r = new THREE.Matrix4;
	r.getInverse(n.matrixWorld), e.applyMatrix(r), t.remove(e), n.add(e)
}}, THREE.FontUtils = {faces: {}, face: "helvetiker", weight: "normal", style: "normal", size: 150, divisions: 10, getFace: function () {
	try {
		return this.faces[this.face][this.weight][this.style]
	} catch (e) {
		throw"The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing."
	}
}, loadFace: function (e) {
	var t = e.familyName.toLowerCase();
	return this.faces[t] = this.faces[t] || {}, this.faces[t][e.cssFontWeight] = this.faces[t][e.cssFontWeight] || {}, this.faces[t][e.cssFontWeight][e.cssFontStyle] = e, this.faces[t][e.cssFontWeight][e.cssFontStyle] = e
}, drawText: function (e) {
	var t = this.getFace(), n = this.size / t.resolution, r = 0, i = String(e).split(""), o = i.length, a = [];
	for (e = 0; o > e; e++) {
		var s = new THREE.Path, s = this.extractGlyphPoints(i[e], t, n, r, s), r = r + s.offset;
		a.push(s.path)
	}
	return{paths: a, offset: r / 2}
}, extractGlyphPoints: function (e, t, n, r, i) {
	var o, a, s, l, u, c, h, f, d, p, m, g = [], E = t.glyphs[e] || t.glyphs["?"];
	if (E) {
		if (E.o)for (t = E._cachedOutline || (E._cachedOutline = E.o.split(" ")), l = t.length, e = 0; l > e;)switch (s = t[e++]) {
			case"m":
				s = t[e++] * n + r, u = t[e++] * n, i.moveTo(s, u);
				break;
			case"l":
				s = t[e++] * n + r, u = t[e++] * n, i.lineTo(s, u);
				break;
			case"q":
				if (s = t[e++] * n + r, u = t[e++] * n, f = t[e++] * n + r, d = t[e++] * n, i.quadraticCurveTo(f, d, s, u), o = g[g.length - 1])for (c = o.x, h = o.y, o = 1, a = this.divisions; a >= o; o++) {
					var v = o / a;
					THREE.Shape.Utils.b2(v, c, f, s), THREE.Shape.Utils.b2(v, h, d, u)
				}
				break;
			case"b":
				if (s = t[e++] * n + r, u = t[e++] * n, f = t[e++] * n + r, d = t[e++] * n, p = t[e++] * n + r, m = t[e++] * n, i.bezierCurveTo(f, d, p, m, s, u), o = g[g.length - 1])for (c = o.x, h = o.y, o = 1, a = this.divisions; a >= o; o++)v = o / a, THREE.Shape.Utils.b3(v, c, f, p, s), THREE.Shape.Utils.b3(v, h, d, m, u)
		}
		return{offset: E.ha * n, path: i}
	}
}}, THREE.FontUtils.generateShapes = function (e, t) {
	t = t || {};
	var n = void 0 !== t.curveSegments ? t.curveSegments : 4, r = void 0 !== t.font ? t.font : "helvetiker", i = void 0 !== t.weight ? t.weight : "normal", o = void 0 !== t.style ? t.style : "normal";
	for (THREE.FontUtils.size = void 0 !== t.size ? t.size : 100, THREE.FontUtils.divisions = n, THREE.FontUtils.face = r, THREE.FontUtils.weight = i, THREE.FontUtils.style = o, n = THREE.FontUtils.drawText(e).paths, r = [], i = 0, o = n.length; o > i; i++)Array.prototype.push.apply(r, n[i].toShapes());
	return r
}, function (e) {
	var t = function (e) {
		for (var t = e.length, n = 0, r = t - 1, i = 0; t > i; r = i++)n += e[r].x * e[i].y - e[i].x * e[r].y;
		return.5 * n
	};
	return e.Triangulate = function (e, n) {
		var r = e.length;
		if (3 > r)return null;
		var i, o, a, s = [], l = [], u = [];
		if (0 < t(e))for (o = 0; r > o; o++)l[o] = o; else for (o = 0; r > o; o++)l[o] = r - 1 - o;
		var c = 2 * r;
		for (o = r - 1; r > 2;) {
			if (0 >= c--) {
				console.log("Warning, unable to triangulate polygon!");
				break
			}
			i = o, i >= r && (i = 0), o = i + 1, o >= r && (o = 0), a = o + 1, a >= r && (a = 0);
			var h;
			e:{
				var f = h = void 0, d = void 0, p = void 0, m = void 0, g = void 0, E = void 0, v = void 0, y = void 0, f = e[l[i]].x, d = e[l[i]].y, p = e[l[o]].x, m = e[l[o]].y, g = e[l[a]].x, E = e[l[a]].y;
				if (1e-10 > (p - f) * (E - d) - (m - d) * (g - f))h = !1; else {
					var T = void 0, x = void 0, R = void 0, b = void 0, _ = void 0, w = void 0, H = void 0, M = void 0, S = void 0, C = void 0, S = M = H = y = v = void 0, T = g - p, x = E - m, R = f - g, b = d - E, _ = p - f, w = m - d;
					for (h = 0; r > h; h++)if (v = e[l[h]].x, y = e[l[h]].y, !(v === f && y === d || v === p && y === m || v === g && y === E) && (H = v - f, M = y - d, S = v - p, C = y - m, v -= g, y -= E, S = T * C - x * S, H = _ * M - w * H, M = R * y - b * v, S >= -1e-10 && M >= -1e-10 && H >= -1e-10)) {
						h = !1;
						break e
					}
					h = !0
				}
			}
			if (h) {
				for (s.push([e[l[i]], e[l[o]], e[l[a]]]), u.push([l[i], l[o], l[a]]), i = o, a = o + 1; r > a; i++, a++)l[i] = l[a];
				r--, c = 2 * r
			}
		}
		return n ? u : s
	}, e.Triangulate.area = t, e
}(THREE.FontUtils), self._typeface_js = {faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace}, THREE.typeface_js = self._typeface_js, THREE.Curve = function () {
}, THREE.Curve.prototype.getPoint = function () {
	return console.log("Warning, getPoint() not implemented!"), null
}, THREE.Curve.prototype.getPointAt = function (e) {
	return e = this.getUtoTmapping(e), this.getPoint(e)
}, THREE.Curve.prototype.getPoints = function (e) {
	e || (e = 5);
	var t, n = [];
	for (t = 0; e >= t; t++)n.push(this.getPoint(t / e));
	return n
}, THREE.Curve.prototype.getSpacedPoints = function (e) {
	e || (e = 5);
	var t, n = [];
	for (t = 0; e >= t; t++)n.push(this.getPointAt(t / e));
	return n
}, THREE.Curve.prototype.getLength = function () {
	var e = this.getLengths();
	return e[e.length - 1]
}, THREE.Curve.prototype.getLengths = function (e) {
	if (e || (e = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200), this.cacheArcLengths && this.cacheArcLengths.length == e + 1 && !this.needsUpdate)return this.cacheArcLengths;
	this.needsUpdate = !1;
	var t, n, r = [], i = this.getPoint(0), o = 0;
	for (r.push(0), n = 1; e >= n; n++)t = this.getPoint(n / e), o += t.distanceTo(i), r.push(o), i = t;
	return this.cacheArcLengths = r
}, THREE.Curve.prototype.updateArcLengths = function () {
	this.needsUpdate = !0, this.getLengths()
}, THREE.Curve.prototype.getUtoTmapping = function (e, t) {
	var n, r = this.getLengths(), i = 0, o = r.length;
	n = t ? t : e * r[o - 1];
	for (var a, s = 0, l = o - 1; l >= s;)if (i = Math.floor(s + (l - s) / 2), a = r[i] - n, 0 > a)s = i + 1; else {
		if (!(a > 0)) {
			l = i;
			break
		}
		l = i - 1
	}
	return i = l, r[i] == n ? i / (o - 1) : (s = r[i], r = (i + (n - s) / (r[i + 1] - s)) / (o - 1))
}, THREE.Curve.prototype.getTangent = function (e) {
	var t = e - 1e-4;
	return e += 1e-4, 0 > t && (t = 0), e > 1 && (e = 1), t = this.getPoint(t), this.getPoint(e).clone().sub(t).normalize()
}, THREE.Curve.prototype.getTangentAt = function (e) {
	return e = this.getUtoTmapping(e), this.getTangent(e)
}, THREE.Curve.Utils = {tangentQuadraticBezier: function (e, t, n, r) {
	return 2 * (1 - e) * (n - t) + 2 * e * (r - n)
}, tangentCubicBezier: function (e, t, n, r, i) {
	return-3 * t * (1 - e) * (1 - e) + 3 * n * (1 - e) * (1 - e) - 6 * e * n * (1 - e) + 6 * e * r * (1 - e) - 3 * e * e * r + 3 * e * e * i
}, tangentSpline: function (e) {
	return 6 * e * e - 6 * e + (3 * e * e - 4 * e + 1) + (-6 * e * e + 6 * e) + (3 * e * e - 2 * e)
}, interpolate: function (e, t, n, r, i) {
	e = .5 * (n - e), r = .5 * (r - t);
	var o = i * i;
	return(2 * t - 2 * n + e + r) * i * o + (-3 * t + 3 * n - 2 * e - r) * o + e * i + t
}}, THREE.Curve.create = function (e, t) {
	return e.prototype = Object.create(THREE.Curve.prototype), e.prototype.getPoint = t, e
}, THREE.CurvePath = function () {
	this.curves = [], this.bends = [], this.autoClose = !1
}, THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype), THREE.CurvePath.prototype.add = function (e) {
	this.curves.push(e)
}, THREE.CurvePath.prototype.checkConnection = function () {
}, THREE.CurvePath.prototype.closePath = function () {
	var e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
	e.equals(t) || this.curves.push(new THREE.LineCurve(t, e))
}, THREE.CurvePath.prototype.getPoint = function (e) {
	var t = e * this.getLength(), n = this.getCurveLengths();
	for (e = 0; e < n.length;) {
		if (n[e] >= t)return t = n[e] - t, e = this.curves[e], t = 1 - t / e.getLength(), e.getPointAt(t);
		e++
	}
	return null
}, THREE.CurvePath.prototype.getLength = function () {
	var e = this.getCurveLengths();
	return e[e.length - 1]
}, THREE.CurvePath.prototype.getCurveLengths = function () {
	if (this.cacheLengths && this.cacheLengths.length == this.curves.length)return this.cacheLengths;
	var e, t = [], n = 0, r = this.curves.length;
	for (e = 0; r > e; e++)n += this.curves[e].getLength(), t.push(n);
	return this.cacheLengths = t
}, THREE.CurvePath.prototype.getBoundingBox = function () {
	var e, t, n, r, i, o, a = this.getPoints();
	e = t = Number.NEGATIVE_INFINITY, r = i = Number.POSITIVE_INFINITY;
	var s, l, u, c, h = a[0]instanceof THREE.Vector3;
	for (c = h ? new THREE.Vector3 : new THREE.Vector2, l = 0, u = a.length; u > l; l++)s = a[l], s.x > e ? e = s.x : s.x < r && (r = s.x), s.y > t ? t = s.y : s.y < i && (i = s.y), h && (s.z > n ? n = s.z : s.z < o && (o = s.z)), c.add(s);
	return a = {minX: r, minY: i, maxX: e, maxY: t}, h && (a.maxZ = n, a.minZ = o), a
}, THREE.CurvePath.prototype.createPointsGeometry = function (e) {
	return e = this.getPoints(e, !0), this.createGeometry(e)
}, THREE.CurvePath.prototype.createSpacedPointsGeometry = function (e) {
	return e = this.getSpacedPoints(e, !0), this.createGeometry(e)
}, THREE.CurvePath.prototype.createGeometry = function (e) {
	for (var t = new THREE.Geometry, n = 0; n < e.length; n++)t.vertices.push(new THREE.Vector3(e[n].x, e[n].y, e[n].z || 0));
	return t
}, THREE.CurvePath.prototype.addWrapPath = function (e) {
	this.bends.push(e)
}, THREE.CurvePath.prototype.getTransformedPoints = function (e, t) {
	var n, r, i = this.getPoints(e);
	for (t || (t = this.bends), n = 0, r = t.length; r > n; n++)i = this.getWrapPoints(i, t[n]);
	return i
}, THREE.CurvePath.prototype.getTransformedSpacedPoints = function (e, t) {
	var n, r, i = this.getSpacedPoints(e);
	for (t || (t = this.bends), n = 0, r = t.length; r > n; n++)i = this.getWrapPoints(i, t[n]);
	return i
}, THREE.CurvePath.prototype.getWrapPoints = function (e, t) {
	var n, r, i, o, a, s, l = this.getBoundingBox();
	for (n = 0, r = e.length; r > n; n++)i = e[n], o = i.x, a = i.y, s = o / l.maxX, s = t.getUtoTmapping(s, o), o = t.getPoint(s), s = t.getTangent(s), s.set(-s.y, s.x).multiplyScalar(a), i.x = o.x + s.x, i.y = o.y + s.y;
	return e
}, THREE.Gyroscope = function () {
	THREE.Object3D.call(this)
}, THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype), THREE.Gyroscope.prototype.updateMatrixWorld = function (e) {
	this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent ? (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorld.decompose(this.translationWorld, this.quaternionWorld, this.scaleWorld), this.matrix.decompose(this.translationObject, this.quaternionObject, this.scaleObject), this.matrixWorld.compose(this.translationWorld, this.quaternionObject, this.scaleWorld)) : this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
	for (var t = 0, n = this.children.length; n > t; t++)this.children[t].updateMatrixWorld(e)
}, THREE.Gyroscope.prototype.translationWorld = new THREE.Vector3, THREE.Gyroscope.prototype.translationObject = new THREE.Vector3, THREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion, THREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion, THREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3, THREE.Gyroscope.prototype.scaleObject = new THREE.Vector3, THREE.Path = function (e) {
	THREE.CurvePath.call(this), this.actions = [], e && this.fromPoints(e)
}, THREE.Path.prototype = Object.create(THREE.CurvePath.prototype), THREE.PathActions = {MOVE_TO: "moveTo", LINE_TO: "lineTo", QUADRATIC_CURVE_TO: "quadraticCurveTo", BEZIER_CURVE_TO: "bezierCurveTo", CSPLINE_THRU: "splineThru", ARC: "arc", ELLIPSE: "ellipse"}, THREE.Path.prototype.fromPoints = function (e) {
	this.moveTo(e[0].x, e[0].y);
	for (var t = 1, n = e.length; n > t; t++)this.lineTo(e[t].x, e[t].y)
}, THREE.Path.prototype.moveTo = function () {
	var e = Array.prototype.slice.call(arguments);
	this.actions.push({action: THREE.PathActions.MOVE_TO, args: e})
}, THREE.Path.prototype.lineTo = function (e, t) {
	var n = Array.prototype.slice.call(arguments), r = this.actions[this.actions.length - 1].args, r = new THREE.LineCurve(new THREE.Vector2(r[r.length - 2], r[r.length - 1]), new THREE.Vector2(e, t));
	this.curves.push(r), this.actions.push({action: THREE.PathActions.LINE_TO, args: n})
}, THREE.Path.prototype.quadraticCurveTo = function (e, t, n, r) {
	var i = Array.prototype.slice.call(arguments), o = this.actions[this.actions.length - 1].args, o = new THREE.QuadraticBezierCurve(new THREE.Vector2(o[o.length - 2], o[o.length - 1]), new THREE.Vector2(e, t), new THREE.Vector2(n, r));
	this.curves.push(o), this.actions.push({action: THREE.PathActions.QUADRATIC_CURVE_TO, args: i})
}, THREE.Path.prototype.bezierCurveTo = function (e, t, n, r, i, o) {
	var a = Array.prototype.slice.call(arguments), s = this.actions[this.actions.length - 1].args, s = new THREE.CubicBezierCurve(new THREE.Vector2(s[s.length - 2], s[s.length - 1]), new THREE.Vector2(e, t), new THREE.Vector2(n, r), new THREE.Vector2(i, o));
	this.curves.push(s), this.actions.push({action: THREE.PathActions.BEZIER_CURVE_TO, args: a})
}, THREE.Path.prototype.splineThru = function (e) {
	var t = Array.prototype.slice.call(arguments), n = this.actions[this.actions.length - 1].args, n = [new THREE.Vector2(n[n.length - 2], n[n.length - 1])];
	Array.prototype.push.apply(n, e), n = new THREE.SplineCurve(n), this.curves.push(n), this.actions.push({action: THREE.PathActions.CSPLINE_THRU, args: t})
}, THREE.Path.prototype.arc = function (e, t, n, r, i, o) {
	var a = this.actions[this.actions.length - 1].args;
	this.absarc(e + a[a.length - 2], t + a[a.length - 1], n, r, i, o)
}, THREE.Path.prototype.absarc = function (e, t, n, r, i, o) {
	this.absellipse(e, t, n, n, r, i, o)
}, THREE.Path.prototype.ellipse = function (e, t, n, r, i, o, a) {
	var s = this.actions[this.actions.length - 1].args;
	this.absellipse(e + s[s.length - 2], t + s[s.length - 1], n, r, i, o, a)
}, THREE.Path.prototype.absellipse = function (e, t, n, r, i, o, a) {
	var s = Array.prototype.slice.call(arguments), l = new THREE.EllipseCurve(e, t, n, r, i, o, a);
	this.curves.push(l), l = l.getPoint(1), s.push(l.x), s.push(l.y), this.actions.push({action: THREE.PathActions.ELLIPSE, args: s})
}, THREE.Path.prototype.getSpacedPoints = function (e) {
	e || (e = 40);
	for (var t = [], n = 0; e > n; n++)t.push(this.getPoint(n / e));
	return t
}, THREE.Path.prototype.getPoints = function (e, t) {
	if (this.useSpacedPoints)return console.log("tata"), this.getSpacedPoints(e, t);
	e = e || 12;
	var n, r, i, o, a, s, l, u, c, h, f, d, p, m = [];
	for (n = 0, r = this.actions.length; r > n; n++)switch (i = this.actions[n], o = i.action, i = i.args, o) {
		case THREE.PathActions.MOVE_TO:
			m.push(new THREE.Vector2(i[0], i[1]));
			break;
		case THREE.PathActions.LINE_TO:
			m.push(new THREE.Vector2(i[0], i[1]));
			break;
		case THREE.PathActions.QUADRATIC_CURVE_TO:
			for (a = i[2], s = i[3], c = i[0], h = i[1], 0 < m.length ? (o = m[m.length - 1], f = o.x, d = o.y) : (o = this.actions[n - 1].args, f = o[o.length - 2], d = o[o.length - 1]), i = 1; e >= i; i++)p = i / e, o = THREE.Shape.Utils.b2(p, f, c, a), p = THREE.Shape.Utils.b2(p, d, h, s), m.push(new THREE.Vector2(o, p));
			break;
		case THREE.PathActions.BEZIER_CURVE_TO:
			for (a = i[4], s = i[5], c = i[0], h = i[1], l = i[2], u = i[3], 0 < m.length ? (o = m[m.length - 1], f = o.x, d = o.y) : (o = this.actions[n - 1].args, f = o[o.length - 2], d = o[o.length - 1]), i = 1; e >= i; i++)p = i / e, o = THREE.Shape.Utils.b3(p, f, c, l, a), p = THREE.Shape.Utils.b3(p, d, h, u, s), m.push(new THREE.Vector2(o, p));
			break;
		case THREE.PathActions.CSPLINE_THRU:
			for (o = this.actions[n - 1].args, p = [new THREE.Vector2(o[o.length - 2], o[o.length - 1])], o = e * i[0].length, p = p.concat(i[0]), p = new THREE.SplineCurve(p), i = 1; o >= i; i++)m.push(p.getPointAt(i / o));
			break;
		case THREE.PathActions.ARC:
			for (a = i[0], s = i[1], h = i[2], l = i[3], o = i[4], c = !!i[5], f = o - l, d = 2 * e, i = 1; d >= i; i++)p = i / d, c || (p = 1 - p), p = l + p * f, o = a + h * Math.cos(p), p = s + h * Math.sin(p), m.push(new THREE.Vector2(o, p));
			break;
		case THREE.PathActions.ELLIPSE:
			for (a = i[0], s = i[1], h = i[2], u = i[3], l = i[4], o = i[5], c = !!i[6], f = o - l, d = 2 * e, i = 1; d >= i; i++)p = i / d, c || (p = 1 - p), p = l + p * f, o = a + h * Math.cos(p), p = s + u * Math.sin(p), m.push(new THREE.Vector2(o, p))
	}
	return n = m[m.length - 1], 1e-10 > Math.abs(n.x - m[0].x) && 1e-10 > Math.abs(n.y - m[0].y) && m.splice(m.length - 1, 1), t && m.push(m[0]), m
}, THREE.Path.prototype.toShapes = function (e, t) {
	function n(e) {
		for (var t = [], n = 0, r = e.length; r > n; n++) {
			var i = e[n], o = new THREE.Shape;
			o.actions = i.actions, o.curves = i.curves, t.push(o)
		}
		return t
	}

	function r(e, t) {
		for (var n = t.length, r = !1, i = n - 1, o = 0; n > o; i = o++) {
			var a = t[i], s = t[o], l = s.x - a.x, u = s.y - a.y;
			if (1e-10 < Math.abs(u)) {
				if (0 > u && (a = t[o], l = -l, s = t[i], u = -u), !(e.y < a.y || e.y > s.y))if (e.y == a.y) {
					if (e.x == a.x)return!0
				} else {
					if (i = u * (e.x - a.x) - l * (e.y - a.y), 0 == i)return!0;
					0 > i || (r = !r)
				}
			} else if (e.y == a.y && (s.x <= e.x && e.x <= a.x || a.x <= e.x && e.x <= s.x))return!0
		}
		return r
	}

	var i = function (e) {
		var t, n, r, i, o = [], a = new THREE.Path;
		for (t = 0, n = e.length; n > t; t++)r = e[t], i = r.args, r = r.action, r == THREE.PathActions.MOVE_TO && 0 != a.actions.length && (o.push(a), a = new THREE.Path), a[r].apply(a, i);
		return 0 != a.actions.length && o.push(a), o
	}(this.actions);
	if (0 == i.length)return[];
	if (!0 === t)return n(i);
	var o, a, s, l = [];
	if (1 == i.length)return a = i[0], s = new THREE.Shape, s.actions = a.actions, s.curves = a.curves, l.push(s), l;
	var u = !THREE.Shape.Utils.isClockWise(i[0].getPoints()), u = e ? !u : u;
	s = [];
	var c, h = [], f = [], d = 0;
	h[d] = void 0, f[d] = [];
	var p, m;
	for (p = 0, m = i.length; m > p; p++)a = i[p], c = a.getPoints(), o = THREE.Shape.Utils.isClockWise(c), (o = e ? !o : o) ? (!u && h[d] && d++, h[d] = {s: new THREE.Shape, p: c}, h[d].s.actions = a.actions, h[d].s.curves = a.curves, u && d++, f[d] = []) : f[d].push({h: a, p: c[0]});
	if (!h[0])return n(i);
	if (1 < h.length) {
		for (p = !1, m = [], a = 0, i = h.length; i > a; a++)s[a] = [];
		for (a = 0, i = h.length; i > a; a++)for (o = f[a], u = 0; u < o.length; u++) {
			d = o[u], c = !0;
			for (var g = 0; g < h.length; g++)r(d.p, h[g].p) && (a != g && m.push({froms: a, tos: g, hole: u}), c ? (c = !1, s[g].push(d)) : p = !0);
			c && s[a].push(d)
		}
		0 < m.length && (p || (f = s))
	}
	for (p = 0, m = h.length; m > p; p++)for (s = h[p].s, l.push(s), a = f[p], i = 0, o = a.length; o > i; i++)s.holes.push(a[i].h);
	return l
}, THREE.Shape = function () {
	THREE.Path.apply(this, arguments), this.holes = []
}, THREE.Shape.prototype = Object.create(THREE.Path.prototype), THREE.Shape.prototype.extrude = function (e) {
	return new THREE.ExtrudeGeometry(this, e)
}, THREE.Shape.prototype.makeGeometry = function (e) {
	return new THREE.ShapeGeometry(this, e)
}, THREE.Shape.prototype.getPointsHoles = function (e) {
	var t, n = this.holes.length, r = [];
	for (t = 0; n > t; t++)r[t] = this.holes[t].getTransformedPoints(e, this.bends);
	return r
}, THREE.Shape.prototype.getSpacedPointsHoles = function (e) {
	var t, n = this.holes.length, r = [];
	for (t = 0; n > t; t++)r[t] = this.holes[t].getTransformedSpacedPoints(e, this.bends);
	return r
}, THREE.Shape.prototype.extractAllPoints = function (e) {
	return{shape: this.getTransformedPoints(e), holes: this.getPointsHoles(e)}
}, THREE.Shape.prototype.extractPoints = function (e) {
	return this.useSpacedPoints ? this.extractAllSpacedPoints(e) : this.extractAllPoints(e)
}, THREE.Shape.prototype.extractAllSpacedPoints = function (e) {
	return{shape: this.getTransformedSpacedPoints(e), holes: this.getSpacedPointsHoles(e)}
}, THREE.Shape.Utils = {triangulateShape: function (e, t) {
	function n(e, t, n) {
		return e.x != t.x ? e.x < t.x ? e.x <= n.x && n.x <= t.x : t.x <= n.x && n.x <= e.x : e.y < t.y ? e.y <= n.y && n.y <= t.y : t.y <= n.y && n.y <= e.y
	}

	function r(e, t, r, i, o) {
		var a = t.x - e.x, s = t.y - e.y, l = i.x - r.x, u = i.y - r.y, c = e.x - r.x, h = e.y - r.y, f = s * l - a * u, d = s * c - a * h;
		if (1e-10 < Math.abs(f)) {
			if (f > 0) {
				if (0 > d || d > f)return[];
				if (l = u * c - l * h, 0 > l || l > f)return[]
			} else {
				if (d > 0 || f > d)return[];
				if (l = u * c - l * h, l > 0 || f > l)return[]
			}
			return 0 == l ? !o || 0 != d && d != f ? [e] : [] : l == f ? !o || 0 != d && d != f ? [t] : [] : 0 == d ? [r] : d == f ? [i] : (o = l / f, [
				{x: e.x + o * a, y: e.y + o * s}
			])
		}
		return 0 != d || u * c != l * h ? [] : (s = 0 == a && 0 == s, l = 0 == l && 0 == u, s && l ? e.x != r.x || e.y != r.y ? [] : [e] : s ? n(r, i, e) ? [e] : [] : l ? n(e, t, r) ? [r] : [] : (0 != a ? (e.x < t.x ? (a = e, l = e.x, s = t, e = t.x) : (a = t, l = t.x, s = e, e = e.x), r.x < i.x ? (t = r, f = r.x, u = i, r = i.x) : (t = i, f = i.x, u = r, r = r.x)) : (e.y < t.y ? (a = e, l = e.y, s = t, e = t.y) : (a = t, l = t.y, s = e, e = e.y), r.y < i.y ? (t = r, f = r.y, u = i, r = i.y) : (t = i, f = i.y, u = r, r = r.y)), f >= l ? f > e ? [] : e == f ? o ? [] : [t] : r >= e ? [t, s] : [t, u] : l > r ? [] : l == r ? o ? [] : [a] : r >= e ? [a, s] : [a, u]))
	}

	function i(e, t, n, r) {
		var i = t.x - e.x, o = t.y - e.y;
		t = n.x - e.x, n = n.y - e.y;
		var a = r.x - e.x;
		return r = r.y - e.y, e = i * n - o * t, i = i * r - o * a, 1e-10 < Math.abs(e) ? (t = a * n - r * t, e > 0 ? i >= 0 && t >= 0 : i >= 0 || t >= 0) : i > 0
	}

	var o, a, s, l, u, c = {};
	for (s = e.concat(), o = 0, a = t.length; a > o; o++)Array.prototype.push.apply(s, t[o]);
	for (o = 0, a = s.length; a > o; o++)u = s[o].x + ":" + s[o].y, void 0 !== c[u] && console.log("Duplicate point", u), c[u] = o;
	o = function (e, t) {
		function n(e, t) {
			var n = g.length - 1, r = e - 1;
			0 > r && (r = n);
			var o = e + 1;
			return o > n && (o = 0), (n = i(g[e], g[r], g[o], s[t])) ? (n = s.length - 1, r = t - 1, 0 > r && (r = n), o = t + 1, o > n && (o = 0), (n = i(s[t], s[r], s[o], g[e])) ? !0 : !1) : !1
		}

		function o(e, t) {
			var n, i;
			for (n = 0; n < g.length; n++)if (i = n + 1, i %= g.length, i = r(e, t, g[n], g[i], !0), 0 < i.length)return!0;
			return!1
		}

		function a(e, n) {
			var i, o, a, s;
			for (i = 0; i < E.length; i++)for (o = t[E[i]], a = 0; a < o.length; a++)if (s = a + 1, s %= o.length, s = r(e, n, o[a], o[s], !0), 0 < s.length)return!0;
			return!1
		}

		var s, l, u, c, h, f, d, p, m, g = e.concat(), E = [], v = [], y = 0;
		for (l = t.length; l > y; y++)E.push(y);
		d = 0;
		for (var T = 2 * E.length; 0 < E.length;) {
			if (T--, 0 > T) {
				console.log("Infinite Loop! Holes left:" + E.length + ", Probably Hole outside Shape!");
				break
			}
			for (u = d; u < g.length; u++) {
				for (c = g[u], l = -1, y = 0; y < E.length; y++)if (h = E[y], f = c.x + ":" + c.y + ":" + h, void 0 === v[f]) {
					for (s = t[h], p = 0; p < s.length; p++)if (h = s[p], n(u, p) && !o(c, h) && !a(c, h)) {
						l = p, E.splice(y, 1), d = g.slice(0, u + 1), h = g.slice(u), p = s.slice(l), m = s.slice(0, l + 1), g = d.concat(p).concat(m).concat(h), d = u;
						break
					}
					if (l >= 0)break;
					v[f] = !0
				}
				if (l >= 0)break
			}
		}
		return g
	}(e, t);
	var h = THREE.FontUtils.Triangulate(o, !1);
	for (o = 0, a = h.length; a > o; o++)for (l = h[o], s = 0; 3 > s; s++)u = l[s].x + ":" + l[s].y, u = c[u], void 0 !== u && (l[s] = u);
	return h.concat()
}, isClockWise: function (e) {
	return 0 > THREE.FontUtils.Triangulate.area(e)
}, b2p0: function (e, t) {
	var n = 1 - e;
	return n * n * t
}, b2p1: function (e, t) {
	return 2 * (1 - e) * e * t
}, b2p2: function (e, t) {
	return e * e * t
}, b2: function (e, t, n, r) {
	return this.b2p0(e, t) + this.b2p1(e, n) + this.b2p2(e, r)
}, b3p0: function (e, t) {
	var n = 1 - e;
	return n * n * n * t
}, b3p1: function (e, t) {
	var n = 1 - e;
	return 3 * n * n * e * t
}, b3p2: function (e, t) {
	return 3 * (1 - e) * e * e * t
}, b3p3: function (e, t) {
	return e * e * e * t
}, b3: function (e, t, n, r, i) {
	return this.b3p0(e, t) + this.b3p1(e, n) + this.b3p2(e, r) + this.b3p3(e, i)
}}, THREE.LineCurve = function (e, t) {
	this.v1 = e, this.v2 = t
}, THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype), THREE.LineCurve.prototype.getPoint = function (e) {
	var t = this.v2.clone().sub(this.v1);
	return t.multiplyScalar(e).add(this.v1), t
}, THREE.LineCurve.prototype.getPointAt = function (e) {
	return this.getPoint(e)
}, THREE.LineCurve.prototype.getTangent = function () {
	return this.v2.clone().sub(this.v1).normalize()
}, THREE.QuadraticBezierCurve = function (e, t, n) {
	this.v0 = e, this.v1 = t, this.v2 = n
}, THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype), THREE.QuadraticBezierCurve.prototype.getPoint = function (e) {
	var t;
	return t = THREE.Shape.Utils.b2(e, this.v0.x, this.v1.x, this.v2.x), e = THREE.Shape.Utils.b2(e, this.v0.y, this.v1.y, this.v2.y), new THREE.Vector2(t, e)
}, THREE.QuadraticBezierCurve.prototype.getTangent = function (e) {
	var t;
	return t = THREE.Curve.Utils.tangentQuadraticBezier(e, this.v0.x, this.v1.x, this.v2.x), e = THREE.Curve.Utils.tangentQuadraticBezier(e, this.v0.y, this.v1.y, this.v2.y), t = new THREE.Vector2(t, e), t.normalize(), t
}, THREE.CubicBezierCurve = function (e, t, n, r) {
	this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r
}, THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype), THREE.CubicBezierCurve.prototype.getPoint = function (e) {
	var t;
	return t = THREE.Shape.Utils.b3(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), e = THREE.Shape.Utils.b3(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y), new THREE.Vector2(t, e)
}, THREE.CubicBezierCurve.prototype.getTangent = function (e) {
	var t;
	return t = THREE.Curve.Utils.tangentCubicBezier(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), e = THREE.Curve.Utils.tangentCubicBezier(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y), t = new THREE.Vector2(t, e), t.normalize(), t
}, THREE.SplineCurve = function (e) {
	this.points = void 0 == e ? [] : e
}, THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype), THREE.SplineCurve.prototype.getPoint = function (e) {
	var t, n = new THREE.Vector2, r = [], i = this.points;
	return t = (i.length - 1) * e, e = Math.floor(t), t -= e, r[0] = 0 == e ? e : e - 1, r[1] = e, r[2] = e > i.length - 2 ? i.length - 1 : e + 1, r[3] = e > i.length - 3 ? i.length - 1 : e + 2, n.x = THREE.Curve.Utils.interpolate(i[r[0]].x, i[r[1]].x, i[r[2]].x, i[r[3]].x, t), n.y = THREE.Curve.Utils.interpolate(i[r[0]].y, i[r[1]].y, i[r[2]].y, i[r[3]].y, t), n
}, THREE.EllipseCurve = function (e, t, n, r, i, o, a) {
	this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = r, this.aStartAngle = i, this.aEndAngle = o, this.aClockwise = a
}, THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype), THREE.EllipseCurve.prototype.getPoint = function (e) {
	var t;
	return t = this.aEndAngle - this.aStartAngle, 0 > t && (t += 2 * Math.PI), t > 2 * Math.PI && (t -= 2 * Math.PI), t = !0 === this.aClockwise ? this.aEndAngle + (1 - e) * (2 * Math.PI - t) : this.aStartAngle + e * t, e = this.aX + this.xRadius * Math.cos(t), t = this.aY + this.yRadius * Math.sin(t), new THREE.Vector2(e, t)
}, THREE.ArcCurve = function (e, t, n, r, i, o) {
	THREE.EllipseCurve.call(this, e, t, n, n, r, i, o)
}, THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype), THREE.LineCurve3 = THREE.Curve.create(function (e, t) {
	this.v1 = e, this.v2 = t
}, function (e) {
	var t = new THREE.Vector3;
	return t.subVectors(this.v2, this.v1), t.multiplyScalar(e), t.add(this.v1), t
}), THREE.QuadraticBezierCurve3 = THREE.Curve.create(function (e, t, n) {
	this.v0 = e, this.v1 = t, this.v2 = n
}, function (e) {
	var t, n;
	return t = THREE.Shape.Utils.b2(e, this.v0.x, this.v1.x, this.v2.x), n = THREE.Shape.Utils.b2(e, this.v0.y, this.v1.y, this.v2.y), e = THREE.Shape.Utils.b2(e, this.v0.z, this.v1.z, this.v2.z), new THREE.Vector3(t, n, e)
}), THREE.CubicBezierCurve3 = THREE.Curve.create(function (e, t, n, r) {
	this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r
}, function (e) {
	var t, n;
	return t = THREE.Shape.Utils.b3(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), n = THREE.Shape.Utils.b3(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y), e = THREE.Shape.Utils.b3(e, this.v0.z, this.v1.z, this.v2.z, this.v3.z), new THREE.Vector3(t, n, e)
}), THREE.SplineCurve3 = THREE.Curve.create(function (e) {
	this.points = void 0 == e ? [] : e
}, function (e) {
	var t, n = new THREE.Vector3, r = [], i = this.points;
	e *= i.length - 1, t = Math.floor(e), e -= t, r[0] = 0 == t ? t : t - 1, r[1] = t, r[2] = t > i.length - 2 ? i.length - 1 : t + 1, r[3] = t > i.length - 3 ? i.length - 1 : t + 2, t = i[r[0]];
	var o = i[r[1]], a = i[r[2]], r = i[r[3]];
	return n.x = THREE.Curve.Utils.interpolate(t.x, o.x, a.x, r.x, e), n.y = THREE.Curve.Utils.interpolate(t.y, o.y, a.y, r.y, e), n.z = THREE.Curve.Utils.interpolate(t.z, o.z, a.z, r.z, e), n
}), THREE.ClosedSplineCurve3 = THREE.Curve.create(function (e) {
	this.points = void 0 == e ? [] : e
}, function (e) {
	var t, n = new THREE.Vector3, r = [], i = this.points;
	return t = (i.length - 0) * e, e = Math.floor(t), t -= e, e += e > 0 ? 0 : (Math.floor(Math.abs(e) / i.length) + 1) * i.length, r[0] = (e - 1) % i.length, r[1] = e % i.length, r[2] = (e + 1) % i.length, r[3] = (e + 2) % i.length, n.x = THREE.Curve.Utils.interpolate(i[r[0]].x, i[r[1]].x, i[r[2]].x, i[r[3]].x, t), n.y = THREE.Curve.Utils.interpolate(i[r[0]].y, i[r[1]].y, i[r[2]].y, i[r[3]].y, t), n.z = THREE.Curve.Utils.interpolate(i[r[0]].z, i[r[1]].z, i[r[2]].z, i[r[3]].z, t), n
}), THREE.AnimationHandler = {LINEAR: 0, CATMULLROM: 1, CATMULLROM_FORWARD: 2, add: function () {
	console.warn("THREE.AnimationHandler.add() has been deprecated.")
}, get: function () {
	console.warn("THREE.AnimationHandler.get() has been deprecated.")
}, remove: function () {
	console.warn("THREE.AnimationHandler.remove() has been deprecated.")
}, animations: [], init: function (e) {
	if (!0 !== e.initialized) {
		for (var t = 0; t < e.hierarchy.length; t++) {
			for (var n = 0; n < e.hierarchy[t].keys.length; n++)if (0 > e.hierarchy[t].keys[n].time && (e.hierarchy[t].keys[n].time = 0), void 0 !== e.hierarchy[t].keys[n].rot && !(e.hierarchy[t].keys[n].rot instanceof THREE.Quaternion)) {
				var r = e.hierarchy[t].keys[n].rot;
				e.hierarchy[t].keys[n].rot = (new THREE.Quaternion).fromArray(r)
			}
			if (e.hierarchy[t].keys.length && void 0 !== e.hierarchy[t].keys[0].morphTargets) {
				for (r = {}, n = 0; n < e.hierarchy[t].keys.length; n++)for (var i = 0; i < e.hierarchy[t].keys[n].morphTargets.length; i++) {
					var o = e.hierarchy[t].keys[n].morphTargets[i];
					r[o] = -1
				}
				for (e.hierarchy[t].usedMorphTargets = r, n = 0; n < e.hierarchy[t].keys.length; n++) {
					var a = {};
					for (o in r) {
						for (i = 0; i < e.hierarchy[t].keys[n].morphTargets.length; i++)if (e.hierarchy[t].keys[n].morphTargets[i] === o) {
							a[o] = e.hierarchy[t].keys[n].morphTargetsInfluences[i];
							break
						}
						i === e.hierarchy[t].keys[n].morphTargets.length && (a[o] = 0)
					}
					e.hierarchy[t].keys[n].morphTargetsInfluences = a
				}
			}
			for (n = 1; n < e.hierarchy[t].keys.length; n++)e.hierarchy[t].keys[n].time === e.hierarchy[t].keys[n - 1].time && (e.hierarchy[t].keys.splice(n, 1), n--);
			for (n = 0; n < e.hierarchy[t].keys.length; n++)e.hierarchy[t].keys[n].index = n
		}
		return e.initialized = !0, e
	}
}, parse: function (e) {
	var t = function (e, n) {
		n.push(e);
		for (var r = 0; r < e.children.length; r++)t(e.children[r], n)
	}, n = [];
	if (e instanceof THREE.SkinnedMesh)for (var r = 0; r < e.skeleton.bones.length; r++)n.push(e.skeleton.bones[r]); else t(e, n);
	return n
}, play: function (e) {
	-1 === this.animations.indexOf(e) && this.animations.push(e)
}, stop: function (e) {
	e = this.animations.indexOf(e), -1 !== e && this.animations.splice(e, 1)
}, update: function (e) {
	for (var t = 0; t < this.animations.length; t++)this.animations[t].update(e)
}}, THREE.Animation = function (e, t) {
	this.root = e, this.data = THREE.AnimationHandler.init(t), this.hierarchy = THREE.AnimationHandler.parse(e), this.currentTime = 0, this.timeScale = 1, this.isPlaying = !1, this.loop = !0, this.weight = 0, this.interpolationType = THREE.AnimationHandler.LINEAR
}, THREE.Animation.prototype.keyTypes = ["pos", "rot", "scl"], THREE.Animation.prototype.play = function (e, t) {
	this.currentTime = void 0 !== e ? e : 0, this.weight = void 0 !== t ? t : 1, this.isPlaying = !0, this.reset(), THREE.AnimationHandler.play(this)
}, THREE.Animation.prototype.stop = function () {
	this.isPlaying = !1, THREE.AnimationHandler.stop(this)
}, THREE.Animation.prototype.reset = function () {
	for (var e = 0, t = this.hierarchy.length; t > e; e++) {
		var n = this.hierarchy[e];
		n.matrixAutoUpdate = !0, void 0 === n.animationCache && (n.animationCache = {}), void 0 === n.animationCache[this.data.name] && (n.animationCache[this.data.name] = {}, n.animationCache[this.data.name].prevKey = {pos: 0, rot: 0, scl: 0}, n.animationCache[this.data.name].nextKey = {pos: 0, rot: 0, scl: 0}, n.animationCache[this.data.name].originalMatrix = n.matrix);
		for (var n = n.animationCache[this.data.name], r = 0; 3 > r; r++) {
			for (var i = this.keyTypes[r], o = this.data.hierarchy[e].keys[0], a = this.getNextKeyWith(i, e, 1); a.time < this.currentTime && a.index > o.index;)o = a, a = this.getNextKeyWith(i, e, a.index + 1);
			n.prevKey[i] = o, n.nextKey[i] = a
		}
	}
}, THREE.Animation.prototype.update = function () {
	var e = [], t = new THREE.Vector3, n = new THREE.Vector3, r = new THREE.Quaternion, i = function (e, t) {
		var n, r, i, a, s, l, u = [], c = [];
		return n = (e.length - 1) * t, r = Math.floor(n), n -= r, u[0] = 0 === r ? r : r - 1, u[1] = r, u[2] = r > e.length - 2 ? r : r + 1, u[3] = r > e.length - 3 ? r : r + 2, r = e[u[0]], a = e[u[1]], s = e[u[2]], l = e[u[3]], u = n * n, i = n * u, c[0] = o(r[0], a[0], s[0], l[0], n, u, i), c[1] = o(r[1], a[1], s[1], l[1], n, u, i), c[2] = o(r[2], a[2], s[2], l[2], n, u, i), c
	}, o = function (e, t, n, r, i, o, a) {
		return e = .5 * (n - e), r = .5 * (r - t), (2 * (t - n) + e + r) * a + (-3 * (t - n) - 2 * e - r) * o + e * i + t
	};
	return function (o) {
		if (!1 !== this.isPlaying && (this.currentTime += o * this.timeScale, 0 !== this.weight)) {
			if (o = this.data.length, !0 === this.loop && this.currentTime > o)this.currentTime %= o, this.reset(); else if (!1 === this.loop && this.currentTime > o)return void this.stop();
			o = 0;
			for (var a = this.hierarchy.length; a > o; o++)for (var s = this.hierarchy[o], l = s.animationCache[this.data.name], u = 0; 3 > u; u++) {
				var c = this.keyTypes[u], h = l.prevKey[c], f = l.nextKey[c];
				if (f.time <= this.currentTime) {
					for (h = this.data.hierarchy[o].keys[0], f = this.getNextKeyWith(c, o, 1); f.time < this.currentTime && f.index > h.index;)h = f, f = this.getNextKeyWith(c, o, f.index + 1);
					l.prevKey[c] = h, l.nextKey[c] = f
				}
				s.matrixAutoUpdate = !0, s.matrixWorldNeedsUpdate = !0;
				var d = (this.currentTime - h.time) / (f.time - h.time), p = h[c], m = f[c];
				0 > d && (d = 0), d > 1 && (d = 1), "pos" === c ? this.interpolationType === THREE.AnimationHandler.LINEAR ? (n.x = p[0] + (m[0] - p[0]) * d, n.y = p[1] + (m[1] - p[1]) * d, n.z = p[2] + (m[2] - p[2]) * d, s instanceof THREE.Bone ? (h = this.weight / (this.weight + s.accumulatedPosWeight), s.position.lerp(n, h), s.accumulatedPosWeight += this.weight) : s.position.copy(n)) : (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) && (e[0] = this.getPrevKeyWith("pos", o, h.index - 1).pos, e[1] = p, e[2] = m, e[3] = this.getNextKeyWith("pos", o, f.index + 1).pos, d = .33 * d + .33, f = i(e, d), h = 1, s instanceof THREE.Bone && (h = this.weight / (this.weight + s.accumulatedPosWeight), s.accumulatedPosWeight += this.weight), c = s.position, c.x += (f[0] - c.x) * h, c.y += (f[1] - c.y) * h, c.z += (f[2] - c.z) * h, this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD && (d = i(e, 1.01 * d), t.set(d[0], d[1], d[2]), t.sub(c), t.y = 0, t.normalize(), d = Math.atan2(t.x, t.z), s.rotation.set(0, d, 0))) : "rot" === c ? (THREE.Quaternion.slerp(p, m, r, d), s instanceof THREE.Bone ? 0 === s.accumulatedRotWeight ? (s.quaternion.copy(r), s.accumulatedRotWeight = this.weight) : (h = this.weight / (this.weight + s.accumulatedRotWeight), THREE.Quaternion.slerp(s.quaternion, r, s.quaternion, h), s.accumulatedRotWeight += this.weight) : s.quaternion.copy(r)) : "scl" === c && (n.x = p[0] + (m[0] - p[0]) * d, n.y = p[1] + (m[1] - p[1]) * d, n.z = p[2] + (m[2] - p[2]) * d, s instanceof THREE.Bone ? (h = this.weight / (this.weight + s.accumulatedSclWeight), s.scale.lerp(n, h), s.accumulatedSclWeight += this.weight) : s.scale.copy(n))
			}
			return!0
		}
	}
}(), THREE.Animation.prototype.getNextKeyWith = function (e, t, n) {
	var r = this.data.hierarchy[t].keys;
	for (n = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? n < r.length - 1 ? n : r.length - 1 : n % r.length; n < r.length; n++)if (void 0 !== r[n][e])return r[n];
	return this.data.hierarchy[t].keys[0]
}, THREE.Animation.prototype.getPrevKeyWith = function (e, t, n) {
	var r = this.data.hierarchy[t].keys;
	for (n = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? n > 0 ? n : 0 : n >= 0 ? n : n + r.length; n >= 0; n--)if (void 0 !== r[n][e])return r[n];
	return this.data.hierarchy[t].keys[r.length - 1]
}, THREE.KeyFrameAnimation = function (e) {
	this.root = e.node, this.data = THREE.AnimationHandler.init(e), this.hierarchy = THREE.AnimationHandler.parse(this.root), this.currentTime = 0, this.timeScale = .001, this.isPlaying = !1, this.loop = this.isPaused = !0, e = 0;
	for (var t = this.hierarchy.length; t > e; e++) {
		var n = this.data.hierarchy[e].sids, r = this.hierarchy[e];
		if (this.data.hierarchy[e].keys.length && n) {
			for (var i = 0; i < n.length; i++) {
				var o = n[i], a = this.getNextKeyWith(o, e, 0);
				a && a.apply(o)
			}
			r.matrixAutoUpdate = !1, this.data.hierarchy[e].node.updateMatrix(), r.matrixWorldNeedsUpdate = !0
		}
	}
}, THREE.KeyFrameAnimation.prototype.play = function (e) {
	if (this.currentTime = void 0 !== e ? e : 0, !1 === this.isPlaying) {
		this.isPlaying = !0;
		var t, n, r = this.hierarchy.length;
		for (e = 0; r > e; e++)t = this.hierarchy[e], n = this.data.hierarchy[e], void 0 === n.animationCache && (n.animationCache = {}, n.animationCache.prevKey = null, n.animationCache.nextKey = null, n.animationCache.originalMatrix = t.matrix), t = this.data.hierarchy[e].keys, t.length && (n.animationCache.prevKey = t[0], n.animationCache.nextKey = t[1], this.startTime = Math.min(t[0].time, this.startTime), this.endTime = Math.max(t[t.length - 1].time, this.endTime));
		this.update(0)
	}
	this.isPaused = !1, THREE.AnimationHandler.play(this)
}, THREE.KeyFrameAnimation.prototype.stop = function () {
	this.isPaused = this.isPlaying = !1, THREE.AnimationHandler.stop(this);
	for (var e = 0; e < this.data.hierarchy.length; e++) {
		var t = this.hierarchy[e], n = this.data.hierarchy[e];
		if (void 0 !== n.animationCache) {
			var r = n.animationCache.originalMatrix;
			r.copy(t.matrix), t.matrix = r, delete n.animationCache
		}
	}
}, THREE.KeyFrameAnimation.prototype.update = function (e) {
	if (!1 !== this.isPlaying) {
		this.currentTime += e * this.timeScale, e = this.data.length, !0 === this.loop && this.currentTime > e && (this.currentTime %= e), this.currentTime = Math.min(this.currentTime, e), e = 0;
		for (var t = this.hierarchy.length; t > e; e++) {
			var n = this.hierarchy[e], r = this.data.hierarchy[e], i = r.keys, r = r.animationCache;
			if (i.length) {
				var o = r.prevKey, a = r.nextKey;
				if (a.time <= this.currentTime) {
					for (; a.time < this.currentTime && a.index > o.index;)o = a, a = i[o.index + 1];
					r.prevKey = o, r.nextKey = a
				}
				a.time >= this.currentTime ? o.interpolate(a, this.currentTime) : o.interpolate(a, a.time), this.data.hierarchy[e].node.updateMatrix(), n.matrixWorldNeedsUpdate = !0
			}
		}
	}
}, THREE.KeyFrameAnimation.prototype.getNextKeyWith = function (e, t, n) {
	for (t = this.data.hierarchy[t].keys, n %= t.length; n < t.length; n++)if (t[n].hasTarget(e))return t[n];
	return t[0]
}, THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function (e, t, n) {
	for (t = this.data.hierarchy[t].keys, n = n >= 0 ? n : n + t.length; n >= 0; n--)if (t[n].hasTarget(e))return t[n];
	return t[t.length - 1]
}, THREE.MorphAnimation = function (e) {
	this.mesh = e, this.frames = e.morphTargetInfluences.length, this.currentTime = 0, this.duration = 1e3, this.loop = !0, this.isPlaying = !1
}, THREE.MorphAnimation.prototype = {play: function () {
	this.isPlaying = !0
}, pause: function () {
	this.isPlaying = !1
}, update: function () {
	var e = 0, t = 0;
	return function (n) {
		if (!1 !== this.isPlaying) {
			this.currentTime += n, !0 === this.loop && this.currentTime > this.duration && (this.currentTime %= this.duration), this.currentTime = Math.min(this.currentTime, this.duration), n = this.duration / this.frames;
			var r = Math.floor(this.currentTime / n);
			r != t && (this.mesh.morphTargetInfluences[e] = 0, this.mesh.morphTargetInfluences[t] = 1, this.mesh.morphTargetInfluences[r] = 0, e = t, t = r), this.mesh.morphTargetInfluences[r] = this.currentTime % n / n, this.mesh.morphTargetInfluences[e] = 1 - this.mesh.morphTargetInfluences[r]
		}
	}
}()}, THREE.BoxGeometry = function (e, t, n, r, i, o) {
	function a(e, t, n, r, i, o, a, l) {
		var u, c = s.widthSegments, h = s.heightSegments, f = i / 2, d = o / 2, p = s.vertices.length;
		"x" === e && "y" === t || "y" === e && "x" === t ? u = "z" : "x" === e && "z" === t || "z" === e && "x" === t ? (u = "y", h = s.depthSegments) : ("z" === e && "y" === t || "y" === e && "z" === t) && (u = "x", c = s.depthSegments);
		var m = c + 1, g = h + 1, E = i / c, v = o / h, y = new THREE.Vector3;
		for (y[u] = a > 0 ? 1 : -1, i = 0; g > i; i++)for (o = 0; m > o; o++) {
			var T = new THREE.Vector3;
			T[e] = (o * E - f) * n, T[t] = (i * v - d) * r, T[u] = a, s.vertices.push(T)
		}
		for (i = 0; h > i; i++)for (o = 0; c > o; o++)d = o + m * i, e = o + m * (i + 1), t = o + 1 + m * (i + 1), n = o + 1 + m * i, r = new THREE.Vector2(o / c, 1 - i / h), a = new THREE.Vector2(o / c, 1 - (i + 1) / h), u = new THREE.Vector2((o + 1) / c, 1 - (i + 1) / h), f = new THREE.Vector2((o + 1) / c, 1 - i / h), d = new THREE.Face3(d + p, e + p, n + p), d.normal.copy(y), d.vertexNormals.push(y.clone(), y.clone(), y.clone()), d.materialIndex = l, s.faces.push(d), s.faceVertexUvs[0].push([r, a, f]), d = new THREE.Face3(e + p, t + p, n + p), d.normal.copy(y), d.vertexNormals.push(y.clone(), y.clone(), y.clone()), d.materialIndex = l, s.faces.push(d), s.faceVertexUvs[0].push([a.clone(), u, f.clone()])
	}

	THREE.Geometry.call(this), this.parameters = {width: e, height: t, depth: n, widthSegments: r, heightSegments: i, depthSegments: o}, this.widthSegments = r || 1, this.heightSegments = i || 1, this.depthSegments = o || 1;
	var s = this;
	r = e / 2, i = t / 2, o = n / 2, a("z", "y", -1, -1, n, t, r, 0), a("z", "y", 1, -1, n, t, -r, 1), a("x", "z", 1, 1, e, n, i, 2), a("x", "z", 1, -1, e, n, -i, 3), a("x", "y", 1, -1, e, t, o, 4), a("x", "y", -1, -1, e, t, -o, 5), this.mergeVertices()
}, THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.CircleGeometry = function (e, t, n, r) {
	THREE.Geometry.call(this), this.parameters = {radius: e, segments: t, thetaStart: n, thetaLength: r}, e = e || 50, t = void 0 !== t ? Math.max(3, t) : 8, n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
	var i, o = [];
	i = new THREE.Vector3;
	var a = new THREE.Vector2(.5, .5);
	for (this.vertices.push(i), o.push(a), i = 0; t >= i; i++) {
		var s = new THREE.Vector3, l = n + i / t * r;
		s.x = e * Math.cos(l), s.y = e * Math.sin(l), this.vertices.push(s), o.push(new THREE.Vector2((s.x / e + 1) / 2, (s.y / e + 1) / 2))
	}
	for (n = new THREE.Vector3(0, 0, 1), i = 1; t >= i; i++)this.faces.push(new THREE.Face3(i, i + 1, 0, [n.clone(), n.clone(), n.clone()])), this.faceVertexUvs[0].push([o[i].clone(), o[i + 1].clone(), a.clone()]);
	this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, e)
}, THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.CubeGeometry = function (e, t, n, r, i, o) {
	return console.warn("THEE.CubeGeometry has been renamed to THREE.BoxGeometry."), new THREE.BoxGeometry(e, t, n, r, i, o)
}, THREE.CylinderGeometry = function (e, t, n, r, i, o) {
	THREE.Geometry.call(this), this.parameters = {radiusTop: e, radiusBottom: t, height: n, radialSegments: r, heightSegments: i, openEnded: o}, e = void 0 !== e ? e : 20, t = void 0 !== t ? t : 20, n = void 0 !== n ? n : 100, r = r || 8, i = i || 1, o = void 0 !== o ? o : !1;
	var a, s, l = n / 2, u = [], c = [];
	for (s = 0; i >= s; s++) {
		var h = [], f = [], d = s / i, p = d * (t - e) + e;
		for (a = 0; r >= a; a++) {
			var m = a / r, g = new THREE.Vector3;
			g.x = p * Math.sin(m * Math.PI * 2), g.y = -d * n + l, g.z = p * Math.cos(m * Math.PI * 2), this.vertices.push(g), h.push(this.vertices.length - 1), f.push(new THREE.Vector2(m, 1 - d))
		}
		u.push(h), c.push(f)
	}
	for (n = (t - e) / n, a = 0; r > a; a++)for (0 !== e ? (h = this.vertices[u[0][a]].clone(), f = this.vertices[u[0][a + 1]].clone()) : (h = this.vertices[u[1][a]].clone(), f = this.vertices[u[1][a + 1]].clone()), h.setY(Math.sqrt(h.x * h.x + h.z * h.z) * n).normalize(), f.setY(Math.sqrt(f.x * f.x + f.z * f.z) * n).normalize(), s = 0; i > s; s++) {
		var d = u[s][a], p = u[s + 1][a], m = u[s + 1][a + 1], g = u[s][a + 1], E = h.clone(), v = h.clone(), y = f.clone(), T = f.clone(), x = c[s][a].clone(), R = c[s + 1][a].clone(), b = c[s + 1][a + 1].clone(), _ = c[s][a + 1].clone();
		this.faces.push(new THREE.Face3(d, p, g, [E, v, T])), this.faceVertexUvs[0].push([x, R, _]), this.faces.push(new THREE.Face3(p, m, g, [v.clone(), y, T.clone()])), this.faceVertexUvs[0].push([R.clone(), b, _.clone()])
	}
	if (!1 === o && e > 0)for (this.vertices.push(new THREE.Vector3(0, l, 0)), a = 0; r > a; a++)d = u[0][a], p = u[0][a + 1], m = this.vertices.length - 1, E = new THREE.Vector3(0, 1, 0), v = new THREE.Vector3(0, 1, 0), y = new THREE.Vector3(0, 1, 0), x = c[0][a].clone(), R = c[0][a + 1].clone(), b = new THREE.Vector2(R.x, 0), this.faces.push(new THREE.Face3(d, p, m, [E, v, y])), this.faceVertexUvs[0].push([x, R, b]);
	if (!1 === o && t > 0)for (this.vertices.push(new THREE.Vector3(0, -l, 0)), a = 0; r > a; a++)d = u[s][a + 1], p = u[s][a], m = this.vertices.length - 1, E = new THREE.Vector3(0, -1, 0), v = new THREE.Vector3(0, -1, 0), y = new THREE.Vector3(0, -1, 0), x = c[s][a + 1].clone(), R = c[s][a].clone(), b = new THREE.Vector2(R.x, 1), this.faces.push(new THREE.Face3(d, p, m, [E, v, y])), this.faceVertexUvs[0].push([x, R, b]);
	this.computeFaceNormals()
}, THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ExtrudeGeometry = function (e, t) {
	"undefined" != typeof e && (THREE.Geometry.call(this), e = e instanceof Array ? e : [e], this.addShapeList(e, t), this.computeFaceNormals())
}, THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ExtrudeGeometry.prototype.addShapeList = function (e, t) {
	for (var n = e.length, r = 0; n > r; r++)this.addShape(e[r], t)
}, THREE.ExtrudeGeometry.prototype.addShape = function (e, t) {
	function n(e, t, n) {
		return t || console.log("die"), t.clone().multiplyScalar(n).add(e)
	}

	function r(e, t, n) {
		var r = THREE.Math.sign, i = 1, i = e.x - t.x, o = e.y - t.y, a = n.x - e.x, s = n.y - e.y, l = i * i + o * o;
		if (1e-10 < Math.abs(i * s - o * a)) {
			var u = Math.sqrt(l), r = Math.sqrt(a * a + s * s), l = t.x - o / u;
			if (t = t.y + i / u, a = ((n.x - s / r - l) * s - (n.y + a / r - t) * a) / (i * s - o * a), n = l + i * a - e.x, e = t + o * a - e.y, i = n * n + e * e, 2 >= i)return new THREE.Vector2(n, e);
			i = Math.sqrt(i / 2)
		} else e = !1, i > 1e-10 ? a > 1e-10 && (e = !0) : -1e-10 > i ? -1e-10 > a && (e = !0) : r(o) == r(s) && (e = !0), e ? (n = -o, e = i, i = Math.sqrt(l)) : (n = i, e = o, i = Math.sqrt(l / 2));
		return new THREE.Vector2(n / i, e / i)
	}

	function i(n, r) {
		var i, o;
		for (B = n.length; 0 <= --B;) {
			i = B, o = B - 1, 0 > o && (o = n.length - 1);
			for (var a = 0, s = v + 2 * m, a = 0; s > a; a++) {
				var l = U * a, u = U * (a + 1), c = r + i + l, l = r + o + l, h = r + o + u, u = r + i + u, f = n, d = a, p = s, g = i, E = o, c = c + S, l = l + S, h = h + S, u = u + S;
				M.faces.push(new THREE.Face3(c, l, u, null, null, R)), M.faces.push(new THREE.Face3(l, h, u, null, null, R)), c = b.generateSideWallUV(M, e, f, t, c, l, h, u, d, p, g, E), M.faceVertexUvs[0].push([c[0], c[1], c[3]]), M.faceVertexUvs[0].push([c[1], c[2], c[3]])
			}
		}
	}

	function o(e, t, n) {
		M.vertices.push(new THREE.Vector3(e, t, n))
	}

	function a(n, r, i, o) {
		n += S, r += S, i += S, M.faces.push(new THREE.Face3(n, r, i, null, null, x)), n = o ? b.generateBottomUV(M, e, t, n, r, i) : b.generateTopUV(M, e, t, n, r, i), M.faceVertexUvs[0].push(n)
	}

	var s, l, u, c, h, f = void 0 !== t.amount ? t.amount : 100, d = void 0 !== t.bevelThickness ? t.bevelThickness : 6, p = void 0 !== t.bevelSize ? t.bevelSize : d - 2, m = void 0 !== t.bevelSegments ? t.bevelSegments : 3, g = void 0 !== t.bevelEnabled ? t.bevelEnabled : !0, E = void 0 !== t.curveSegments ? t.curveSegments : 12, v = void 0 !== t.steps ? t.steps : 1, y = t.extrudePath, T = !1, x = t.material, R = t.extrudeMaterial, b = void 0 !== t.UVGenerator ? t.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;
	y && (s = y.getSpacedPoints(v), T = !0, g = !1, l = void 0 !== t.frames ? t.frames : new THREE.TubeGeometry.FrenetFrames(y, v, !1), u = new THREE.Vector3, c = new THREE.Vector3, h = new THREE.Vector3), g || (p = d = m = 0);
	var _, w, H, M = this, S = this.vertices.length, y = e.extractPoints(E), E = y.shape, C = y.holes;
	if (y = !THREE.Shape.Utils.isClockWise(E)) {
		for (E = E.reverse(), w = 0, H = C.length; H > w; w++)_ = C[w], THREE.Shape.Utils.isClockWise(_) && (C[w] = _.reverse());
		y = !1
	}
	var A = THREE.Shape.Utils.triangulateShape(E, C), L = E;
	for (w = 0, H = C.length; H > w; w++)_ = C[w], E = E.concat(_);
	var k, P, D, F, N, z, U = E.length, V = A.length, y = [], B = 0;
	for (D = L.length, k = D - 1, P = B + 1; D > B; B++, k++, P++)k === D && (k = 0), P === D && (P = 0), y[B] = r(L[B], L[k], L[P]);
	var O, I = [], j = y.concat();
	for (w = 0, H = C.length; H > w; w++) {
		for (_ = C[w], O = [], B = 0, D = _.length, k = D - 1, P = B + 1; D > B; B++, k++, P++)k === D && (k = 0), P === D && (P = 0), O[B] = r(_[B], _[k], _[P]);
		I.push(O), j = j.concat(O)
	}
	for (k = 0; m > k; k++) {
		for (D = k / m, F = d * (1 - D), P = p * Math.sin(D * Math.PI / 2), B = 0, D = L.length; D > B; B++)N = n(L[B], y[B], P), o(N.x, N.y, -F);
		for (w = 0, H = C.length; H > w; w++)for (_ = C[w], O = I[w], B = 0, D = _.length; D > B; B++)N = n(_[B], O[B], P), o(N.x, N.y, -F)
	}
	for (P = p, B = 0; U > B; B++)N = g ? n(E[B], j[B], P) : E[B], T ? (c.copy(l.normals[0]).multiplyScalar(N.x), u.copy(l.binormals[0]).multiplyScalar(N.y), h.copy(s[0]).add(c).add(u), o(h.x, h.y, h.z)) : o(N.x, N.y, 0);
	for (D = 1; v >= D; D++)for (B = 0; U > B; B++)N = g ? n(E[B], j[B], P) : E[B], T ? (c.copy(l.normals[D]).multiplyScalar(N.x), u.copy(l.binormals[D]).multiplyScalar(N.y), h.copy(s[D]).add(c).add(u), o(h.x, h.y, h.z)) : o(N.x, N.y, f / v * D);
	for (k = m - 1; k >= 0; k--) {
		for (D = k / m, F = d * (1 - D), P = p * Math.sin(D * Math.PI / 2), B = 0, D = L.length; D > B; B++)N = n(L[B], y[B], P), o(N.x, N.y, f + F);
		for (w = 0, H = C.length; H > w; w++)for (_ = C[w], O = I[w], B = 0, D = _.length; D > B; B++)N = n(_[B], O[B], P), T ? o(N.x, N.y + s[v - 1].y, s[v - 1].x + F) : o(N.x, N.y, f + F)
	}
	!function () {
		if (g) {
			var e;
			for (e = 0 * U, B = 0; V > B; B++)z = A[B], a(z[2] + e, z[1] + e, z[0] + e, !0);
			for (e = v + 2 * m, e *= U, B = 0; V > B; B++)z = A[B], a(z[0] + e, z[1] + e, z[2] + e, !1)
		} else {
			for (B = 0; V > B; B++)z = A[B], a(z[2], z[1], z[0], !0);
			for (B = 0; V > B; B++)z = A[B], a(z[0] + U * v, z[1] + U * v, z[2] + U * v, !1)
		}
	}(), function () {
		var e = 0;
		for (i(L, e), e += L.length, w = 0, H = C.length; H > w; w++)_ = C[w], i(_, e), e += _.length
	}()
}, THREE.ExtrudeGeometry.WorldUVGenerator = {generateTopUV: function (e, t, n, r, i, o) {
	return t = e.vertices[i].x, i = e.vertices[i].y, n = e.vertices[o].x, o = e.vertices[o].y, [new THREE.Vector2(e.vertices[r].x, e.vertices[r].y), new THREE.Vector2(t, i), new THREE.Vector2(n, o)]
}, generateBottomUV: function (e, t, n, r, i, o) {
	return this.generateTopUV(e, t, n, r, i, o)
}, generateSideWallUV: function (e, t, n, r, i, o, a, s, l, u, c, h) {
	t = e.vertices[i].x, n = e.vertices[i].y, i = e.vertices[i].z, r = e.vertices[o].x, l = e.vertices[o].y, o = e.vertices[o].z, u = e.vertices[a].x, c = e.vertices[a].y, a = e.vertices[a].z, h = e.vertices[s].x;
	var f = e.vertices[s].y;
	return e = e.vertices[s].z, .01 > Math.abs(n - l) ? [new THREE.Vector2(t, 1 - i), new THREE.Vector2(r, 1 - o), new THREE.Vector2(u, 1 - a), new THREE.Vector2(h, 1 - e)] : [new THREE.Vector2(n, 1 - i), new THREE.Vector2(l, 1 - o), new THREE.Vector2(c, 1 - a), new THREE.Vector2(f, 1 - e)]
}}, THREE.ExtrudeGeometry.__v1 = new THREE.Vector2, THREE.ExtrudeGeometry.__v2 = new THREE.Vector2, THREE.ExtrudeGeometry.__v3 = new THREE.Vector2, THREE.ExtrudeGeometry.__v4 = new THREE.Vector2, THREE.ExtrudeGeometry.__v5 = new THREE.Vector2, THREE.ExtrudeGeometry.__v6 = new THREE.Vector2, THREE.ShapeGeometry = function (e, t) {
	THREE.Geometry.call(this), !1 == e instanceof Array && (e = [e]), this.addShapeList(e, t), this.computeFaceNormals()
}, THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ShapeGeometry.prototype.addShapeList = function (e, t) {
	for (var n = 0, r = e.length; r > n; n++)this.addShape(e[n], t);
	return this
}, THREE.ShapeGeometry.prototype.addShape = function (e, t) {
	void 0 === t && (t = {});
	var n, r, i, o = t.material, a = void 0 === t.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : t.UVGenerator, s = this.vertices.length;
	n = e.extractPoints(void 0 !== t.curveSegments ? t.curveSegments : 12);
	var l = n.shape, u = n.holes;
	if (!THREE.Shape.Utils.isClockWise(l))for (l = l.reverse(), n = 0, r = u.length; r > n; n++)i = u[n], THREE.Shape.Utils.isClockWise(i) && (u[n] = i.reverse());
	var c = THREE.Shape.Utils.triangulateShape(l, u);
	for (n = 0, r = u.length; r > n; n++)i = u[n], l = l.concat(i);
	for (u = l.length, r = c.length, n = 0; u > n; n++)i = l[n], this.vertices.push(new THREE.Vector3(i.x, i.y, 0));
	for (n = 0; r > n; n++)u = c[n], l = u[0] + s, i = u[1] + s, u = u[2] + s, this.faces.push(new THREE.Face3(l, i, u, null, null, o)), this.faceVertexUvs[0].push(a.generateBottomUV(this, e, t, l, i, u))
}, THREE.LatheGeometry = function (e, t, n, r) {
	THREE.Geometry.call(this), t = t || 12, n = n || 0, r = r || 2 * Math.PI;
	for (var i = 1 / (e.length - 1), o = 1 / t, a = 0, s = t; s >= a; a++)for (var l = n + a * o * r, u = Math.cos(l), c = Math.sin(l), l = 0, h = e.length; h > l; l++) {
		var f = e[l], d = new THREE.Vector3;
		d.x = u * f.x - c * f.y, d.y = c * f.x + u * f.y, d.z = f.z, this.vertices.push(d)
	}
	for (n = e.length, a = 0, s = t; s > a; a++)for (l = 0, h = e.length - 1; h > l; l++) {
		t = c = l + n * a, r = c + n;
		var u = c + 1 + n, c = c + 1, f = a * o, d = l * i, p = f + o, m = d + i;
		this.faces.push(new THREE.Face3(t, r, c)), this.faceVertexUvs[0].push([new THREE.Vector2(f, d), new THREE.Vector2(p, d), new THREE.Vector2(f, m)]), this.faces.push(new THREE.Face3(r, u, c)), this.faceVertexUvs[0].push([new THREE.Vector2(p, d), new THREE.Vector2(p, m), new THREE.Vector2(f, m)])
	}
	this.mergeVertices(), this.computeFaceNormals(), this.computeVertexNormals()
}, THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.PlaneGeometry = function (e, t, n, r) {
	THREE.Geometry.call(this), this.parameters = {width: e, height: t, widthSegments: n, heightSegments: r};
	var i = e / 2, o = t / 2;
	n = n || 1, r = r || 1;
	var a = n + 1, s = r + 1, l = e / n, u = t / r, c = new THREE.Vector3(0, 0, 1);
	for (e = 0; s > e; e++) {
		var h = e * u - o;
		for (t = 0; a > t; t++)this.vertices.push(new THREE.Vector3(t * l - i, -h, 0))
	}
	for (e = 0; r > e; e++)for (t = 0; n > t; t++) {
		var f = t + a * e, i = t + a * (e + 1), o = t + 1 + a * (e + 1), s = t + 1 + a * e, l = new THREE.Vector2(t / n, 1 - e / r), u = new THREE.Vector2(t / n, 1 - (e + 1) / r), h = new THREE.Vector2((t + 1) / n, 1 - (e + 1) / r), d = new THREE.Vector2((t + 1) / n, 1 - e / r), f = new THREE.Face3(f, i, s);
		f.normal.copy(c), f.vertexNormals.push(c.clone(), c.clone(), c.clone()), this.faces.push(f), this.faceVertexUvs[0].push([l, u, d]), f = new THREE.Face3(i, o, s), f.normal.copy(c), f.vertexNormals.push(c.clone(), c.clone(), c.clone()), this.faces.push(f), this.faceVertexUvs[0].push([u.clone(), h, d.clone()])
	}
}, THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.RingGeometry = function (e, t, n, r, i, o) {
	THREE.Geometry.call(this), e = e || 0, t = t || 50, i = void 0 !== i ? i : 0, o = void 0 !== o ? o : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8, r = void 0 !== r ? Math.max(1, r) : 8;
	var a, s = [], l = e, u = (t - e) / r;
	for (e = 0; r + 1 > e; e++) {
		for (a = 0; n + 1 > a; a++) {
			var c = new THREE.Vector3, h = i + a / n * o;
			c.x = l * Math.cos(h), c.y = l * Math.sin(h), this.vertices.push(c), s.push(new THREE.Vector2((c.x / t + 1) / 2, (c.y / t + 1) / 2))
		}
		l += u
	}
	for (t = new THREE.Vector3(0, 0, 1), e = 0; r > e; e++)for (i = e * (n + 1), a = 0; n > a; a++)o = h = a + i, u = h + n + 1, c = h + n + 2, this.faces.push(new THREE.Face3(o, u, c, [t.clone(), t.clone(), t.clone()])), this.faceVertexUvs[0].push([s[o].clone(), s[u].clone(), s[c].clone()]), o = h, u = h + n + 2, c = h + 1, this.faces.push(new THREE.Face3(o, u, c, [t.clone(), t.clone(), t.clone()])), this.faceVertexUvs[0].push([s[o].clone(), s[u].clone(), s[c].clone()]);
	this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, l)
}, THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.SphereGeometry = function (e, t, n, r, i, o, a) {
	THREE.Geometry.call(this), this.parameters = {radius: e, widthSegments: t, heightSegments: n, phiStart: r, phiLength: i, thetaStart: o, thetaLength: a}, e = e || 50, t = Math.max(3, Math.floor(t) || 8), n = Math.max(2, Math.floor(n) || 6), r = void 0 !== r ? r : 0, i = void 0 !== i ? i : 2 * Math.PI, o = void 0 !== o ? o : 0, a = void 0 !== a ? a : Math.PI;
	var s, l, u = [], c = [];
	for (l = 0; n >= l; l++) {
		var h = [], f = [];
		for (s = 0; t >= s; s++) {
			var d = s / t, p = l / n, m = new THREE.Vector3;
			m.x = -e * Math.cos(r + d * i) * Math.sin(o + p * a), m.y = e * Math.cos(o + p * a), m.z = e * Math.sin(r + d * i) * Math.sin(o + p * a), this.vertices.push(m), h.push(this.vertices.length - 1), f.push(new THREE.Vector2(d, 1 - p))
		}
		u.push(h), c.push(f)
	}
	for (l = 0; n > l; l++)for (s = 0; t > s; s++) {
		r = u[l][s + 1], i = u[l][s], o = u[l + 1][s], a = u[l + 1][s + 1];
		var h = this.vertices[r].clone().normalize(), f = this.vertices[i].clone().normalize(), d = this.vertices[o].clone().normalize(), p = this.vertices[a].clone().normalize(), m = c[l][s + 1].clone(), g = c[l][s].clone(), E = c[l + 1][s].clone(), v = c[l + 1][s + 1].clone();
		Math.abs(this.vertices[r].y) === e ? (m.x = (m.x + g.x) / 2, this.faces.push(new THREE.Face3(r, o, a, [h, d, p])), this.faceVertexUvs[0].push([m, E, v])) : Math.abs(this.vertices[o].y) === e ? (E.x = (E.x + v.x) / 2, this.faces.push(new THREE.Face3(r, i, o, [h, f, d])), this.faceVertexUvs[0].push([m, g, E])) : (this.faces.push(new THREE.Face3(r, i, a, [h, f, p])), this.faceVertexUvs[0].push([m, g, v]), this.faces.push(new THREE.Face3(i, o, a, [f.clone(), d, p.clone()])), this.faceVertexUvs[0].push([g.clone(), E, v.clone()]))
	}
	this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, e)
}, THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TextGeometry = function (e, t) {
	t = t || {};
	var n = THREE.FontUtils.generateShapes(e, t);
	t.amount = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), THREE.ExtrudeGeometry.call(this, n, t)
}, THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype), THREE.TorusGeometry = function (e, t, n, r, i) {
	THREE.Geometry.call(this), this.parameters = {radius: e, tube: t, radialSegments: n, tubularSegments: r, arc: i}, e = e || 100, t = t || 40, n = n || 8, r = r || 6, i = i || 2 * Math.PI;
	for (var o = new THREE.Vector3, a = [], s = [], l = 0; n >= l; l++)for (var u = 0; r >= u; u++) {
		var c = u / r * i, h = l / n * Math.PI * 2;
		o.x = e * Math.cos(c), o.y = e * Math.sin(c);
		var f = new THREE.Vector3;
		f.x = (e + t * Math.cos(h)) * Math.cos(c), f.y = (e + t * Math.cos(h)) * Math.sin(c), f.z = t * Math.sin(h), this.vertices.push(f), a.push(new THREE.Vector2(u / r, l / n)), s.push(f.clone().sub(o).normalize())
	}
	for (l = 1; n >= l; l++)for (u = 1; r >= u; u++)e = (r + 1) * l + u - 1, t = (r + 1) * (l - 1) + u - 1, i = (r + 1) * (l - 1) + u, o = (r + 1) * l + u, c = new THREE.Face3(e, t, o, [s[e].clone(), s[t].clone(), s[o].clone()]), this.faces.push(c), this.faceVertexUvs[0].push([a[e].clone(), a[t].clone(), a[o].clone()]), c = new THREE.Face3(t, i, o, [s[t].clone(), s[i].clone(), s[o].clone()]), this.faces.push(c), this.faceVertexUvs[0].push([a[t].clone(), a[i].clone(), a[o].clone()]);
	this.computeFaceNormals()
}, THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TorusKnotGeometry = function (e, t, n, r, i, o, a) {
	function s(e, t, n, r, i) {
		var o = Math.cos(e), a = Math.sin(e);
		return e *= t / n, t = Math.cos(e), o *= r * (2 + t) * .5, a = r * (2 + t) * a * .5, r = i * r * Math.sin(e) * .5, new THREE.Vector3(o, a, r)
	}

	THREE.Geometry.call(this), this.parameters = {radius: e, tube: t, radialSegments: n, tubularSegments: r, p: i, q: o, heightScale: a}, e = e || 100, t = t || 40, n = n || 64, r = r || 8, i = i || 2, o = o || 3, a = a || 1;
	for (var l = Array(n), u = new THREE.Vector3, c = new THREE.Vector3, h = new THREE.Vector3, f = 0; n > f; ++f) {
		l[f] = Array(r);
		var d = f / n * 2 * i * Math.PI, p = s(d, o, i, e, a), d = s(d + .01, o, i, e, a);
		for (u.subVectors(d, p), c.addVectors(d, p), h.crossVectors(u, c), c.crossVectors(h, u), h.normalize(), c.normalize(), d = 0; r > d; ++d) {
			var m = d / r * 2 * Math.PI, g = -t * Math.cos(m), m = t * Math.sin(m), E = new THREE.Vector3;
			E.x = p.x + g * c.x + m * h.x, E.y = p.y + g * c.y + m * h.y, E.z = p.z + g * c.z + m * h.z, l[f][d] = this.vertices.push(E) - 1
		}
	}
	for (f = 0; n > f; ++f)for (d = 0; r > d; ++d)i = (f + 1) % n, o = (d + 1) % r, e = l[f][d], t = l[i][d], i = l[i][o], o = l[f][o], a = new THREE.Vector2(f / n, d / r), u = new THREE.Vector2((f + 1) / n, d / r), c = new THREE.Vector2((f + 1) / n, (d + 1) / r), h = new THREE.Vector2(f / n, (d + 1) / r), this.faces.push(new THREE.Face3(e, t, o)), this.faceVertexUvs[0].push([a, u, h]), this.faces.push(new THREE.Face3(t, i, o)), this.faceVertexUvs[0].push([u.clone(), c, h.clone()]);
	this.computeFaceNormals(), this.computeVertexNormals()
}, THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TubeGeometry = function (e, t, n, r, i) {
	THREE.Geometry.call(this), this.parameters = {path: e, segments: t, radius: n, radialSegments: r, closed: i}, t = t || 64, n = n || 1, r = r || 8, i = i || !1;
	var o, a, s, l, u, c, h, f, d, p = [], m = t + 1, g = new THREE.Vector3;
	for (h = new THREE.TubeGeometry.FrenetFrames(e, t, i), f = h.normals, d = h.binormals, this.tangents = h.tangents, this.normals = f, this.binormals = d, h = 0; m > h; h++)for (p[h] = [], s = h / (m - 1), c = e.getPointAt(s), o = f[h], a = d[h], s = 0; r > s; s++)l = s / r * 2 * Math.PI, u = -n * Math.cos(l), l = n * Math.sin(l), g.copy(c), g.x += u * o.x + l * a.x, g.y += u * o.y + l * a.y, g.z += u * o.z + l * a.z, p[h][s] = this.vertices.push(new THREE.Vector3(g.x, g.y, g.z)) - 1;
	for (h = 0; t > h; h++)for (s = 0; r > s; s++)m = i ? (h + 1) % t : h + 1, g = (s + 1) % r, e = p[h][s], n = p[m][s], m = p[m][g], g = p[h][g], f = new THREE.Vector2(h / t, s / r), d = new THREE.Vector2((h + 1) / t, s / r), o = new THREE.Vector2((h + 1) / t, (s + 1) / r), a = new THREE.Vector2(h / t, (s + 1) / r), this.faces.push(new THREE.Face3(e, n, g)), this.faceVertexUvs[0].push([f, d, a]), this.faces.push(new THREE.Face3(n, m, g)), this.faceVertexUvs[0].push([d.clone(), o, a.clone()]);
	this.computeFaceNormals(), this.computeVertexNormals()
}, THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TubeGeometry.FrenetFrames = function (e, t, n) {
	new THREE.Vector3;
	var r = new THREE.Vector3;
	new THREE.Vector3;
	var i = [], o = [], a = [], s = new THREE.Vector3, l = new THREE.Matrix4;
	t += 1;
	var u, c, h;
	for (this.tangents = i, this.normals = o, this.binormals = a, u = 0; t > u; u++)c = u / (t - 1), i[u] = e.getTangentAt(c), i[u].normalize();
	for (o[0] = new THREE.Vector3, a[0] = new THREE.Vector3, e = Number.MAX_VALUE, u = Math.abs(i[0].x), c = Math.abs(i[0].y), h = Math.abs(i[0].z), e >= u && (e = u, r.set(1, 0, 0)), e >= c && (e = c, r.set(0, 1, 0)), e >= h && r.set(0, 0, 1), s.crossVectors(i[0], r).normalize(), o[0].crossVectors(i[0], s), a[0].crossVectors(i[0], o[0]), u = 1; t > u; u++)o[u] = o[u - 1].clone(), a[u] = a[u - 1].clone(), s.crossVectors(i[u - 1], i[u]), 1e-4 < s.length() && (s.normalize(), r = Math.acos(THREE.Math.clamp(i[u - 1].dot(i[u]), -1, 1)), o[u].applyMatrix4(l.makeRotationAxis(s, r))), a[u].crossVectors(i[u], o[u]);
	if (n)for (r = Math.acos(THREE.Math.clamp(o[0].dot(o[t - 1]), -1, 1)), r /= t - 1, 0 < i[0].dot(s.crossVectors(o[0], o[t - 1])) && (r = -r), u = 1; t > u; u++)o[u].applyMatrix4(l.makeRotationAxis(i[u], r * u)), a[u].crossVectors(i[u], o[u])
}, THREE.PolyhedronGeometry = function (e, t, n, r) {
	function i(e) {
		var t = e.normalize().clone();
		t.index = l.vertices.push(t) - 1;
		var n = Math.atan2(e.z, -e.x) / 2 / Math.PI + .5;
		return e = Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5, t.uv = new THREE.Vector2(n, 1 - e), t
	}

	function o(e, t, n) {
		var r = new THREE.Face3(e.index, t.index, n.index, [e.clone(), t.clone(), n.clone()]);
		l.faces.push(r), g.copy(e).add(t).add(n).divideScalar(3), r = Math.atan2(g.z, -g.x), l.faceVertexUvs[0].push([s(e.uv, e, r), s(t.uv, t, r), s(n.uv, n, r)])
	}

	function a(e, t) {
		var n = Math.pow(2, t);
		Math.pow(4, t);
		for (var r = i(l.vertices[e.a]), a = i(l.vertices[e.b]), s = i(l.vertices[e.c]), u = [], c = 0; n >= c; c++) {
			u[c] = [];
			for (var h = i(r.clone().lerp(s, c / n)), f = i(a.clone().lerp(s, c / n)), d = n - c, p = 0; d >= p; p++)u[c][p] = 0 == p && c == n ? h : i(h.clone().lerp(f, p / d))
		}
		for (c = 0; n > c; c++)for (p = 0; 2 * (n - c) - 1 > p; p++)r = Math.floor(p / 2), 0 == p % 2 ? o(u[c][r + 1], u[c + 1][r], u[c][r]) : o(u[c][r + 1], u[c + 1][r + 1], u[c + 1][r])
	}

	function s(e, t, n) {
		return 0 > n && 1 === e.x && (e = new THREE.Vector2(e.x - 1, e.y)), 0 === t.x && 0 === t.z && (e = new THREE.Vector2(n / 2 / Math.PI + .5, e.y)), e.clone()
	}

	THREE.Geometry.call(this), n = n || 1, r = r || 0;
	for (var l = this, u = 0, c = e.length; c > u; u += 3)i(new THREE.Vector3(e[u], e[u + 1], e[u + 2]));
	e = this.vertices;
	for (var h = [], f = u = 0, c = t.length; c > u; u += 3, f++) {
		var d = e[t[u]], p = e[t[u + 1]], m = e[t[u + 2]];
		h[f] = new THREE.Face3(d.index, p.index, m.index, [d.clone(), p.clone(), m.clone()])
	}
	for (var g = new THREE.Vector3, u = 0, c = h.length; c > u; u++)a(h[u], r);
	for (u = 0, c = this.faceVertexUvs[0].length; c > u; u++)t = this.faceVertexUvs[0][u], r = t[0].x, e = t[1].x, h = t[2].x, f = Math.max(r, Math.max(e, h)), d = Math.min(r, Math.min(e, h)), f > .9 && .1 > d && (.2 > r && (t[0].x += 1), .2 > e && (t[1].x += 1), .2 > h && (t[2].x += 1));
	for (u = 0, c = this.vertices.length; c > u; u++)this.vertices[u].multiplyScalar(n);
	this.mergeVertices(), this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, n)
}, THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.IcosahedronGeometry = function (e, t) {
	this.parameters = {radius: e, detail: t};
	var n = (1 + Math.sqrt(5)) / 2;
	THREE.PolyhedronGeometry.call(this, [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t)
}, THREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.OctahedronGeometry = function (e, t) {
	this.parameters = {radius: e, detail: t}, THREE.PolyhedronGeometry.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t)
}, THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TetrahedronGeometry = function (e, t) {
	THREE.PolyhedronGeometry.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t)
}, THREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ParametricGeometry = function (e, t, n) {
	THREE.Geometry.call(this);
	var r, i, o, a, s = this.vertices, l = this.faces, u = this.faceVertexUvs[0], c = t + 1;
	for (r = 0; n >= r; r++)for (a = r / n, i = 0; t >= i; i++)o = i / t, o = e(o, a), s.push(o);
	var h, f, d, p;
	for (r = 0; n > r; r++)for (i = 0; t > i; i++)e = r * c + i, s = r * c + i + 1, a = (r + 1) * c + i + 1, o = (r + 1) * c + i, h = new THREE.Vector2(i / t, r / n), f = new THREE.Vector2((i + 1) / t, r / n), d = new THREE.Vector2((i + 1) / t, (r + 1) / n), p = new THREE.Vector2(i / t, (r + 1) / n), l.push(new THREE.Face3(e, s, o)), u.push([h, f, p]), l.push(new THREE.Face3(s, a, o)), u.push([f.clone(), d, p.clone()]);
	this.computeFaceNormals(), this.computeVertexNormals()
}, THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.AxisHelper = function (e) {
	e = e || 1;
	var t = new Float32Array([0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]), n = new Float32Array([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]);
	e = new THREE.BufferGeometry, e.addAttribute("position", new THREE.BufferAttribute(t, 3)), e.addAttribute("color", new THREE.BufferAttribute(n, 3)), t = new THREE.LineBasicMaterial({vertexColors: THREE.VertexColors}), THREE.Line.call(this, e, t, THREE.LinePieces)
}, THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype), THREE.ArrowHelper = function () {
	var e = new THREE.Geometry;
	e.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));
	var t = new THREE.CylinderGeometry(0, .5, 1, 5, 1);
	return t.applyMatrix((new THREE.Matrix4).makeTranslation(0, -.5, 0)), function (n, r, i, o, a, s) {
		THREE.Object3D.call(this), void 0 === o && (o = 16776960), void 0 === i && (i = 1), void 0 === a && (a = .2 * i), void 0 === s && (s = .2 * a), this.position.copy(r), this.line = new THREE.Line(e, new THREE.LineBasicMaterial({color: o})), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new THREE.Mesh(t, new THREE.MeshBasicMaterial({color: o})), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(n), this.setLength(i, a, s)
	}
}(), THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.ArrowHelper.prototype.setDirection = function () {
	var e, t = new THREE.Vector3;
	return function (n) {
		.99999 < n.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > n.y ? this.quaternion.set(1, 0, 0, 0) : (t.set(n.z, 0, -n.x).normalize(), e = Math.acos(n.y), this.quaternion.setFromAxisAngle(t, e))
	}
}(), THREE.ArrowHelper.prototype.setLength = function (e, t, n) {
	void 0 === t && (t = .2 * e), void 0 === n && (n = .2 * t), this.line.scale.set(1, e, 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix()
}, THREE.ArrowHelper.prototype.setColor = function (e) {
	this.line.material.color.set(e), this.cone.material.color.set(e)
}, THREE.BoxHelper = function (e) {
	var t = new THREE.BufferGeometry;
	t.addAttribute("position", new THREE.BufferAttribute(new Float32Array(72), 3)), THREE.Line.call(this, t, new THREE.LineBasicMaterial({color: 16776960}), THREE.LinePieces), void 0 !== e && this.update(e)
}, THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype), THREE.BoxHelper.prototype.update = function (e) {
	var t = e.geometry;
	null === t.boundingBox && t.computeBoundingBox();
	var n = t.boundingBox.min, t = t.boundingBox.max, r = this.geometry.attributes.position.array;
	r[0] = t.x, r[1] = t.y, r[2] = t.z, r[3] = n.x, r[4] = t.y, r[5] = t.z, r[6] = n.x, r[7] = t.y, r[8] = t.z, r[9] = n.x, r[10] = n.y, r[11] = t.z, r[12] = n.x, r[13] = n.y, r[14] = t.z, r[15] = t.x, r[16] = n.y, r[17] = t.z, r[18] = t.x, r[19] = n.y, r[20] = t.z, r[21] = t.x, r[22] = t.y, r[23] = t.z, r[24] = t.x, r[25] = t.y, r[26] = n.z, r[27] = n.x, r[28] = t.y, r[29] = n.z, r[30] = n.x, r[31] = t.y, r[32] = n.z, r[33] = n.x, r[34] = n.y, r[35] = n.z, r[36] = n.x, r[37] = n.y, r[38] = n.z, r[39] = t.x, r[40] = n.y, r[41] = n.z, r[42] = t.x, r[43] = n.y, r[44] = n.z, r[45] = t.x, r[46] = t.y, r[47] = n.z, r[48] = t.x, r[49] = t.y, r[50] = t.z, r[51] = t.x, r[52] = t.y, r[53] = n.z, r[54] = n.x, r[55] = t.y, r[56] = t.z, r[57] = n.x, r[58] = t.y, r[59] = n.z, r[60] = n.x, r[61] = n.y, r[62] = t.z, r[63] = n.x, r[64] = n.y, r[65] = n.z, r[66] = t.x, r[67] = n.y, r[68] = t.z, r[69] = t.x, r[70] = n.y, r[71] = n.z, this.geometry.attributes.position.needsUpdate = !0, this.geometry.computeBoundingSphere(), this.matrixAutoUpdate = !1, this.matrixWorld = e.matrixWorld
}, THREE.BoundingBoxHelper = function (e, t) {
	var n = void 0 !== t ? t : 8947848;
	this.object = e, this.box = new THREE.Box3, THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({color: n, wireframe: !0}))
}, THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype), THREE.BoundingBoxHelper.prototype.update = function () {
	this.box.setFromObject(this.object), this.box.size(this.scale), this.box.center(this.position)
}, THREE.CameraHelper = function (e) {
	function t(e, t, r) {
		n(e, r), n(t, r)
	}

	function n(e, t) {
		r.vertices.push(new THREE.Vector3), r.colors.push(new THREE.Color(t)), void 0 === o[e] && (o[e] = []), o[e].push(r.vertices.length - 1)
	}

	var r = new THREE.Geometry, i = new THREE.LineBasicMaterial({color: 16777215, vertexColors: THREE.FaceColors}), o = {};
	t("n1", "n2", 16755200), t("n2", "n4", 16755200), t("n4", "n3", 16755200), t("n3", "n1", 16755200), t("f1", "f2", 16755200), t("f2", "f4", 16755200), t("f4", "f3", 16755200), t("f3", "f1", 16755200), t("n1", "f1", 16755200), t("n2", "f2", 16755200), t("n3", "f3", 16755200), t("n4", "f4", 16755200), t("p", "n1", 16711680), t("p", "n2", 16711680), t("p", "n3", 16711680), t("p", "n4", 16711680), t("u1", "u2", 43775), t("u2", "u3", 43775), t("u3", "u1", 43775), t("c", "t", 16777215), t("p", "c", 3355443), t("cn1", "cn2", 3355443), t("cn3", "cn4", 3355443), t("cf1", "cf2", 3355443), t("cf3", "cf4", 3355443), THREE.Line.call(this, r, i, THREE.LinePieces), this.camera = e, this.matrixWorld = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update()
}, THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype), THREE.CameraHelper.prototype.update = function () {
	var e = new THREE.Vector3, t = new THREE.Camera, n = new THREE.Projector;
	return function () {
		function r(r, o, a, s) {
			if (e.set(o, a, s), n.unprojectVector(e, t), r = i.pointMap[r], void 0 !== r)for (o = 0, a = r.length; a > o; o++)i.geometry.vertices[r[o]].copy(e)
		}

		var i = this;
		t.projectionMatrix.copy(this.camera.projectionMatrix), r("c", 0, 0, -1), r("t", 0, 0, 1), r("n1", -1, -1, -1), r("n2", 1, -1, -1), r("n3", -1, 1, -1), r("n4", 1, 1, -1), r("f1", -1, -1, 1), r("f2", 1, -1, 1), r("f3", -1, 1, 1), r("f4", 1, 1, 1), r("u1", .7, 1.1, -1), r("u2", -.7, 1.1, -1), r("u3", 0, 2, -1), r("cf1", -1, 0, 1), r("cf2", 1, 0, 1), r("cf3", 0, -1, 1), r("cf4", 0, 1, 1), r("cn1", -1, 0, -1), r("cn2", 1, 0, -1), r("cn3", 0, -1, -1), r("cn4", 0, 1, -1), this.geometry.verticesNeedUpdate = !0
	}
}(), THREE.DirectionalLightHelper = function (e, t) {
	THREE.Object3D.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrixWorld = e.matrixWorld, this.matrixAutoUpdate = !1, t = t || 1;
	var n = new THREE.Geometry;
	n.vertices.push(new THREE.Vector3(-t, t, 0), new THREE.Vector3(t, t, 0), new THREE.Vector3(t, -t, 0), new THREE.Vector3(-t, -t, 0), new THREE.Vector3(-t, t, 0));
	var r = new THREE.LineBasicMaterial({fog: !1});
	r.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.lightPlane = new THREE.Line(n, r), this.add(this.lightPlane), n = new THREE.Geometry, n.vertices.push(new THREE.Vector3, new THREE.Vector3), r = new THREE.LineBasicMaterial({fog: !1}), r.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.targetLine = new THREE.Line(n, r), this.add(this.targetLine), this.update()
}, THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.DirectionalLightHelper.prototype.dispose = function () {
	this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
}, THREE.DirectionalLightHelper.prototype.update = function () {
	var e = new THREE.Vector3, t = new THREE.Vector3, n = new THREE.Vector3;
	return function () {
		e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), n.subVectors(t, e), this.lightPlane.lookAt(n), this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.targetLine.geometry.vertices[1].copy(n), this.targetLine.geometry.verticesNeedUpdate = !0, this.targetLine.material.color.copy(this.lightPlane.material.color)
	}
}(), THREE.EdgesHelper = function (e, t) {
	var n = void 0 !== t ? t : 16777215, r = [0, 0], i = {}, o = function (e, t) {
		return e - t
	}, a = ["a", "b", "c"], s = new THREE.BufferGeometry, l = e.geometry.clone();
	l.mergeVertices(), l.computeFaceNormals();
	for (var u = l.vertices, l = l.faces, c = 0, h = 0, f = l.length; f > h; h++)for (var d = l[h], p = 0; 3 > p; p++) {
		r[0] = d[a[p]], r[1] = d[a[(p + 1) % 3]], r.sort(o);
		var m = r.toString();
		void 0 === i[m] ? (i[m] = {vert1: r[0], vert2: r[1], face1: h, face2: void 0}, c++) : i[m].face2 = h
	}
	s.addAttribute("position", new THREE.Float32Attribute(6 * c, 3)), r = s.attributes.position.array, o = 0;
	for (m in i)a = i[m], (void 0 === a.face2 || .9999 > l[a.face1].normal.dot(l[a.face2].normal)) && (c = u[a.vert1], r[o++] = c.x, r[o++] = c.y, r[o++] = c.z, c = u[a.vert2], r[o++] = c.x, r[o++] = c.y, r[o++] = c.z);
	THREE.Line.call(this, s, new THREE.LineBasicMaterial({color: n}), THREE.LinePieces), this.matrixAutoUpdate = !1, this.matrixWorld = e.matrixWorld
}, THREE.EdgesHelper.prototype = Object.create(THREE.Line.prototype), THREE.FaceNormalsHelper = function (e, t, n, r) {
	this.object = e, this.size = void 0 !== t ? t : 1, e = void 0 !== n ? n : 16776960, r = void 0 !== r ? r : 1, t = new THREE.Geometry, n = 0;
	for (var i = this.object.geometry.faces.length; i > n; n++)t.vertices.push(new THREE.Vector3, new THREE.Vector3);
	THREE.Line.call(this, t, new THREE.LineBasicMaterial({color: e, linewidth: r}), THREE.LinePieces), this.matrixAutoUpdate = !1, this.normalMatrix = new THREE.Matrix3, this.update()
}, THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype), THREE.FaceNormalsHelper.prototype.update = function () {
	var e = this.geometry.vertices, t = this.object, n = t.geometry.vertices, r = t.geometry.faces, i = t.matrixWorld;
	t.updateMatrixWorld(!0), this.normalMatrix.getNormalMatrix(i);
	for (var o = t = 0, a = r.length; a > t; t++, o += 2) {
		var s = r[t];
		e[o].copy(n[s.a]).add(n[s.b]).add(n[s.c]).divideScalar(3).applyMatrix4(i), e[o + 1].copy(s.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size).add(e[o])
	}
	return this.geometry.verticesNeedUpdate = !0, this
}, THREE.GridHelper = function (e, t) {
	var n = new THREE.Geometry, r = new THREE.LineBasicMaterial({vertexColors: THREE.VertexColors});
	this.color1 = new THREE.Color(4473924), this.color2 = new THREE.Color(8947848);
	for (var i = -e; e >= i; i += t) {
		n.vertices.push(new THREE.Vector3(-e, 0, i), new THREE.Vector3(e, 0, i), new THREE.Vector3(i, 0, -e), new THREE.Vector3(i, 0, e));
		var o = 0 === i ? this.color1 : this.color2;
		n.colors.push(o, o, o, o)
	}
	THREE.Line.call(this, n, r, THREE.LinePieces)
}, THREE.GridHelper.prototype = Object.create(THREE.Line.prototype), THREE.GridHelper.prototype.setColors = function (e, t) {
	this.color1.set(e), this.color2.set(t), this.geometry.colorsNeedUpdate = !0
}, THREE.HemisphereLightHelper = function (e, t) {
	for (THREE.Object3D.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrixWorld = e.matrixWorld, this.matrixAutoUpdate = !1, this.colors = [new THREE.Color, new THREE.Color], e = new THREE.SphereGeometry(t, 4, 2), e.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2)), t = 0; 8 > t; t++)e.faces[t].color = this.colors[4 > t ? 0 : 1];
	t = new THREE.MeshBasicMaterial({vertexColors: THREE.FaceColors, wireframe: !0}), this.lightSphere = new THREE.Mesh(e, t), this.add(this.lightSphere), this.update()
}, THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.HemisphereLightHelper.prototype.dispose = function () {
	this.lightSphere.geometry.dispose(), this.lightSphere.material.dispose()
}, THREE.HemisphereLightHelper.prototype.update = function () {
	var e = new THREE.Vector3;
	return function () {
		this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity), this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity), this.lightSphere.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate()), this.lightSphere.geometry.colorsNeedUpdate = !0
	}
}(), THREE.PointLightHelper = function (e, t) {
	this.light = e, this.light.updateMatrixWorld();
	var n = new THREE.SphereGeometry(t, 4, 2), r = new THREE.MeshBasicMaterial({wireframe: !0, fog: !1});
	r.color.copy(this.light.color).multiplyScalar(this.light.intensity), THREE.Mesh.call(this, n, r), this.matrixWorld = this.light.matrixWorld, this.matrixAutoUpdate = !1
}, THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype), THREE.PointLightHelper.prototype.dispose = function () {
	this.geometry.dispose(), this.material.dispose()
}, THREE.PointLightHelper.prototype.update = function () {
	this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
}, THREE.SkeletonHelper = function (e) {
	this.bones = this.getBoneList(e);
	for (var t = new THREE.Geometry, n = 0; n < this.bones.length; n++)this.bones[n].parent instanceof THREE.Bone && (t.vertices.push(new THREE.Vector3), t.vertices.push(new THREE.Vector3), t.colors.push(new THREE.Color(0, 0, 1)), t.colors.push(new THREE.Color(0, 1, 0)));
	n = new THREE.LineBasicMaterial({vertexColors: THREE.VertexColors, depthTest: !1, depthWrite: !1, transparent: !0}), THREE.Line.call(this, t, n, THREE.LinePieces), this.root = e, this.matrixWorld = e.matrixWorld, this.matrixAutoUpdate = !1, this.update()
}, THREE.SkeletonHelper.prototype = Object.create(THREE.Line.prototype), THREE.SkeletonHelper.prototype.getBoneList = function (e) {
	var t = [];
	e instanceof THREE.Bone && t.push(e);
	for (var n = 0; n < e.children.length; n++)t.push.apply(t, this.getBoneList(e.children[n]));
	return t
}, THREE.SkeletonHelper.prototype.update = function () {
	for (var e = this.geometry, t = (new THREE.Matrix4).getInverse(this.root.matrixWorld), n = new THREE.Matrix4, r = 0, i = 0; i < this.bones.length; i++) {
		var o = this.bones[i];
		o.parent instanceof THREE.Bone && (n.multiplyMatrices(t, o.matrixWorld), e.vertices[r].setFromMatrixPosition(n), n.multiplyMatrices(t, o.parent.matrixWorld), e.vertices[r + 1].setFromMatrixPosition(n), r += 2)
	}
	e.verticesNeedUpdate = !0, e.computeBoundingSphere()
}, THREE.SpotLightHelper = function (e) {
	THREE.Object3D.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrixWorld = e.matrixWorld, this.matrixAutoUpdate = !1, e = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0), e.applyMatrix((new THREE.Matrix4).makeTranslation(0, -.5, 0)), e.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2));
	var t = new THREE.MeshBasicMaterial({wireframe: !0, fog: !1});
	this.cone = new THREE.Mesh(e, t), this.add(this.cone), this.update()
}, THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.SpotLightHelper.prototype.dispose = function () {
	this.cone.geometry.dispose(), this.cone.material.dispose()
}, THREE.SpotLightHelper.prototype.update = function () {
	var e = new THREE.Vector3, t = new THREE.Vector3;
	return function () {
		var n = this.light.distance ? this.light.distance : 1e4, r = n * Math.tan(this.light.angle);
		this.cone.scale.set(r, r, n), e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(t.sub(e)), this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
	}
}(), THREE.VertexNormalsHelper = function (e, t, n, r) {
	this.object = e, this.size = void 0 !== t ? t : 1, t = void 0 !== n ? n : 16711680, r = void 0 !== r ? r : 1, n = new THREE.Geometry, e = e.geometry.faces;
	for (var i = 0, o = e.length; o > i; i++)for (var a = 0, s = e[i].vertexNormals.length; s > a; a++)n.vertices.push(new THREE.Vector3, new THREE.Vector3);
	THREE.Line.call(this, n, new THREE.LineBasicMaterial({color: t, linewidth: r}), THREE.LinePieces), this.matrixAutoUpdate = !1, this.normalMatrix = new THREE.Matrix3, this.update()
}, THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype), THREE.VertexNormalsHelper.prototype.update = function () {
	var e = new THREE.Vector3;
	return function (t) {
		t = ["a", "b", "c", "d"], this.object.updateMatrixWorld(!0), this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
		for (var n = this.geometry.vertices, r = this.object.geometry.vertices, i = this.object.geometry.faces, o = this.object.matrixWorld, a = 0, s = 0, l = i.length; l > s; s++)for (var u = i[s], c = 0, h = u.vertexNormals.length; h > c; c++) {
			var f = u.vertexNormals[c];
			n[a].copy(r[u[t[c]]]).applyMatrix4(o), e.copy(f).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size), e.add(n[a]), a += 1, n[a].copy(e), a += 1
		}
		return this.geometry.verticesNeedUpdate = !0, this
	}
}(), THREE.VertexTangentsHelper = function (e, t, n, r) {
	this.object = e, this.size = void 0 !== t ? t : 1, t = void 0 !== n ? n : 255, r = void 0 !== r ? r : 1, n = new THREE.Geometry, e = e.geometry.faces;
	for (var i = 0, o = e.length; o > i; i++)for (var a = 0, s = e[i].vertexTangents.length; s > a; a++)n.vertices.push(new THREE.Vector3), n.vertices.push(new THREE.Vector3);
	THREE.Line.call(this, n, new THREE.LineBasicMaterial({color: t, linewidth: r}), THREE.LinePieces), this.matrixAutoUpdate = !1, this.update()
}, THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype), THREE.VertexTangentsHelper.prototype.update = function () {
	var e = new THREE.Vector3;
	return function (t) {
		t = ["a", "b", "c", "d"], this.object.updateMatrixWorld(!0);
		for (var n = this.geometry.vertices, r = this.object.geometry.vertices, i = this.object.geometry.faces, o = this.object.matrixWorld, a = 0, s = 0, l = i.length; l > s; s++)for (var u = i[s], c = 0, h = u.vertexTangents.length; h > c; c++) {
			var f = u.vertexTangents[c];
			n[a].copy(r[u[t[c]]]).applyMatrix4(o), e.copy(f).transformDirection(o).multiplyScalar(this.size), e.add(n[a]), a += 1, n[a].copy(e), a += 1
		}
		return this.geometry.verticesNeedUpdate = !0, this
	}
}(), THREE.WireframeHelper = function (e, t) {
	var n = void 0 !== t ? t : 16777215, r = [0, 0], i = {}, o = function (e, t) {
		return e - t
	}, a = ["a", "b", "c"], s = new THREE.BufferGeometry;
	if (e.geometry instanceof THREE.Geometry) {
		for (var l = e.geometry.vertices, u = e.geometry.faces, c = 0, h = new Uint32Array(6 * u.length), f = 0, d = u.length; d > f; f++)for (var p = u[f], m = 0; 3 > m; m++) {
			r[0] = p[a[m]], r[1] = p[a[(m + 1) % 3]], r.sort(o);
			var g = r.toString();
			void 0 === i[g] && (h[2 * c] = r[0], h[2 * c + 1] = r[1], i[g] = !0, c++)
		}
		for (r = new Float32Array(6 * c), f = 0, d = c; d > f; f++)for (m = 0; 2 > m; m++)c = l[h[2 * f + m]], a = 6 * f + 3 * m, r[a + 0] = c.x, r[a + 1] = c.y, r[a + 2] = c.z;
		s.addAttribute("position", new THREE.BufferAttribute(r, 3))
	} else if (e.geometry instanceof THREE.BufferGeometry) {
		if (void 0 !== e.geometry.attributes.index) {
			for (var l = e.geometry.attributes.position.array, d = e.geometry.attributes.index.array, u = e.geometry.offsets, c = 0, h = new Uint32Array(2 * d.length), p = 0, E = u.length; E > p; ++p)for (var m = u[p].start, g = u[p].count, a = u[p].index, f = m, v = m + g; v > f; f += 3)for (m = 0; 3 > m; m++)r[0] = a + d[f + m], r[1] = a + d[f + (m + 1) % 3], r.sort(o), g = r.toString(), void 0 === i[g] && (h[2 * c] = r[0], h[2 * c + 1] = r[1], i[g] = !0, c++);
			for (r = new Float32Array(6 * c), f = 0, d = c; d > f; f++)for (m = 0; 2 > m; m++)a = 6 * f + 3 * m, c = 3 * h[2 * f + m], r[a + 0] = l[c], r[a + 1] = l[c + 1], r[a + 2] = l[c + 2]
		} else for (l = e.geometry.attributes.position.array, c = l.length / 3, h = c / 3, r = new Float32Array(6 * c), f = 0, d = h; d > f; f++)for (m = 0; 3 > m; m++)a = 18 * f + 6 * m, h = 9 * f + 3 * m, r[a + 0] = l[h], r[a + 1] = l[h + 1], r[a + 2] = l[h + 2], c = 9 * f + (m + 1) % 3 * 3, r[a + 3] = l[c], r[a + 4] = l[c + 1], r[a + 5] = l[c + 2];
		s.addAttribute("position", new THREE.BufferAttribute(r, 3))
	}
	THREE.Line.call(this, s, new THREE.LineBasicMaterial({color: n}), THREE.LinePieces), this.matrixAutoUpdate = !1, this.matrixWorld = e.matrixWorld
}, THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype), THREE.ImmediateRenderObject = function () {
	THREE.Object3D.call(this), this.render = function () {
	}
}, THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype), THREE.LensFlare = function (e, t, n, r, i) {
	THREE.Object3D.call(this), this.lensFlares = [], this.positionScreen = new THREE.Vector3, this.customUpdateCallback = void 0, void 0 !== e && this.add(e, t, n, r, i)
}, THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype), THREE.LensFlare.prototype.add = function (e, t, n, r, i, o) {
	void 0 === t && (t = -1), void 0 === n && (n = 0), void 0 === o && (o = 1), void 0 === i && (i = new THREE.Color(16777215)), void 0 === r && (r = THREE.NormalBlending), n = Math.min(n, Math.max(0, n)), this.lensFlares.push({texture: e, size: t, distance: n, x: 0, y: 0, z: 0, scale: 1, rotation: 1, opacity: o, color: i, blending: r})
}, THREE.LensFlare.prototype.updateLensFlares = function () {
	var e, t, n = this.lensFlares.length, r = 2 * -this.positionScreen.x, i = 2 * -this.positionScreen.y;
	for (e = 0; n > e; e++)t = this.lensFlares[e], t.x = this.positionScreen.x + r * t.distance, t.y = this.positionScreen.y + i * t.distance, t.wantedRotation = t.x * Math.PI * .25, t.rotation += .25 * (t.wantedRotation - t.rotation)
}, THREE.MorphBlendMesh = function (e, t) {
	THREE.Mesh.call(this, e, t), this.animationsMap = {}, this.animationsList = [];
	var n = this.geometry.morphTargets.length;
	this.createAnimation("__default", 0, n - 1, n / 1), this.setAnimationWeight("__default", 1)
}, THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.MorphBlendMesh.prototype.createAnimation = function (e, t, n, r) {
	t = {startFrame: t, endFrame: n, length: n - t + 1, fps: r, duration: (n - t) / r, lastFrame: 0, currentFrame: 0, active: !1, time: 0, direction: 1, weight: 1, directionBackwards: !1, mirroredLoop: !1}, this.animationsMap[e] = t, this.animationsList.push(t)
}, THREE.MorphBlendMesh.prototype.autoCreateAnimations = function (e) {
	for (var t, n = /([a-z]+)_?(\d+)/, r = {}, i = this.geometry, o = 0, a = i.morphTargets.length; a > o; o++) {
		var s = i.morphTargets[o].name.match(n);
		if (s && 1 < s.length) {
			var l = s[1];
			r[l] || (r[l] = {start: 1 / 0, end: -1 / 0}), s = r[l], o < s.start && (s.start = o), o > s.end && (s.end = o), t || (t = l)
		}
	}
	for (l in r)s = r[l], this.createAnimation(l, s.start, s.end, e);
	this.firstAnimation = t
}, THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function (e) {
	(e = this.animationsMap[e]) && (e.direction = 1, e.directionBackwards = !1)
}, THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function (e) {
	(e = this.animationsMap[e]) && (e.direction = -1, e.directionBackwards = !0)
}, THREE.MorphBlendMesh.prototype.setAnimationFPS = function (e, t) {
	var n = this.animationsMap[e];
	n && (n.fps = t, n.duration = (n.end - n.start) / n.fps)
}, THREE.MorphBlendMesh.prototype.setAnimationDuration = function (e, t) {
	var n = this.animationsMap[e];
	n && (n.duration = t, n.fps = (n.end - n.start) / n.duration)
}, THREE.MorphBlendMesh.prototype.setAnimationWeight = function (e, t) {
	var n = this.animationsMap[e];
	n && (n.weight = t)
}, THREE.MorphBlendMesh.prototype.setAnimationTime = function (e, t) {
	var n = this.animationsMap[e];
	n && (n.time = t)
}, THREE.MorphBlendMesh.prototype.getAnimationTime = function (e) {
	var t = 0;
	return(e = this.animationsMap[e]) && (t = e.time), t
}, THREE.MorphBlendMesh.prototype.getAnimationDuration = function (e) {
	var t = -1;
	return(e = this.animationsMap[e]) && (t = e.duration), t
}, THREE.MorphBlendMesh.prototype.playAnimation = function (e) {
	var t = this.animationsMap[e];
	t ? (t.time = 0, t.active = !0) : console.warn("animation[" + e + "] undefined")
}, THREE.MorphBlendMesh.prototype.stopAnimation = function (e) {
	(e = this.animationsMap[e]) && (e.active = !1)
}, THREE.MorphBlendMesh.prototype.update = function (e) {
	for (var t = 0, n = this.animationsList.length; n > t; t++) {
		var r = this.animationsList[t];
		if (r.active) {
			var i = r.duration / r.length;
			r.time += r.direction * e, r.mirroredLoop ? (r.time > r.duration || 0 > r.time) && (r.direction *= -1, r.time > r.duration && (r.time = r.duration, r.directionBackwards = !0), 0 > r.time && (r.time = 0, r.directionBackwards = !1)) : (r.time %= r.duration, 0 > r.time && (r.time += r.duration));
			var o = r.startFrame + THREE.Math.clamp(Math.floor(r.time / i), 0, r.length - 1), a = r.weight;
			o !== r.currentFrame && (this.morphTargetInfluences[r.lastFrame] = 0, this.morphTargetInfluences[r.currentFrame] = 1 * a, this.morphTargetInfluences[o] = 0, r.lastFrame = r.currentFrame, r.currentFrame = o), i = r.time % i / i, r.directionBackwards && (i = 1 - i), this.morphTargetInfluences[r.currentFrame] = i * a, this.morphTargetInfluences[r.lastFrame] = (1 - i) * a
		}
	}
}, THREE.LensFlarePlugin = function () {
	function e(e, n) {
		var r = t.createProgram(), i = t.createShader(t.FRAGMENT_SHADER), o = t.createShader(t.VERTEX_SHADER), a = "precision " + n + " float;\n";
		return t.shaderSource(i, a + e.fragmentShader), t.shaderSource(o, a + e.vertexShader), t.compileShader(i), t.compileShader(o), t.attachShader(r, i), t.attachShader(r, o), t.linkProgram(r), r
	}

	var t, n, r, i, o, a, s, l, u, c, h, f, d, p = [];
	this.init = function (p) {
		t = p.context, n = p, r = p.getPrecision(), i = new Float32Array(16), o = new Uint16Array(6), p = 0, i[p++] = -1, i[p++] = -1, i[p++] = 0, i[p++] = 0, i[p++] = 1, i[p++] = -1, i[p++] = 1, i[p++] = 0, i[p++] = 1, i[p++] = 1, i[p++] = 1, i[p++] = 1, i[p++] = -1, i[p++] = 1, i[p++] = 0, i[p++] = 1, p = 0, o[p++] = 0, o[p++] = 1, o[p++] = 2, o[p++] = 0, o[p++] = 2, o[p++] = 3, a = t.createBuffer(), s = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, a), t.bufferData(t.ARRAY_BUFFER, i, t.STATIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, s), t.bufferData(t.ELEMENT_ARRAY_BUFFER, o, t.STATIC_DRAW), l = t.createTexture(), u = t.createTexture(), t.bindTexture(t.TEXTURE_2D, l), t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 16, 16, 0, t.RGB, t.UNSIGNED_BYTE, null), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.bindTexture(t.TEXTURE_2D, u), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 16, 16, 0, t.RGBA, t.UNSIGNED_BYTE, null), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), 0 >= t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS) ? (c = !1, h = e(THREE.ShaderFlares.lensFlare, r)) : (c = !0, h = e(THREE.ShaderFlares.lensFlareVertexTexture, r)), f = {}, d = {}, f.vertex = t.getAttribLocation(h, "position"), f.uv = t.getAttribLocation(h, "uv"), d.renderType = t.getUniformLocation(h, "renderType"), d.map = t.getUniformLocation(h, "map"), d.occlusionMap = t.getUniformLocation(h, "occlusionMap"), d.opacity = t.getUniformLocation(h, "opacity"), d.color = t.getUniformLocation(h, "color"), d.scale = t.getUniformLocation(h, "scale"), d.rotation = t.getUniformLocation(h, "rotation"), d.screenPosition = t.getUniformLocation(h, "screenPosition")
	}, this.render = function (e, r, i, o) {
		if (p.length = 0, e.traverseVisible(function (e) {
			e instanceof THREE.LensFlare && p.push(e)
		}), 0 !== p.length) {
			e = new THREE.Vector3;
			var m = o / i, g = .5 * i, E = .5 * o, v = 16 / o, y = new THREE.Vector2(v * m, v), T = new THREE.Vector3(1, 1, 0), x = new THREE.Vector2(1, 1), R = d, v = f;
			t.useProgram(h), t.enableVertexAttribArray(f.vertex), t.enableVertexAttribArray(f.uv), t.uniform1i(R.occlusionMap, 0), t.uniform1i(R.map, 1), t.bindBuffer(t.ARRAY_BUFFER, a), t.vertexAttribPointer(v.vertex, 2, t.FLOAT, !1, 16, 0), t.vertexAttribPointer(v.uv, 2, t.FLOAT, !1, 16, 8), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, s), t.disable(t.CULL_FACE), t.depthMask(!1);
			for (var b = 0, _ = p.length; _ > b; b++) {
				v = 16 / o, y.set(v * m, v);
				var w = p[b];
				if (e.set(w.matrixWorld.elements[12], w.matrixWorld.elements[13], w.matrixWorld.elements[14]), e.applyMatrix4(r.matrixWorldInverse), e.applyProjection(r.projectionMatrix), T.copy(e), x.x = T.x * g + g, x.y = T.y * E + E, c || 0 < x.x && x.x < i && 0 < x.y && x.y < o) {
					t.activeTexture(t.TEXTURE1), t.bindTexture(t.TEXTURE_2D, l), t.copyTexImage2D(t.TEXTURE_2D, 0, t.RGB, x.x - 8, x.y - 8, 16, 16, 0), t.uniform1i(R.renderType, 0), t.uniform2f(R.scale, y.x, y.y), t.uniform3f(R.screenPosition, T.x, T.y, T.z), t.disable(t.BLEND), t.enable(t.DEPTH_TEST), t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, u), t.copyTexImage2D(t.TEXTURE_2D, 0, t.RGBA, x.x - 8, x.y - 8, 16, 16, 0), t.uniform1i(R.renderType, 1), t.disable(t.DEPTH_TEST), t.activeTexture(t.TEXTURE1), t.bindTexture(t.TEXTURE_2D, l), t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0), w.positionScreen.copy(T), w.customUpdateCallback ? w.customUpdateCallback(w) : w.updateLensFlares(), t.uniform1i(R.renderType, 2), t.enable(t.BLEND);
					for (var H = 0, M = w.lensFlares.length; M > H; H++) {
						var S = w.lensFlares[H];
						.001 < S.opacity && .001 < S.scale && (T.x = S.x, T.y = S.y, T.z = S.z, v = S.size * S.scale / o, y.x = v * m, y.y = v, t.uniform3f(R.screenPosition, T.x, T.y, T.z), t.uniform2f(R.scale, y.x, y.y), t.uniform1f(R.rotation, S.rotation), t.uniform1f(R.opacity, S.opacity), t.uniform3f(R.color, S.color.r, S.color.g, S.color.b), n.setBlending(S.blending, S.blendEquation, S.blendSrc, S.blendDst), n.setTexture(S.texture, 1), t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0))
					}
				}
			}
			t.enable(t.CULL_FACE), t.enable(t.DEPTH_TEST), t.depthMask(!0)
		}
	}
}, THREE.ShadowMapPlugin = function () {
	function e(t, n, r) {
		if (n.visible) {
			var i = t.__webglObjects[n.id];
			if (i && n.castShadow && (!1 === n.frustumCulled || !0 === s.intersectsObject(n)))for (var o = 0, a = i.length; a > o; o++) {
				var l = i[o];
				n._modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, n.matrixWorld), f.push(l)
			}
			for (o = 0, a = n.children.length; a > o; o++)e(t, n.children[o], r)
		}
	}

	var t, n, r, i, o, a, s = new THREE.Frustum, l = new THREE.Matrix4, u = new THREE.Vector3, c = new THREE.Vector3, h = new THREE.Vector3, f = [];
	this.init = function (e) {
		t = e.context, n = e, e = THREE.ShaderLib.depthRGBA;
		var s = THREE.UniformsUtils.clone(e.uniforms);
		r = new THREE.ShaderMaterial({fragmentShader: e.fragmentShader, vertexShader: e.vertexShader, uniforms: s}), i = new THREE.ShaderMaterial({fragmentShader: e.fragmentShader, vertexShader: e.vertexShader, uniforms: s, morphTargets: !0}), o = new THREE.ShaderMaterial({fragmentShader: e.fragmentShader, vertexShader: e.vertexShader, uniforms: s, skinning: !0}), a = new THREE.ShaderMaterial({fragmentShader: e.fragmentShader, vertexShader: e.vertexShader, uniforms: s, morphTargets: !0, skinning: !0}), r._shadowPass = !0, i._shadowPass = !0, o._shadowPass = !0, a._shadowPass = !0
	}, this.render = function (e, t) {
		n.shadowMapEnabled && n.shadowMapAutoUpdate && this.update(e, t)
	}, this.update = function (d, p) {
		var m, g, E, v, y, T, x, R, b = [];
		for (v = 0, t.clearColor(1, 1, 1, 1), t.disable(t.BLEND), t.enable(t.CULL_FACE), t.frontFace(t.CCW), t.cullFace(n.shadowMapCullFace === THREE.CullFaceFront ? t.FRONT : t.BACK), n.setDepthTest(!0), m = 0, g = d.__lights.length; g > m; m++)if (E = d.__lights[m], E.castShadow)if (E instanceof THREE.DirectionalLight && E.shadowCascade)for (y = 0; y < E.shadowCascadeCount; y++) {
			var _;
			if (E.shadowCascadeArray[y])_ = E.shadowCascadeArray[y]; else {
				x = E;
				var w = y;
				_ = new THREE.DirectionalLight, _.isVirtual = !0, _.onlyShadow = !0, _.castShadow = !0, _.shadowCameraNear = x.shadowCameraNear, _.shadowCameraFar = x.shadowCameraFar, _.shadowCameraLeft = x.shadowCameraLeft, _.shadowCameraRight = x.shadowCameraRight, _.shadowCameraBottom = x.shadowCameraBottom, _.shadowCameraTop = x.shadowCameraTop, _.shadowCameraVisible = x.shadowCameraVisible, _.shadowDarkness = x.shadowDarkness, _.shadowBias = x.shadowCascadeBias[w], _.shadowMapWidth = x.shadowCascadeWidth[w], _.shadowMapHeight = x.shadowCascadeHeight[w], _.pointsWorld = [], _.pointsFrustum = [], R = _.pointsWorld, T = _.pointsFrustum;
				for (var H = 0; 8 > H; H++)R[H] = new THREE.Vector3, T[H] = new THREE.Vector3;
				R = x.shadowCascadeNearZ[w], x = x.shadowCascadeFarZ[w], T[0].set(-1, -1, R), T[1].set(1, -1, R), T[2].set(-1, 1, R), T[3].set(1, 1, R), T[4].set(-1, -1, x), T[5].set(1, -1, x), T[6].set(-1, 1, x), T[7].set(1, 1, x), _.originalCamera = p, T = new THREE.Gyroscope, T.position.copy(E.shadowCascadeOffset), T.add(_), T.add(_.target), p.add(T), E.shadowCascadeArray[y] = _, console.log("Created virtualLight", _)
			}
			w = E, R = y, x = w.shadowCascadeArray[R], x.position.copy(w.position), x.target.position.copy(w.target.position), x.lookAt(x.target), x.shadowCameraVisible = w.shadowCameraVisible, x.shadowDarkness = w.shadowDarkness, x.shadowBias = w.shadowCascadeBias[R], T = w.shadowCascadeNearZ[R], w = w.shadowCascadeFarZ[R], x = x.pointsFrustum, x[0].z = T, x[1].z = T, x[2].z = T, x[3].z = T, x[4].z = w, x[5].z = w, x[6].z = w, x[7].z = w, b[v] = _, v++
		} else b[v] = E, v++;
		for (m = 0, g = b.length; g > m; m++) {
			if (E = b[m], E.shadowMap || (y = THREE.LinearFilter, n.shadowMapType === THREE.PCFSoftShadowMap && (y = THREE.NearestFilter), E.shadowMap = new THREE.WebGLRenderTarget(E.shadowMapWidth, E.shadowMapHeight, {minFilter: y, magFilter: y, format: THREE.RGBAFormat}), E.shadowMapSize = new THREE.Vector2(E.shadowMapWidth, E.shadowMapHeight), E.shadowMatrix = new THREE.Matrix4), !E.shadowCamera) {
				if (E instanceof THREE.SpotLight)E.shadowCamera = new THREE.PerspectiveCamera(E.shadowCameraFov, E.shadowMapWidth / E.shadowMapHeight, E.shadowCameraNear, E.shadowCameraFar); else {
					if (!(E instanceof THREE.DirectionalLight)) {
						console.error("Unsupported light type for shadow");
						continue
					}
					E.shadowCamera = new THREE.OrthographicCamera(E.shadowCameraLeft, E.shadowCameraRight, E.shadowCameraTop, E.shadowCameraBottom, E.shadowCameraNear, E.shadowCameraFar)
				}
				d.add(E.shadowCamera), !0 === d.autoUpdate && d.updateMatrixWorld()
			}
			if (E.shadowCameraVisible && !E.cameraHelper && (E.cameraHelper = new THREE.CameraHelper(E.shadowCamera), E.shadowCamera.add(E.cameraHelper)), E.isVirtual && _.originalCamera == p) {
				for (y = p, v = E.shadowCamera, T = E.pointsFrustum, x = E.pointsWorld, u.set(1 / 0, 1 / 0, 1 / 0), c.set(-1 / 0, -1 / 0, -1 / 0), w = 0; 8 > w; w++)R = x[w], R.copy(T[w]), THREE.ShadowMapPlugin.__projector.unprojectVector(R, y), R.applyMatrix4(v.matrixWorldInverse), R.x < u.x && (u.x = R.x), R.x > c.x && (c.x = R.x), R.y < u.y && (u.y = R.y), R.y > c.y && (c.y = R.y), R.z < u.z && (u.z = R.z), R.z > c.z && (c.z = R.z);
				v.left = u.x, v.right = c.x, v.top = c.y, v.bottom = u.y, v.updateProjectionMatrix()
			}
			for (v = E.shadowMap, T = E.shadowMatrix, y = E.shadowCamera, y.position.setFromMatrixPosition(E.matrixWorld), h.setFromMatrixPosition(E.target.matrixWorld), y.lookAt(h), y.updateMatrixWorld(), y.matrixWorldInverse.getInverse(y.matrixWorld), E.cameraHelper && (E.cameraHelper.visible = E.shadowCameraVisible), E.shadowCameraVisible && E.cameraHelper.update(), T.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), T.multiply(y.projectionMatrix), T.multiply(y.matrixWorldInverse), l.multiplyMatrices(y.projectionMatrix, y.matrixWorldInverse), s.setFromMatrix(l), n.setRenderTarget(v), n.clear(), f.length = 0, e(d, d, y), E = 0, v = f.length; v > E; E++)x = f[E], T = x.object, x = x.buffer, w = T.material instanceof THREE.MeshFaceMaterial ? T.material.materials[0] : T.material, R = void 0 !== T.geometry.morphTargets && 0 < T.geometry.morphTargets.length && w.morphTargets, H = T instanceof THREE.SkinnedMesh && w.skinning, R = T.customDepthMaterial ? T.customDepthMaterial : H ? R ? a : o : R ? i : r, n.setMaterialFaces(w), x instanceof THREE.BufferGeometry ? n.renderBufferDirect(y, d.__lights, null, R, x, T) : n.renderBuffer(y, d.__lights, null, R, x, T);
			for (w = d.__webglObjectsImmediate, E = 0, v = w.length; v > E; E++)x = w[E], T = x.object, T.visible && T.castShadow && (T._modelViewMatrix.multiplyMatrices(y.matrixWorldInverse, T.matrixWorld), n.renderImmediateObject(y, d.__lights, null, r, T))
		}
		m = n.getClearColor(), g = n.getClearAlpha(), t.clearColor(m.r, m.g, m.b, g), t.enable(t.BLEND), n.shadowMapCullFace === THREE.CullFaceFront && t.cullFace(t.BACK)
	}
}, THREE.ShadowMapPlugin.__projector = new THREE.Projector, THREE.SpritePlugin = function () {
	function e(e, t) {
		return e.z !== t.z ? t.z - e.z : t.id - e.id
	}

	var t, n, r, i, o, a, s, l, u, c, h, f, d, p, m, g, E, v, y, T, x, R, b, _, w, H = [];
	this.init = function (e) {
		v = e.context, y = e, x = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]), R = new Uint16Array([0, 1, 2, 0, 2, 3]), b = v.createBuffer(), _ = v.createBuffer(), v.bindBuffer(v.ARRAY_BUFFER, b), v.bufferData(v.ARRAY_BUFFER, x, v.STATIC_DRAW), v.bindBuffer(v.ELEMENT_ARRAY_BUFFER, _), v.bufferData(v.ELEMENT_ARRAY_BUFFER, R, v.STATIC_DRAW), e = v.createProgram();
		var H = v.createShader(v.VERTEX_SHADER), M = v.createShader(v.FRAGMENT_SHADER);
		v.shaderSource(H, ["precision " + y.getPrecision() + " float;", "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}"].join("\n")), v.shaderSource(M, ["precision " + y.getPrecision() + " float;", "uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}"].join("\n")), v.compileShader(H), v.compileShader(M), v.attachShader(e, H), v.attachShader(e, M), v.linkProgram(e), w = e, g = v.getAttribLocation(w, "position"), E = v.getAttribLocation(w, "uv"), t = v.getUniformLocation(w, "uvOffset"), n = v.getUniformLocation(w, "uvScale"), r = v.getUniformLocation(w, "rotation"), i = v.getUniformLocation(w, "scale"), o = v.getUniformLocation(w, "color"), a = v.getUniformLocation(w, "map"), s = v.getUniformLocation(w, "opacity"), l = v.getUniformLocation(w, "modelViewMatrix"), u = v.getUniformLocation(w, "projectionMatrix"), c = v.getUniformLocation(w, "fogType"), h = v.getUniformLocation(w, "fogDensity"), f = v.getUniformLocation(w, "fogNear"), d = v.getUniformLocation(w, "fogFar"), p = v.getUniformLocation(w, "fogColor"), m = v.getUniformLocation(w, "alphaTest"), e = document.createElement("canvas"), e.width = 8, e.height = 8, H = e.getContext("2d"), H.fillStyle = "white", H.fillRect(0, 0, 8, 8), T = new THREE.Texture(e), T.needsUpdate = !0
	}, this.render = function (x, R, M, S) {
		if (H.length = 0, x.traverseVisible(function (e) {
			e instanceof THREE.Sprite && H.push(e)
		}), 0 !== H.length) {
			v.useProgram(w), v.enableVertexAttribArray(g), v.enableVertexAttribArray(E), v.disable(v.CULL_FACE), v.enable(v.BLEND), v.bindBuffer(v.ARRAY_BUFFER, b), v.vertexAttribPointer(g, 2, v.FLOAT, !1, 16, 0), v.vertexAttribPointer(E, 2, v.FLOAT, !1, 16, 8), v.bindBuffer(v.ELEMENT_ARRAY_BUFFER, _), v.uniformMatrix4fv(u, !1, R.projectionMatrix.elements), v.activeTexture(v.TEXTURE0), v.uniform1i(a, 0), S = M = 0;
			var C = x.fog;
			C ? (v.uniform3f(p, C.color.r, C.color.g, C.color.b), C instanceof THREE.Fog ? (v.uniform1f(f, C.near), v.uniform1f(d, C.far), v.uniform1i(c, 1), S = M = 1) : C instanceof THREE.FogExp2 && (v.uniform1f(h, C.density), v.uniform1i(c, 2), S = M = 2)) : (v.uniform1i(c, 0), S = M = 0);
			for (var C = 0, A = H.length; A > C; C++) {
				var L = H[C], k = L.material;
				L._modelViewMatrix.multiplyMatrices(R.matrixWorldInverse, L.matrixWorld), L.z = -L._modelViewMatrix.elements[14]
			}
			for (H.sort(e), R = [], C = 0, A = H.length; A > C; C++)L = H[C], k = L.material, v.uniform1f(m, k.alphaTest), v.uniformMatrix4fv(l, !1, L._modelViewMatrix.elements), R[0] = L.scale.x, R[1] = L.scale.y, L = 0, x.fog && k.fog && (L = S), M !== L && (v.uniform1i(c, L), M = L), null !== k.map ? (v.uniform2f(t, k.map.offset.x, k.map.offset.y), v.uniform2f(n, k.map.repeat.x, k.map.repeat.y)) : (v.uniform2f(t, 0, 0), v.uniform2f(n, 1, 1)), v.uniform1f(s, k.opacity), v.uniform3f(o, k.color.r, k.color.g, k.color.b), v.uniform1f(r, k.rotation), v.uniform2fv(i, R), y.setBlending(k.blending, k.blendEquation, k.blendSrc, k.blendDst), y.setDepthTest(k.depthTest), y.setDepthWrite(k.depthWrite), k.map && k.map.image && k.map.image.width ? y.setTexture(k.map, 0) : y.setTexture(T, 0), v.drawElements(v.TRIANGLES, 6, v.UNSIGNED_SHORT, 0);
			v.enable(v.CULL_FACE)
		}
	}
}, THREE.DepthPassPlugin = function () {
	function e(t, n, r) {
		if (n.visible) {
			var i = t.__webglObjects[n.id];
			if (i && (!1 === n.frustumCulled || !0 === s.intersectsObject(n)))for (var o = 0, a = i.length; a > o; o++) {
				var l = i[o];
				n._modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, n.matrixWorld), u.push(l)
			}
			for (o = 0, a = n.children.length; a > o; o++)e(t, n.children[o], r)
		}
	}

	this.enabled = !1, this.renderTarget = null;
	var t, n, r, i, o, a, s = new THREE.Frustum, l = new THREE.Matrix4, u = [];
	this.init = function (e) {
		t = e.context, n = e, e = THREE.ShaderLib.depthRGBA;
		var s = THREE.UniformsUtils.clone(e.uniforms);
		r = new THREE.ShaderMaterial({fragmentShader: e.fragmentShader, vertexShader: e.vertexShader, uniforms: s}), i = new THREE.ShaderMaterial({fragmentShader: e.fragmentShader, vertexShader: e.vertexShader, uniforms: s, morphTargets: !0}), o = new THREE.ShaderMaterial({fragmentShader: e.fragmentShader, vertexShader: e.vertexShader, uniforms: s, skinning: !0}), a = new THREE.ShaderMaterial({fragmentShader: e.fragmentShader, vertexShader: e.vertexShader, uniforms: s, morphTargets: !0, skinning: !0}), r._shadowPass = !0, i._shadowPass = !0, o._shadowPass = !0, a._shadowPass = !0
	}, this.render = function (e, t) {
		this.enabled && this.update(e, t)
	}, this.update = function (c, h) {
		var f, d, p, m, g;
		t.clearColor(1, 1, 1, 1), t.disable(t.BLEND), n.setDepthTest(!0), !0 === c.autoUpdate && c.updateMatrixWorld(), h.matrixWorldInverse.getInverse(h.matrixWorld), l.multiplyMatrices(h.projectionMatrix, h.matrixWorldInverse), s.setFromMatrix(l), n.setRenderTarget(this.renderTarget), n.clear(), u.length = 0, e(c, c, h);
		var E;
		for (f = 0, d = u.length; d > f; f++)p = u[f], g = p.object, p = p.buffer, g instanceof THREE.PointCloud && !g.customDepthMaterial || ((E = g.material instanceof THREE.MeshFaceMaterial ? g.material.materials[0] : g.material) && n.setMaterialFaces(g.material), m = void 0 !== g.geometry.morphTargets && 0 < g.geometry.morphTargets.length && E.morphTargets, E = g instanceof THREE.SkinnedMesh && E.skinning, m = g.customDepthMaterial ? g.customDepthMaterial : E ? m ? a : o : m ? i : r, p instanceof THREE.BufferGeometry ? n.renderBufferDirect(h, c.__lights, null, m, p, g) : n.renderBuffer(h, c.__lights, null, m, p, g));
		for (m = c.__webglObjectsImmediate, f = 0, d = m.length; d > f; f++)p = m[f], g = p.object, g.visible && (g._modelViewMatrix.multiplyMatrices(h.matrixWorldInverse, g.matrixWorld), n.renderImmediateObject(h, c.__lights, null, r, g));
		f = n.getClearColor(), d = n.getClearAlpha(), t.clearColor(f.r, f.g, f.b, d), t.enable(t.BLEND)
	}
}, THREE.ShaderFlares = {lensFlareVertexTexture: {vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}", fragmentShader: "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"}, lensFlare: {vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}", fragmentShader: "precision mediump float;\nuniform lowp int renderType;\nuniform sampler2D map;\nuniform sampler2D occlusionMap;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\nvisibility = ( 1.0 - visibility / 4.0 );\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * visibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"}}, Detector = {canvas: !!window.CanvasRenderingContext2D, webgl: function () {
	try {
		return!!window.WebGLRenderingContext && !!document.createElement("canvas").getContext("experimental-webgl")
	} catch (e) {
		return!1
	}
}(), workers: !!window.Worker, fileapi: window.File && window.FileReader && window.FileList && window.Blob, getWebGLErrorMessage: function () {
	var e = document.createElement("div");
	return e.id = "webgl-error-message", e.style.fontFamily = "monospace", e.style.fontSize = "13px", e.style.fontWeight = "normal", e.style.textAlign = "center", e.style.background = "#fff", e.style.color = "#000", e.style.padding = "1.5em", e.style.width = "400px", e.style.margin = "5em auto 0", this.webgl || (e.innerHTML = window.WebGLRenderingContext ? ['Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br />', 'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'].join("\n") : ['Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br/>', 'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'].join("\n")), e
}, addGetWebGLMessage: function (e) {
	var t, n, r;
	e = e || {}, t = void 0 !== e.parent ? e.parent : document.body, n = void 0 !== e.id ? e.id : "oldie", r = Detector.getWebGLErrorMessage(), r.id = n, t.appendChild(r)
}};
var THREEx = THREEx || {};
THREEx.FullScreen = THREEx.FullScreen || {}, THREEx.FullScreen.available = function () {
	return this._hasWebkitFullScreen || this._hasMozFullScreen
}, THREEx.FullScreen.activated = function () {
	return this._hasWebkitFullScreen ? document.webkitIsFullScreen : this._hasMozFullScreen ? document.mozFullScreen : void console.assert(!1)
}, THREEx.FullScreen.request = function (e) {
	e = e || document.body, this._hasWebkitFullScreen ? e.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT) : this._hasMozFullScreen ? e.mozRequestFullScreen() : console.assert(!1)
}, THREEx.FullScreen.cancel = function () {
	this._hasWebkitFullScreen ? document.webkitCancelFullScreen() : this._hasMozFullScreen ? document.mozCancelFullScreen() : console.assert(!1)
}, THREEx.FullScreen._hasWebkitFullScreen = "webkitCancelFullScreen"in document ? !0 : !1, THREEx.FullScreen._hasMozFullScreen = "mozCancelFullScreen"in document ? !0 : !1, THREEx.FullScreen.bindKey = function (e) {
	e = e || {};
	var t = e.charCode || "f".charCodeAt(0), n = void 0 !== e.dblclick ? e.dblclick : !1, r = e.element, i = function () {
		THREEx.FullScreen.activated() ? THREEx.FullScreen.cancel() : THREEx.FullScreen.request(r)
	}, o = function (e) {
		e.which === t && i()
	}.bind(this);
	return document.addEventListener("keypress", o, !1), n && document.addEventListener("dblclick", i, !1), {unbind: function () {
		document.removeEventListener("keypress", o, !1), n && document.removeEventListener("dblclick", i, !1)
	}}
};
var THREEx = THREEx || {};
THREEx.WindowResize = function (e, t, n) {
	n = n || function () {
		return{width: window.innerWidth, height: window.innerHeight}
	};
	var r = function () {
		var r = n();
		e.setSize(r.width, r.height), t.aspect = r.width / r.height, t.updateProjectionMatrix()
	};
	return window.addEventListener("resize", r, !1), {trigger: function () {
		r()
	}, destroy: function () {
		window.removeEventListener("resize", r)
	}}
}, THREE.OrbitControls = function (e, t) {
	function n() {
		return 2 * Math.PI / 60 / 60 * c.autoRotateSpeed
	}

	function r() {
		return Math.pow(.95, c.userZoomSpeed)
	}

	function i(e) {
		c.enabled !== !1 && c.userRotate !== !1 && (e.preventDefault(), _ === b.NONE && (0 === e.button && (_ = b.ROTATE), 1 === e.button && (_ = b.ZOOM), 2 === e.button && (_ = b.PAN)), _ === b.ROTATE ? d.set(e.clientX, e.clientY) : _ === b.ZOOM ? g.set(e.clientX, e.clientY) : _ === b.PAN, document.addEventListener("mousemove", o, !1), document.addEventListener("mouseup", a, !1))
	}

	function o(e) {
		if (c.enabled !== !1)if (e.preventDefault(), _ === b.ROTATE)p.set(e.clientX, e.clientY), m.subVectors(p, d), c.rotateLeft(2 * Math.PI * m.x / f * c.userRotateSpeed), c.rotateUp(2 * Math.PI * m.y / f * c.userRotateSpeed), d.copy(p); else if (_ === b.ZOOM)E.set(e.clientX, e.clientY), v.subVectors(E, g), v.y > 0 ? c.zoomIn() : c.zoomOut(), g.copy(E); else if (_ === b.PAN) {
			var t = e.movementX || e.mozMovementX || e.webkitMovementX || 0, n = e.movementY || e.mozMovementY || e.webkitMovementY || 0;
			c.pan(new THREE.Vector3(-t, n, 0))
		}
	}

	function a() {
		c.enabled !== !1 && c.userRotate !== !1 && (document.removeEventListener("mousemove", o, !1), document.removeEventListener("mouseup", a, !1), _ = b.NONE)
	}

	function s(e) {
		if (c.enabled !== !1 && c.userZoom !== !1) {
			var t = 0;
			e.wheelDelta ? t = e.wheelDelta : e.detail && (t = -e.detail), t > 0 ? c.zoomOut() : c.zoomIn()
		}
	}

	function l(e) {
		if (c.enabled !== !1 && c.userPan !== !1)switch (e.keyCode) {
			case c.keys.ROTATE:
				_ = b.ROTATE;
				break;
			case c.keys.ZOOM:
				_ = b.ZOOM;
				break;
			case c.keys.PAN:
				_ = b.PAN
		}
	}

	function u(e) {
		switch (e.keyCode) {
			case c.keys.ROTATE:
			case c.keys.ZOOM:
			case c.keys.PAN:
				_ = b.NONE
		}
	}

	this.object = e, this.domElement = void 0 !== t ? t : document, this.enabled = !0, this.center = new THREE.Vector3, this.userZoom = !0, this.userZoomSpeed = 1, this.userRotate = !0, this.userRotateSpeed = 1, this.userPan = !0, this.userPanSpeed = 2, this.autoRotate = !1, this.autoRotateSpeed = 2, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minDistance = 0, this.maxDistance = 1 / 0, this.keys = {LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40, ROTATE: 65, ZOOM: 83, PAN: 68};
	var c = this, h = 1e-6, f = 1800, d = new THREE.Vector2, p = new THREE.Vector2, m = new THREE.Vector2, g = new THREE.Vector2, E = new THREE.Vector2, v = new THREE.Vector2, y = 0, T = 0, x = 1, R = new THREE.Vector3, b = {NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2}, _ = b.NONE, w = {type: "change"};
	this.rotateLeft = function (e) {
		void 0 === e && (e = n()), T -= e
	}, this.rotateRight = function (e) {
		void 0 === e && (e = n()), T += e
	}, this.rotateUp = function (e) {
		void 0 === e && (e = n()), y -= e
	}, this.rotateDown = function (e) {
		void 0 === e && (e = n()), y += e
	}, this.zoomIn = function (e) {
		void 0 === e && (e = r()), x /= e
	}, this.zoomOut = function (e) {
		void 0 === e && (e = r()), x *= e
	}, this.pan = function (e) {
		e.transformDirection(this.object.matrix), e.multiplyScalar(c.userPanSpeed), this.object.position.add(e), this.center.add(e)
	}, this.update = function () {
		var e = this.object.position, t = e.clone().sub(this.center), r = Math.atan2(t.x, t.z), i = Math.atan2(Math.sqrt(t.x * t.x + t.z * t.z), t.y);
		this.autoRotate && this.rotateLeft(n()), r += T, i += y, i = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, i)), i = Math.max(h, Math.min(Math.PI - h, i));
		var o = t.length() * x;
		o = Math.max(this.minDistance, Math.min(this.maxDistance, o)), t.x = o * Math.sin(i) * Math.sin(r), t.y = o * Math.cos(i), t.z = o * Math.sin(i) * Math.cos(r), e.copy(this.center).add(t), this.object.lookAt(this.center), T = 0, y = 0, x = 1, R.distanceTo(this.object.position) > 0 && (this.dispatchEvent(w), R.copy(this.object.position))
	}, this.domElement.addEventListener("contextmenu", function (e) {
		e.preventDefault()
	}, !1), this.domElement.addEventListener("mousedown", i, !1), this.domElement.addEventListener("mousewheel", s, !1), this.domElement.addEventListener("DOMMouseScroll", s, !1), window.addEventListener("keydown", l, !1), window.addEventListener("keyup", u, !1)
}, THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);
var dat = dat || {};
dat.gui = dat.gui || {}, dat.utils = dat.utils || {}, dat.controllers = dat.controllers || {}, dat.dom = dat.dom || {}, dat.color = dat.color || {}, dat.utils.css = function () {
	return{load: function (e, t) {
		t = t || document;
		var n = t.createElement("link");
		n.type = "text/css", n.rel = "stylesheet", n.href = e, t.getElementsByTagName("head")[0].appendChild(n)
	}, inject: function (e, t) {
		t = t || document;
		var n = document.createElement("style");
		n.type = "text/css", n.innerHTML = e, t.getElementsByTagName("head")[0].appendChild(n)
	}}
}(), dat.utils.common = function () {
	var e = Array.prototype.forEach, t = Array.prototype.slice;
	return{BREAK: {}, extend: function (e) {
		return this.each(t.call(arguments, 1), function (t) {
			for (var n in t)this.isUndefined(t[n]) || (e[n] = t[n])
		}, this), e
	}, defaults: function (e) {
		return this.each(t.call(arguments, 1), function (t) {
			for (var n in t)this.isUndefined(e[n]) && (e[n] = t[n])
		}, this), e
	}, compose: function () {
		var e = t.call(arguments);
		return function () {
			for (var n = t.call(arguments), r = e.length - 1; r >= 0; r--)n = [e[r].apply(this, n)];
			return n[0]
		}
	}, each: function (t, n, r) {
		if (e && t.forEach === e)t.forEach(n, r); else if (t.length === t.length + 0)for (var i = 0, o = t.length; o > i && !(i in t && n.call(r, t[i], i) === this.BREAK); i++); else for (i in t)if (n.call(r, t[i], i) === this.BREAK)break
	}, defer: function (e) {
		setTimeout(e, 0)
	}, toArray: function (e) {
		return e.toArray ? e.toArray() : t.call(e)
	}, isUndefined: function (e) {
		return void 0 === e
	}, isNull: function (e) {
		return null === e
	}, isNaN: function (e) {
		return e !== e
	}, isArray: Array.isArray || function (e) {
		return e.constructor === Array
	}, isObject: function (e) {
		return e === Object(e)
	}, isNumber: function (e) {
		return e === e + 0
	}, isString: function (e) {
		return e === e + ""
	}, isBoolean: function (e) {
		return!1 === e || !0 === e
	}, isFunction: function (e) {
		return"[object Function]" === Object.prototype.toString.call(e)
	}}
}(), dat.controllers.Controller = function (e) {
	var t = function (e, t) {
		this.initialValue = e[t], this.domElement = document.createElement("div"), this.object = e, this.property = t, this.__onFinishChange = this.__onChange = void 0
	};
	return e.extend(t.prototype, {onChange: function (e) {
		return this.__onChange = e, this
	}, onFinishChange: function (e) {
		return this.__onFinishChange = e, this
	}, setValue: function (e) {
		return this.object[this.property] = e, this.__onChange && this.__onChange.call(this, e), this.updateDisplay(), this
	}, getValue: function () {
		return this.object[this.property]
	}, updateDisplay: function () {
		return this
	}, isModified: function () {
		return this.initialValue !== this.getValue()
	}}), t
}(dat.utils.common), dat.dom.dom = function (e) {
	function t(t) {
		return"0" === t || e.isUndefined(t) ? 0 : (t = t.match(r), e.isNull(t) ? 0 : parseFloat(t[1]))
	}

	var n = {};
	e.each({HTMLEvents: ["change"], MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"], KeyboardEvents: ["keydown"]}, function (t, r) {
		e.each(t, function (e) {
			n[e] = r
		})
	});
	var r = /(\d+(\.\d+)?)px/, i = {makeSelectable: function (e, t) {
		void 0 !== e && void 0 !== e.style && (e.onselectstart = t ? function () {
			return!1
		} : function () {
		}, e.style.MozUserSelect = t ? "auto" : "none", e.style.KhtmlUserSelect = t ? "auto" : "none", e.unselectable = t ? "on" : "off")
	}, makeFullscreen: function (t, n, r) {
		e.isUndefined(n) && (n = !0), e.isUndefined(r) && (r = !0), t.style.position = "absolute", n && (t.style.left = 0, t.style.right = 0), r && (t.style.top = 0, t.style.bottom = 0)
	}, fakeEvent: function (t, r, i, o) {
		i = i || {};
		var a = n[r];
		if (!a)throw Error("Event type " + r + " not supported.");
		var s = document.createEvent(a);
		switch (a) {
			case"MouseEvents":
				s.initMouseEvent(r, i.bubbles || !1, i.cancelable || !0, window, i.clickCount || 1, 0, 0, i.x || i.clientX || 0, i.y || i.clientY || 0, !1, !1, !1, !1, 0, null);
				break;
			case"KeyboardEvents":
				a = s.initKeyboardEvent || s.initKeyEvent, e.defaults(i, {cancelable: !0, ctrlKey: !1, altKey: !1, shiftKey: !1, metaKey: !1, keyCode: void 0, charCode: void 0}), a(r, i.bubbles || !1, i.cancelable, window, i.ctrlKey, i.altKey, i.shiftKey, i.metaKey, i.keyCode, i.charCode);
				break;
			default:
				s.initEvent(r, i.bubbles || !1, i.cancelable || !0)
		}
		e.defaults(s, o), t.dispatchEvent(s)
	}, bind: function (e, t, n, r) {
		return e.addEventListener ? e.addEventListener(t, n, r || !1) : e.attachEvent && e.attachEvent("on" + t, n), i
	}, unbind: function (e, t, n, r) {
		return e.removeEventListener ? e.removeEventListener(t, n, r || !1) : e.detachEvent && e.detachEvent("on" + t, n), i
	}, addClass: function (e, t) {
		if (void 0 === e.className)e.className = t; else if (e.className !== t) {
			var n = e.className.split(/ +/);
			-1 == n.indexOf(t) && (n.push(t), e.className = n.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""))
		}
		return i
	}, removeClass: function (e, t) {
		if (t) {
			if (void 0 !== e.className)if (e.className === t)e.removeAttribute("class"); else {
				var n = e.className.split(/ +/), r = n.indexOf(t);
				-1 != r && (n.splice(r, 1), e.className = n.join(" "))
			}
		} else e.className = void 0;
		return i
	}, hasClass: function (e, t) {
		return RegExp("(?:^|\\s+)" + t + "(?:\\s+|$)").test(e.className) || !1
	}, getWidth: function (e) {
		return e = getComputedStyle(e), t(e["border-left-width"]) + t(e["border-right-width"]) + t(e["padding-left"]) + t(e["padding-right"]) + t(e.width)
	}, getHeight: function (e) {
		return e = getComputedStyle(e), t(e["border-top-width"]) + t(e["border-bottom-width"]) + t(e["padding-top"]) + t(e["padding-bottom"]) + t(e.height)
	}, getOffset: function (e) {
		var t = {left: 0, top: 0};
		if (e.offsetParent)do t.left += e.offsetLeft, t.top += e.offsetTop; while (e = e.offsetParent);
		return t
	}, isActive: function (e) {
		return e === document.activeElement && (e.type || e.href)
	}};
	return i
}(dat.utils.common), dat.controllers.OptionController = function (e, t, n) {
	var r = function (e, i, o) {
		r.superclass.call(this, e, i);
		var a = this;
		if (this.__select = document.createElement("select"), n.isArray(o)) {
			var s = {};
			n.each(o, function (e) {
				s[e] = e
			}), o = s
		}
		n.each(o, function (e, t) {
			var n = document.createElement("option");
			n.innerHTML = t, n.setAttribute("value", e), a.__select.appendChild(n)
		}), this.updateDisplay(), t.bind(this.__select, "change", function () {
			a.setValue(this.options[this.selectedIndex].value)
		}), this.domElement.appendChild(this.__select)
	};
	return r.superclass = e, n.extend(r.prototype, e.prototype, {setValue: function (e) {
		return e = r.superclass.prototype.setValue.call(this, e), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), e
	}, updateDisplay: function () {
		return this.__select.value = this.getValue(), r.superclass.prototype.updateDisplay.call(this)
	}}), r
}(dat.controllers.Controller, dat.dom.dom, dat.utils.common), dat.controllers.NumberController = function (e, t) {
	var n = function (e, r, i) {
		n.superclass.call(this, e, r), i = i || {}, this.__min = i.min, this.__max = i.max, this.__step = i.step, this.__impliedStep = t.isUndefined(this.__step) ? 0 == this.initialValue ? 1 : Math.pow(10, Math.floor(Math.log(this.initialValue) / Math.LN10)) / 10 : this.__step, e = this.__impliedStep, e = e.toString(), e = -1 < e.indexOf(".") ? e.length - e.indexOf(".") - 1 : 0, this.__precision = e
	};
	return n.superclass = e, t.extend(n.prototype, e.prototype, {setValue: function (e) {
		return void 0 !== this.__min && e < this.__min ? e = this.__min : void 0 !== this.__max && e > this.__max && (e = this.__max), void 0 !== this.__step && 0 != e % this.__step && (e = Math.round(e / this.__step) * this.__step), n.superclass.prototype.setValue.call(this, e)
	}, min: function (e) {
		return this.__min = e, this
	}, max: function (e) {
		return this.__max = e, this
	}, step: function (e) {
		return this.__step = e, this
	}}), n
}(dat.controllers.Controller, dat.utils.common), dat.controllers.NumberControllerBox = function (e, t, n) {
	var r = function (e, i, o) {
		function a() {
			var e = parseFloat(c.__input.value);
			n.isNaN(e) || c.setValue(e)
		}

		function s(e) {
			var t = u - e.clientY;
			c.setValue(c.getValue() + t * c.__impliedStep), u = e.clientY
		}

		function l() {
			t.unbind(window, "mousemove", s), t.unbind(window, "mouseup", l)
		}

		this.__truncationSuspended = !1, r.superclass.call(this, e, i, o);
		var u, c = this;
		this.__input = document.createElement("input"), this.__input.setAttribute("type", "text"), t.bind(this.__input, "change", a), t.bind(this.__input, "blur", function () {
			a(), c.__onFinishChange && c.__onFinishChange.call(c, c.getValue())
		}), t.bind(this.__input, "mousedown", function (e) {
			t.bind(window, "mousemove", s), t.bind(window, "mouseup", l), u = e.clientY
		}), t.bind(this.__input, "keydown", function (e) {
			13 === e.keyCode && (c.__truncationSuspended = !0, this.blur(), c.__truncationSuspended = !1)
		}), this.updateDisplay(), this.domElement.appendChild(this.__input)
	};
	return r.superclass = e, n.extend(r.prototype, e.prototype, {updateDisplay: function () {
		var e, t = this.__input;
		if (this.__truncationSuspended)e = this.getValue(); else {
			e = this.getValue();
			var n = Math.pow(10, this.__precision);
			e = Math.round(e * n) / n
		}
		return t.value = e, r.superclass.prototype.updateDisplay.call(this)
	}}), r
}(dat.controllers.NumberController, dat.dom.dom, dat.utils.common), dat.controllers.NumberControllerSlider = function (e, t, n, r, i) {
	function o(e, t, n, r, i) {
		return r + (e - t) / (n - t) * (i - r)
	}

	var a = function (e, n, r, i, s) {
		function l(e) {
			e.preventDefault();
			var n = t.getOffset(c.__background), r = t.getWidth(c.__background);
			return c.setValue(o(e.clientX, n.left, n.left + r, c.__min, c.__max)), !1
		}

		function u() {
			t.unbind(window, "mousemove", l), t.unbind(window, "mouseup", u), c.__onFinishChange && c.__onFinishChange.call(c, c.getValue())
		}

		a.superclass.call(this, e, n, {min: r, max: i, step: s});
		var c = this;
		this.__background = document.createElement("div"), this.__foreground = document.createElement("div"), t.bind(this.__background, "mousedown", function (e) {
			t.bind(window, "mousemove", l), t.bind(window, "mouseup", u), l(e)
		}), t.addClass(this.__background, "slider"), t.addClass(this.__foreground, "slider-fg"), this.updateDisplay(), this.__background.appendChild(this.__foreground), this.domElement.appendChild(this.__background)
	};
	return a.superclass = e, a.useDefaultStyles = function () {
		n.inject(i)
	}, r.extend(a.prototype, e.prototype, {updateDisplay: function () {
		var e = (this.getValue() - this.__min) / (this.__max - this.__min);
		return this.__foreground.style.width = 100 * e + "%", a.superclass.prototype.updateDisplay.call(this)
	}}), a
}(dat.controllers.NumberController, dat.dom.dom, dat.utils.css, dat.utils.common, "/**\n * dat-gui JavaScript Controller Library\n * http://code.google.com/p/dat-gui\n *\n * Copyright 2011 Data Arts Team, Google Creative Lab\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\n.slider {\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\n  height: 1em;\n  border-radius: 1em;\n  background-color: #eee;\n  padding: 0 0.5em;\n  overflow: hidden;\n}\n\n.slider-fg {\n  padding: 1px 0 2px 0;\n  background-color: #aaa;\n  height: 1em;\n  margin-left: -0.5em;\n  padding-right: 0.5em;\n  border-radius: 1em 0 0 1em;\n}\n\n.slider-fg:after {\n  display: inline-block;\n  border-radius: 1em;\n  background-color: #fff;\n  border:  1px solid #aaa;\n  content: '';\n  float: right;\n  margin-right: -1em;\n  margin-top: -1px;\n  height: 0.9em;\n  width: 0.9em;\n}"), dat.controllers.FunctionController = function (e, t, n) {
	var r = function (e, n, i) {
		r.superclass.call(this, e, n);
		var o = this;
		this.__button = document.createElement("div"), this.__button.innerHTML = void 0 === i ? "Fire" : i, t.bind(this.__button, "click", function (e) {
			return e.preventDefault(), o.fire(), !1
		}), t.addClass(this.__button, "button"), this.domElement.appendChild(this.__button)
	};
	return r.superclass = e, n.extend(r.prototype, e.prototype, {fire: function () {
		this.__onChange && this.__onChange.call(this), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.getValue().call(this.object)
	}}), r
}(dat.controllers.Controller, dat.dom.dom, dat.utils.common), dat.controllers.BooleanController = function (e, t, n) {
	var r = function (e, n) {
		r.superclass.call(this, e, n);
		var i = this;
		this.__prev = this.getValue(), this.__checkbox = document.createElement("input"), this.__checkbox.setAttribute("type", "checkbox"), t.bind(this.__checkbox, "change", function () {
			i.setValue(!i.__prev)
		}, !1), this.domElement.appendChild(this.__checkbox), this.updateDisplay()
	};
	return r.superclass = e, n.extend(r.prototype, e.prototype, {setValue: function (e) {
		return e = r.superclass.prototype.setValue.call(this, e), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), e
	}, updateDisplay: function () {
		return!0 === this.getValue() ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = !0) : this.__checkbox.checked = !1, r.superclass.prototype.updateDisplay.call(this)
	}}), r
}(dat.controllers.Controller, dat.dom.dom, dat.utils.common), dat.color.toString = function (e) {
	return function (t) {
		if (1 == t.a || e.isUndefined(t.a)) {
			for (t = t.hex.toString(16); 6 > t.length;)t = "0" + t;
			return"#" + t
		}
		return"rgba(" + Math.round(t.r) + "," + Math.round(t.g) + "," + Math.round(t.b) + "," + t.a + ")"
	}
}(dat.utils.common), dat.color.interpret = function (e, t) {
	var n, r, i = [
		{litmus: t.isString, conversions: {THREE_CHAR_HEX: {read: function (e) {
			return e = e.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i), null === e ? !1 : {space: "HEX", hex: parseInt("0x" + e[1].toString() + e[1].toString() + e[2].toString() + e[2].toString() + e[3].toString() + e[3].toString())}
		}, write: e}, SIX_CHAR_HEX: {read: function (e) {
			return e = e.match(/^#([A-F0-9]{6})$/i), null === e ? !1 : {space: "HEX", hex: parseInt("0x" + e[1].toString())}
		}, write: e}, CSS_RGB: {read: function (e) {
			return e = e.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/), null === e ? !1 : {space: "RGB", r: parseFloat(e[1]), g: parseFloat(e[2]), b: parseFloat(e[3])}
		}, write: e}, CSS_RGBA: {read: function (e) {
			return e = e.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/), null === e ? !1 : {space: "RGB", r: parseFloat(e[1]), g: parseFloat(e[2]), b: parseFloat(e[3]), a: parseFloat(e[4])}
		}, write: e}}},
		{litmus: t.isNumber, conversions: {HEX: {read: function (e) {
			return{space: "HEX", hex: e, conversionName: "HEX"}
		}, write: function (e) {
			return e.hex
		}}}},
		{litmus: t.isArray, conversions: {RGB_ARRAY: {read: function (e) {
			return 3 != e.length ? !1 : {space: "RGB", r: e[0], g: e[1], b: e[2]}
		}, write: function (e) {
			return[e.r, e.g, e.b]
		}}, RGBA_ARRAY: {read: function (e) {
			return 4 != e.length ? !1 : {space: "RGB", r: e[0], g: e[1], b: e[2], a: e[3]}
		}, write: function (e) {
			return[e.r, e.g, e.b, e.a]
		}}}},
		{litmus: t.isObject, conversions: {RGBA_OBJ: {read: function (e) {
			return t.isNumber(e.r) && t.isNumber(e.g) && t.isNumber(e.b) && t.isNumber(e.a) ? {space: "RGB", r: e.r, g: e.g, b: e.b, a: e.a} : !1
		}, write: function (e) {
			return{r: e.r, g: e.g, b: e.b, a: e.a}
		}}, RGB_OBJ: {read: function (e) {
			return t.isNumber(e.r) && t.isNumber(e.g) && t.isNumber(e.b) ? {space: "RGB", r: e.r, g: e.g, b: e.b} : !1
		}, write: function (e) {
			return{r: e.r, g: e.g, b: e.b}
		}}, HSVA_OBJ: {read: function (e) {
			return t.isNumber(e.h) && t.isNumber(e.s) && t.isNumber(e.v) && t.isNumber(e.a) ? {space: "HSV", h: e.h, s: e.s, v: e.v, a: e.a} : !1
		}, write: function (e) {
			return{h: e.h, s: e.s, v: e.v, a: e.a}
		}}, HSV_OBJ: {read: function (e) {
			return t.isNumber(e.h) && t.isNumber(e.s) && t.isNumber(e.v) ? {space: "HSV", h: e.h, s: e.s, v: e.v} : !1
		}, write: function (e) {
			return{h: e.h, s: e.s, v: e.v}
		}}}}
	];
	return function () {
		r = !1;
		var e = 1 < arguments.length ? t.toArray(arguments) : arguments[0];
		return t.each(i, function (i) {
			return i.litmus(e) ? (t.each(i.conversions, function (i, o) {
				return n = i.read(e), !1 === r && !1 !== n ? (r = n, n.conversionName = o, n.conversion = i, t.BREAK) : void 0
			}), t.BREAK) : void 0
		}), r
	}
}(dat.color.toString, dat.utils.common), dat.GUI = dat.gui.GUI = function (e, t, n, r, i, o, a, s, l, u, c, h, f, d, p) {
	function m(e, t, n, o) {
		if (void 0 === t[n])throw Error("Object " + t + ' has no property "' + n + '"');
		o.color ? t = new c(t, n) : (t = [t, n].concat(o.factoryArgs), t = r.apply(e, t)), o.before instanceof i && (o.before = o.before.__li), v(e, t), d.addClass(t.domElement, "c"), n = document.createElement("span"), d.addClass(n, "property-name"), n.innerHTML = t.property;
		var a = document.createElement("div");
		return a.appendChild(n), a.appendChild(t.domElement), o = g(e, a, o.before), d.addClass(o, D.CLASS_CONTROLLER_ROW), d.addClass(o, typeof t.getValue()), E(e, o, t), e.__controllers.push(t), t
	}

	function g(e, t, n) {
		var r = document.createElement("li");
		return t && r.appendChild(t), n ? e.__ul.insertBefore(r, params.before) : e.__ul.appendChild(r), e.onResize(), r
	}

	function E(e, t, n) {
		if (n.__li = t, n.__gui = e, p.extend(n, {options: function (t) {
			return 1 < arguments.length ? (n.remove(), m(e, n.object, n.property, {before: n.__li.nextElementSibling, factoryArgs: [p.toArray(arguments)]})) : p.isArray(t) || p.isObject(t) ? (n.remove(), m(e, n.object, n.property, {before: n.__li.nextElementSibling, factoryArgs: [t]})) : void 0
		}, name: function (e) {
			return n.__li.firstElementChild.firstElementChild.innerHTML = e, n
		}, listen: function () {
			return n.__gui.listen(n), n
		}, remove: function () {
			return n.__gui.remove(n), n
		}}), n instanceof l) {
			var r = new s(n.object, n.property, {min: n.__min, max: n.__max, step: n.__step});
			p.each(["updateDisplay", "onChange", "onFinishChange"], function (e) {
				var t = n[e], i = r[e];
				n[e] = r[e] = function () {
					var e = Array.prototype.slice.call(arguments);
					return t.apply(n, e), i.apply(r, e)
				}
			}), d.addClass(t, "has-slider"), n.domElement.insertBefore(r.domElement, n.domElement.firstElementChild)
		} else if (n instanceof s) {
			var i = function (t) {
				return p.isNumber(n.__min) && p.isNumber(n.__max) ? (n.remove(), m(e, n.object, n.property, {before: n.__li.nextElementSibling, factoryArgs: [n.__min, n.__max, n.__step]})) : t
			};
			n.min = p.compose(i, n.min), n.max = p.compose(i, n.max)
		} else n instanceof o ? (d.bind(t, "click", function () {
			d.fakeEvent(n.__checkbox, "click")
		}), d.bind(n.__checkbox, "click", function (e) {
			e.stopPropagation()
		})) : n instanceof a ? (d.bind(t, "click", function () {
			d.fakeEvent(n.__button, "click")
		}), d.bind(t, "mouseover", function () {
			d.addClass(n.__button, "hover")
		}), d.bind(t, "mouseout", function () {
			d.removeClass(n.__button, "hover")
		})) : n instanceof c && (d.addClass(t, "color"), n.updateDisplay = p.compose(function (e) {
			return t.style.borderLeftColor = n.__color.toString(), e
		}, n.updateDisplay), n.updateDisplay());
		n.setValue = p.compose(function (t) {
			return e.getRoot().__preset_select && n.isModified() && _(e.getRoot(), !0), t
		}, n.setValue)
	}

	function v(e, t) {
		var n = e.getRoot(), r = n.__rememberedObjects.indexOf(t.object);
		if (-1 != r) {
			var i = n.__rememberedObjectIndecesToControllers[r];
			if (void 0 === i && (i = {}, n.__rememberedObjectIndecesToControllers[r] = i), i[t.property] = t, n.load && n.load.remembered) {
				if (n = n.load.remembered, n[e.preset])n = n[e.preset]; else {
					if (!n[M])return;
					n = n[M]
				}
				n[r] && void 0 !== n[r][t.property] && (r = n[r][t.property], t.initialValue = r, t.setValue(r))
			}
		}
	}

	function y(e) {
		var t = e.__save_row = document.createElement("li");
		d.addClass(e.domElement, "has-save"), e.__ul.insertBefore(t, e.__ul.firstChild), d.addClass(t, "save-row");
		var n = document.createElement("span");
		n.innerHTML = "&nbsp;", d.addClass(n, "button gears");
		var r = document.createElement("span");
		r.innerHTML = "Save", d.addClass(r, "button"), d.addClass(r, "save");
		var i = document.createElement("span");
		i.innerHTML = "New", d.addClass(i, "button"), d.addClass(i, "save-as");
		var o = document.createElement("span");
		o.innerHTML = "Revert", d.addClass(o, "button"), d.addClass(o, "revert");
		var a = e.__preset_select = document.createElement("select");
		if (e.load && e.load.remembered ? p.each(e.load.remembered, function (t, n) {
			b(e, n, n == e.preset)
		}) : b(e, M, !1), d.bind(a, "change", function () {
			for (var t = 0; t < e.__preset_select.length; t++)e.__preset_select[t].innerHTML = e.__preset_select[t].value;
			e.preset = this.value
		}), t.appendChild(a), t.appendChild(n), t.appendChild(r), t.appendChild(i), t.appendChild(o), H) {
			var t = document.getElementById("dg-save-locally"), s = document.getElementById("dg-local-explain");
			t.style.display = "block", t = document.getElementById("dg-local-storage"), "true" === localStorage.getItem(document.location.href + ".isLocal") && t.setAttribute("checked", "checked");
			var l = function () {
				s.style.display = e.useLocalStorage ? "block" : "none"
			};
			l(), d.bind(t, "change", function () {
				e.useLocalStorage = !e.useLocalStorage, l()
			})
		}
		var u = document.getElementById("dg-new-constructor");
		d.bind(u, "keydown", function (e) {
			!e.metaKey || 67 !== e.which && 67 != e.keyCode || C.hide()
		}), d.bind(n, "click", function () {
			u.innerHTML = JSON.stringify(e.getSaveObject(), void 0, 2), C.show(), u.focus(), u.select()
		}), d.bind(r, "click", function () {
			e.save()
		}), d.bind(i, "click", function () {
			var t = prompt("Enter a new preset name.");
			t && e.saveAs(t)
		}), d.bind(o, "click", function () {
			e.revert()
		})
	}

	function T(e) {
		function t(t) {
			return t.preventDefault(), i = t.clientX, d.addClass(e.__closeButton, D.CLASS_DRAG), d.bind(window, "mousemove", n), d.bind(window, "mouseup", r), !1
		}

		function n(t) {
			return t.preventDefault(), e.width += i - t.clientX, e.onResize(), i = t.clientX, !1
		}

		function r() {
			d.removeClass(e.__closeButton, D.CLASS_DRAG), d.unbind(window, "mousemove", n), d.unbind(window, "mouseup", r)
		}

		e.__resize_handle = document.createElement("div"), p.extend(e.__resize_handle.style, {width: "6px", marginLeft: "-3px", height: "200px", cursor: "ew-resize", position: "absolute"});
		var i;
		d.bind(e.__resize_handle, "mousedown", t), d.bind(e.__closeButton, "mousedown", t), e.domElement.insertBefore(e.__resize_handle, e.domElement.firstElementChild)
	}

	function x(e, t) {
		e.domElement.style.width = t + "px", e.__save_row && e.autoPlace && (e.__save_row.style.width = t + "px"), e.__closeButton && (e.__closeButton.style.width = t + "px")
	}

	function R(e, t) {
		var n = {};
		return p.each(e.__rememberedObjects, function (r, i) {
			var o = {};
			p.each(e.__rememberedObjectIndecesToControllers[i], function (e, n) {
				o[n] = t ? e.initialValue : e.getValue()
			}), n[i] = o
		}), n
	}

	function b(e, t, n) {
		var r = document.createElement("option");
		r.innerHTML = t, r.value = t, e.__preset_select.appendChild(r), n && (e.__preset_select.selectedIndex = e.__preset_select.length - 1)
	}

	function _(e, t) {
		var n = e.__preset_select[e.__preset_select.selectedIndex];
		n.innerHTML = t ? n.value + "*" : n.value
	}

	function w(e) {
		0 != e.length && h(function () {
			w(e)
		}), p.each(e, function (e) {
			e.updateDisplay()
		})
	}

	e.inject(n);
	var H, M = "Default";
	try {
		H = "localStorage"in window && null !== window.localStorage
	} catch (S) {
		H = !1
	}
	var C, A, L = !0, k = !1, P = [], D = function (e) {
		function t() {
			localStorage.setItem(document.location.href + ".gui", JSON.stringify(r.getSaveObject()))
		}

		function n() {
			var e = r.getRoot();
			e.width += 1, p.defer(function () {
				e.width -= 1
			})
		}

		var r = this;
		this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), d.addClass(this.domElement, "dg"), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], e = e || {}, e = p.defaults(e, {autoPlace: !0, width: D.DEFAULT_WIDTH}), e = p.defaults(e, {resizable: e.autoPlace, hideable: e.autoPlace}), p.isUndefined(e.load) ? e.load = {preset: M} : e.preset && (e.load.preset = e.preset), p.isUndefined(e.parent) && e.hideable && P.push(this), e.resizable = p.isUndefined(e.parent) && e.resizable, e.autoPlace && p.isUndefined(e.scrollable) && (e.scrollable = !0);
		var i = H && "true" === localStorage.getItem(document.location.href + ".isLocal");
		if (Object.defineProperties(this, {parent: {get: function () {
			return e.parent
		}}, scrollable: {get: function () {
			return e.scrollable
		}}, autoPlace: {get: function () {
			return e.autoPlace
		}}, preset: {get: function () {
			return r.parent ? r.getRoot().preset : e.load.preset
		}, set: function (t) {
			for (r.parent ? r.getRoot().preset = t : e.load.preset = t, t = 0; t < this.__preset_select.length; t++)this.__preset_select[t].value == this.preset && (this.__preset_select.selectedIndex = t);
			r.revert()
		}}, width: {get: function () {
			return e.width
		}, set: function (t) {
			e.width = t, x(r, t)
		}}, name: {get: function () {
			return e.name
		}, set: function (t) {
			e.name = t, a && (a.innerHTML = e.name)
		}}, closed: {get: function () {
			return e.closed
		}, set: function (t) {
			e.closed = t, e.closed ? d.addClass(r.__ul, D.CLASS_CLOSED) : d.removeClass(r.__ul, D.CLASS_CLOSED), this.onResize(), r.__closeButton && (r.__closeButton.innerHTML = t ? D.TEXT_OPEN : D.TEXT_CLOSED)
		}}, load: {get: function () {
			return e.load
		}}, useLocalStorage: {get: function () {
			return i
		}, set: function (e) {
			H && ((i = e) ? d.bind(window, "unload", t) : d.unbind(window, "unload", t), localStorage.setItem(document.location.href + ".isLocal", e))
		}}}), p.isUndefined(e.parent)) {
			if (e.closed = !1, d.addClass(this.domElement, D.CLASS_MAIN), d.makeSelectable(this.domElement, !1), H && i) {
				r.useLocalStorage = !0;
				var o = localStorage.getItem(document.location.href + ".gui");
				o && (e.load = JSON.parse(o))
			}
			this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = D.TEXT_CLOSED, d.addClass(this.__closeButton, D.CLASS_CLOSE_BUTTON), this.domElement.appendChild(this.__closeButton), d.bind(this.__closeButton, "click", function () {
				r.closed = !r.closed
			})
		} else {
			void 0 === e.closed && (e.closed = !0);
			var a = document.createTextNode(e.name);
			d.addClass(a, "controller-name"), o = g(r, a), d.addClass(this.__ul, D.CLASS_CLOSED), d.addClass(o, "title"), d.bind(o, "click", function (e) {
				return e.preventDefault(), r.closed = !r.closed, !1
			}), e.closed || (this.closed = !1)
		}
		e.autoPlace && (p.isUndefined(e.parent) && (L && (A = document.createElement("div"), d.addClass(A, "dg"), d.addClass(A, D.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(A), L = !1), A.appendChild(this.domElement), d.addClass(this.domElement, D.CLASS_AUTO_PLACE)), this.parent || x(r, e.width)), d.bind(window, "resize", function () {
			r.onResize()
		}), d.bind(this.__ul, "webkitTransitionEnd", function () {
			r.onResize()
		}), d.bind(this.__ul, "transitionend", function () {
			r.onResize()
		}), d.bind(this.__ul, "oTransitionEnd", function () {
			r.onResize()
		}), this.onResize(), e.resizable && T(this), r.getRoot(), e.parent || n()
	};
	return D.toggleHide = function () {
		k = !k, p.each(P, function (e) {
			e.domElement.style.zIndex = k ? -999 : 999, e.domElement.style.opacity = k ? 0 : 1
		})
	}, D.CLASS_AUTO_PLACE = "a", D.CLASS_AUTO_PLACE_CONTAINER = "ac", D.CLASS_MAIN = "main", D.CLASS_CONTROLLER_ROW = "cr", D.CLASS_TOO_TALL = "taller-than-window", D.CLASS_CLOSED = "closed", D.CLASS_CLOSE_BUTTON = "close-button", D.CLASS_DRAG = "drag", D.DEFAULT_WIDTH = 245, D.TEXT_CLOSED = "Close Controls", D.TEXT_OPEN = "Open Controls", d.bind(window, "keydown", function (e) {
		"text" === document.activeElement.type || 72 !== e.which && 72 != e.keyCode || D.toggleHide()
	}, !1), p.extend(D.prototype, {add: function (e, t) {
		return m(this, e, t, {factoryArgs: Array.prototype.slice.call(arguments, 2)})
	}, addColor: function (e, t) {
		return m(this, e, t, {color: !0})
	}, remove: function (e) {
		this.__ul.removeChild(e.__li), this.__controllers.slice(this.__controllers.indexOf(e), 1);
		var t = this;
		p.defer(function () {
			t.onResize()
		})
	}, destroy: function () {
		this.autoPlace && A.removeChild(this.domElement)
	}, addFolder: function (e) {
		if (void 0 !== this.__folders[e])throw Error('You already have a folder in this GUI by the name "' + e + '"');
		var t = {name: e, parent: this};
		return t.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[e] && (t.closed = this.load.folders[e].closed, t.load = this.load.folders[e]), t = new D(t), this.__folders[e] = t, e = g(this, t.domElement), d.addClass(e, "folder"), t
	}, open: function () {
		this.closed = !1
	}, close: function () {
		this.closed = !0
	}, onResize: function () {
		var e = this.getRoot();
		if (e.scrollable) {
			var t = d.getOffset(e.__ul).top, n = 0;
			p.each(e.__ul.childNodes, function (t) {
				e.autoPlace && t === e.__save_row || (n += d.getHeight(t))
			}), window.innerHeight - t - 20 < n ? (d.addClass(e.domElement, D.CLASS_TOO_TALL), e.__ul.style.height = window.innerHeight - t - 20 + "px") : (d.removeClass(e.domElement, D.CLASS_TOO_TALL), e.__ul.style.height = "auto")
		}
		e.__resize_handle && p.defer(function () {
			e.__resize_handle.style.height = e.__ul.offsetHeight + "px"
		}), e.__closeButton && (e.__closeButton.style.width = e.width + "px")
	}, remember: function () {
		if (p.isUndefined(C) && (C = new f, C.domElement.innerHTML = t), this.parent)throw Error("You can only call remember on a top level GUI.");
		var e = this;
		p.each(Array.prototype.slice.call(arguments), function (t) {
			0 == e.__rememberedObjects.length && y(e), -1 == e.__rememberedObjects.indexOf(t) && e.__rememberedObjects.push(t)
		}), this.autoPlace && x(this, this.width)
	}, getRoot: function () {
		for (var e = this; e.parent;)e = e.parent;
		return e
	}, getSaveObject: function () {
		var e = this.load;
		return e.closed = this.closed, 0 < this.__rememberedObjects.length && (e.preset = this.preset, e.remembered || (e.remembered = {}), e.remembered[this.preset] = R(this)), e.folders = {}, p.each(this.__folders, function (t, n) {
			e.folders[n] = t.getSaveObject()
		}), e
	}, save: function () {
		this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = R(this), _(this, !1)
	}, saveAs: function (e) {
		this.load.remembered || (this.load.remembered = {}, this.load.remembered[M] = R(this, !0)), this.load.remembered[e] = R(this), this.preset = e, b(this, e, !0)
	}, revert: function (e) {
		p.each(this.__controllers, function (t) {
			this.getRoot().load.remembered ? v(e || this.getRoot(), t) : t.setValue(t.initialValue)
		}, this), p.each(this.__folders, function (e) {
			e.revert(e)
		}), e || _(this.getRoot(), !1)
	}, listen: function (e) {
		var t = 0 == this.__listening.length;
		this.__listening.push(e), t && w(this.__listening)
	}}), D
}(dat.utils.css, '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n      \n    </div>\n    \n  </div>\n\n</div>', ".dg {\n  /** Clear list styles */\n  /* Auto-place container */\n  /* Auto-placed GUI's */\n  /* Line items that don't contain folders. */\n  /** Folder names */\n  /** Hides closed items */\n  /** Controller row */\n  /** Name-half (left) */\n  /** Controller-half (right) */\n  /** Controller placement */\n  /** Shorter number boxes when slider is present. */\n  /** Ensure the entire boolean and function row shows a hand */ }\n  .dg ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    width: 100%;\n    clear: both; }\n  .dg.ac {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    height: 0;\n    z-index: 0; }\n  .dg:not(.ac) .main {\n    /** Exclude mains in ac so that we don't hide close button */\n    overflow: hidden; }\n  .dg.main {\n    -webkit-transition: opacity 0.1s linear;\n    -o-transition: opacity 0.1s linear;\n    -moz-transition: opacity 0.1s linear;\n    transition: opacity 0.1s linear; }\n    .dg.main.taller-than-window {\n      overflow-y: auto; }\n      .dg.main.taller-than-window .close-button {\n        opacity: 1;\n        /* TODO, these are style notes */\n        margin-top: -1px;\n        border-top: 1px solid #2c2c2c; }\n    .dg.main ul.closed .close-button {\n      opacity: 1 !important; }\n    .dg.main:hover .close-button,\n    .dg.main .close-button.drag {\n      opacity: 1; }\n    .dg.main .close-button {\n      /*opacity: 0;*/\n      -webkit-transition: opacity 0.1s linear;\n      -o-transition: opacity 0.1s linear;\n      -moz-transition: opacity 0.1s linear;\n      transition: opacity 0.1s linear;\n      border: 0;\n      position: absolute;\n      line-height: 19px;\n      height: 20px;\n      /* TODO, these are style notes */\n      cursor: pointer;\n      text-align: center;\n      background-color: #000; }\n      .dg.main .close-button:hover {\n        background-color: #111; }\n  .dg.a {\n    float: right;\n    margin-right: 15px;\n    overflow-x: hidden; }\n    .dg.a.has-save > ul {\n      margin-top: 27px; }\n      .dg.a.has-save > ul.closed {\n        margin-top: 0; }\n    .dg.a .save-row {\n      position: fixed;\n      top: 0;\n      z-index: 1002; }\n  .dg li {\n    -webkit-transition: height 0.1s ease-out;\n    -o-transition: height 0.1s ease-out;\n    -moz-transition: height 0.1s ease-out;\n    transition: height 0.1s ease-out; }\n  .dg li:not(.folder) {\n    cursor: auto;\n    height: 27px;\n    line-height: 27px;\n    overflow: hidden;\n    padding: 0 4px 0 5px; }\n  .dg li.folder {\n    padding: 0;\n    border-left: 4px solid rgba(0, 0, 0, 0); }\n  .dg li.title {\n    cursor: pointer;\n    margin-left: -4px; }\n  .dg .closed li:not(.title),\n  .dg .closed ul li,\n  .dg .closed ul li > * {\n    height: 0;\n    overflow: hidden;\n    border: 0; }\n  .dg .cr {\n    clear: both;\n    padding-left: 3px;\n    height: 27px; }\n  .dg .property-name {\n    cursor: default;\n    float: left;\n    clear: left;\n    width: 40%;\n    overflow: hidden;\n    text-overflow: ellipsis; }\n  .dg .c {\n    float: left;\n    width: 60%; }\n  .dg .c input[type=text] {\n    border: 0;\n    margin-top: 4px;\n    padding: 3px;\n    width: 100%;\n    float: right; }\n  .dg .has-slider input[type=text] {\n    width: 30%;\n    /*display: none;*/\n    margin-left: 0; }\n  .dg .slider {\n    float: left;\n    width: 66%;\n    margin-left: -5px;\n    margin-right: 0;\n    height: 19px;\n    margin-top: 4px; }\n  .dg .slider-fg {\n    height: 100%; }\n  .dg .c input[type=checkbox] {\n    margin-top: 9px; }\n  .dg .c select {\n    margin-top: 5px; }\n  .dg .cr.function,\n  .dg .cr.function .property-name,\n  .dg .cr.function *,\n  .dg .cr.boolean,\n  .dg .cr.boolean * {\n    cursor: pointer; }\n  .dg .selector {\n    display: none;\n    position: absolute;\n    margin-left: -9px;\n    margin-top: 23px;\n    z-index: 10; }\n  .dg .c:hover .selector,\n  .dg .selector.drag {\n    display: block; }\n  .dg li.save-row {\n    padding: 0; }\n    .dg li.save-row .button {\n      display: inline-block;\n      padding: 0px 6px; }\n  .dg.dialogue {\n    background-color: #222;\n    width: 460px;\n    padding: 15px;\n    font-size: 13px;\n    line-height: 15px; }\n\n/* TODO Separate style and structure */\n#dg-new-constructor {\n  padding: 10px;\n  color: #222;\n  font-family: Monaco, monospace;\n  font-size: 10px;\n  border: 0;\n  resize: none;\n  box-shadow: inset 1px 1px 1px #888;\n  word-wrap: break-word;\n  margin: 12px 0;\n  display: block;\n  width: 440px;\n  overflow-y: scroll;\n  height: 100px;\n  position: relative; }\n\n#dg-local-explain {\n  display: none;\n  font-size: 11px;\n  line-height: 17px;\n  border-radius: 3px;\n  background-color: #333;\n  padding: 8px;\n  margin-top: 10px; }\n  #dg-local-explain code {\n    font-size: 10px; }\n\n#dat-gui-save-locally {\n  display: none; }\n\n/** Main type */\n.dg {\n  color: #eee;\n  font: 11px 'Lucida Grande', sans-serif;\n  text-shadow: 0 -1px 0 #111;\n  /** Auto place */\n  /* Controller row, <li> */\n  /** Controllers */ }\n  .dg.main {\n    /** Scrollbar */ }\n    .dg.main::-webkit-scrollbar {\n      width: 5px;\n      background: #1a1a1a; }\n    .dg.main::-webkit-scrollbar-corner {\n      height: 0;\n      display: none; }\n    .dg.main::-webkit-scrollbar-thumb {\n      border-radius: 5px;\n      background: #676767; }\n  .dg li:not(.folder) {\n    background: #1a1a1a;\n    border-bottom: 1px solid #2c2c2c; }\n  .dg li.save-row {\n    line-height: 25px;\n    background: #dad5cb;\n    border: 0; }\n    .dg li.save-row select {\n      margin-left: 5px;\n      width: 108px; }\n    .dg li.save-row .button {\n      margin-left: 5px;\n      margin-top: 1px;\n      border-radius: 2px;\n      font-size: 9px;\n      line-height: 7px;\n      padding: 4px 4px 5px 4px;\n      background: #c5bdad;\n      color: #fff;\n      text-shadow: 0 1px 0 #b0a58f;\n      box-shadow: 0 -1px 0 #b0a58f;\n      cursor: pointer; }\n      .dg li.save-row .button.gears {\n        background: #c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;\n        height: 7px;\n        width: 8px; }\n      .dg li.save-row .button:hover {\n        background-color: #bab19e;\n        box-shadow: 0 -1px 0 #b0a58f; }\n  .dg li.folder {\n    border-bottom: 0; }\n  .dg li.title {\n    padding-left: 16px;\n    background: black url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;\n    cursor: pointer;\n    border-bottom: 1px solid rgba(255, 255, 255, 0.2); }\n  .dg .closed li.title {\n    background-image: url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==); }\n  .dg .cr.boolean {\n    border-left: 3px solid #806787; }\n  .dg .cr.function {\n    border-left: 3px solid #e61d5f; }\n  .dg .cr.number {\n    border-left: 3px solid #2fa1d6; }\n    .dg .cr.number input[type=text] {\n      color: #2fa1d6; }\n  .dg .cr.string {\n    border-left: 3px solid #1ed36f; }\n    .dg .cr.string input[type=text] {\n      color: #1ed36f; }\n  .dg .cr.function:hover, .dg .cr.boolean:hover {\n    background: #111; }\n  .dg .c input[type=text] {\n    background: #303030;\n    outline: none; }\n    .dg .c input[type=text]:hover {\n      background: #3c3c3c; }\n    .dg .c input[type=text]:focus {\n      background: #494949;\n      color: #fff; }\n  .dg .c .slider {\n    background: #303030;\n    cursor: ew-resize; }\n  .dg .c .slider-fg {\n    background: #2fa1d6; }\n  .dg .c .slider:hover {\n    background: #3c3c3c; }\n    .dg .c .slider:hover .slider-fg {\n      background: #44abda; }\n", dat.controllers.factory = function (e, t, n, r, i, o, a) {
	return function (s, l, u, c) {
		var h = s[l];
		return a.isArray(u) || a.isObject(u) ? new e(s, l, u) : a.isNumber(h) ? a.isNumber(u) && a.isNumber(c) ? new n(s, l, u, c) : new t(s, l, {min: u, max: c}) : a.isString(h) ? new r(s, l) : a.isFunction(h) ? new i(s, l, "") : a.isBoolean(h) ? new o(s, l) : void 0
	}
}(dat.controllers.OptionController, dat.controllers.NumberControllerBox, dat.controllers.NumberControllerSlider, dat.controllers.StringController = function (e, t, n) {
	var r = function (e, n) {
		function i() {
			o.setValue(o.__input.value)
		}

		r.superclass.call(this, e, n);
		var o = this;
		this.__input = document.createElement("input"), this.__input.setAttribute("type", "text"), t.bind(this.__input, "keyup", i), t.bind(this.__input, "change", i), t.bind(this.__input, "blur", function () {
			o.__onFinishChange && o.__onFinishChange.call(o, o.getValue())
		}), t.bind(this.__input, "keydown", function (e) {
			13 === e.keyCode && this.blur()
		}), this.updateDisplay(), this.domElement.appendChild(this.__input)
	};
	return r.superclass = e, n.extend(r.prototype, e.prototype, {updateDisplay: function () {
		return t.isActive(this.__input) || (this.__input.value = this.getValue()), r.superclass.prototype.updateDisplay.call(this)
	}}), r
}(dat.controllers.Controller, dat.dom.dom, dat.utils.common), dat.controllers.FunctionController, dat.controllers.BooleanController, dat.utils.common), dat.controllers.Controller, dat.controllers.BooleanController, dat.controllers.FunctionController, dat.controllers.NumberControllerBox, dat.controllers.NumberControllerSlider, dat.controllers.OptionController, dat.controllers.ColorController = function (e, t, n, r, i) {
	function o(e, t, n, r) {
		e.style.background = "", i.each(l, function (i) {
			e.style.cssText += "background: " + i + "linear-gradient(" + t + ", " + n + " 0%, " + r + " 100%); "
		})
	}

	function a(e) {
		e.style.background = "", e.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", e.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", e.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", e.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", e.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"
	}

	var s = function (e, l) {
		function u(e) {
			d(e), t.bind(window, "mousemove", d), t.bind(window, "mouseup", c)
		}

		function c() {
			t.unbind(window, "mousemove", d), t.unbind(window, "mouseup", c)
		}

		function h() {
			var e = r(this.value);
			!1 !== e ? (m.__color.__state = e, m.setValue(m.__color.toOriginal())) : this.value = m.__color.toString()
		}

		function f() {
			t.unbind(window, "mousemove", p), t.unbind(window, "mouseup", f)
		}

		function d(e) {
			e.preventDefault();
			var n = t.getWidth(m.__saturation_field), r = t.getOffset(m.__saturation_field), i = (e.clientX - r.left + document.body.scrollLeft) / n;
			return e = 1 - (e.clientY - r.top + document.body.scrollTop) / n, e > 1 ? e = 1 : 0 > e && (e = 0), i > 1 ? i = 1 : 0 > i && (i = 0), m.__color.v = e, m.__color.s = i, m.setValue(m.__color.toOriginal()), !1
		}

		function p(e) {
			e.preventDefault();
			var n = t.getHeight(m.__hue_field), r = t.getOffset(m.__hue_field);
			return e = 1 - (e.clientY - r.top + document.body.scrollTop) / n, e > 1 ? e = 1 : 0 > e && (e = 0), m.__color.h = 360 * e, m.setValue(m.__color.toOriginal()), !1
		}

		s.superclass.call(this, e, l), this.__color = new n(this.getValue()), this.__temp = new n(0);
		var m = this;
		this.domElement = document.createElement("div"), t.makeSelectable(this.domElement, !1), this.__selector = document.createElement("div"), this.__selector.className = "selector", this.__saturation_field = document.createElement("div"), this.__saturation_field.className = "saturation-field", this.__field_knob = document.createElement("div"), this.__field_knob.className = "field-knob", this.__field_knob_border = "2px solid ", this.__hue_knob = document.createElement("div"), this.__hue_knob.className = "hue-knob", this.__hue_field = document.createElement("div"), this.__hue_field.className = "hue-field", this.__input = document.createElement("input"), this.__input.type = "text", this.__input_textShadow = "0 1px 1px ", t.bind(this.__input, "keydown", function (e) {
			13 === e.keyCode && h.call(this)
		}), t.bind(this.__input, "blur", h), t.bind(this.__selector, "mousedown", function () {
			t.addClass(this, "drag").bind(window, "mouseup", function () {
				t.removeClass(m.__selector, "drag")
			})
		});
		var g = document.createElement("div");
		i.extend(this.__selector.style, {width: "122px", height: "102px", padding: "3px", backgroundColor: "#222", boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"}), i.extend(this.__field_knob.style, {position: "absolute", width: "12px", height: "12px", border: this.__field_knob_border + (.5 > this.__color.v ? "#fff" : "#000"), boxShadow: "0px 1px 3px rgba(0,0,0,0.5)", borderRadius: "12px", zIndex: 1}), i.extend(this.__hue_knob.style, {position: "absolute", width: "15px", height: "2px", borderRight: "4px solid #fff", zIndex: 1}), i.extend(this.__saturation_field.style, {width: "100px", height: "100px", border: "1px solid #555", marginRight: "3px", display: "inline-block", cursor: "pointer"}), i.extend(g.style, {width: "100%", height: "100%", background: "none"}), o(g, "top", "rgba(0,0,0,0)", "#000"), i.extend(this.__hue_field.style, {width: "15px", height: "100px", display: "inline-block", border: "1px solid #555", cursor: "ns-resize"}), a(this.__hue_field), i.extend(this.__input.style, {outline: "none", textAlign: "center", color: "#fff", border: 0, fontWeight: "bold", textShadow: this.__input_textShadow + "rgba(0,0,0,0.7)"}), t.bind(this.__saturation_field, "mousedown", u), t.bind(this.__field_knob, "mousedown", u), t.bind(this.__hue_field, "mousedown", function (e) {
			p(e), t.bind(window, "mousemove", p), t.bind(window, "mouseup", f)
		}), this.__saturation_field.appendChild(g), this.__selector.appendChild(this.__field_knob), this.__selector.appendChild(this.__saturation_field), this.__selector.appendChild(this.__hue_field), this.__hue_field.appendChild(this.__hue_knob), this.domElement.appendChild(this.__input), this.domElement.appendChild(this.__selector), this.updateDisplay()
	};
	s.superclass = e, i.extend(s.prototype, e.prototype, {updateDisplay: function () {
		var e = r(this.getValue());
		if (!1 !== e) {
			var t = !1;
			i.each(n.COMPONENTS, function (n) {
				return i.isUndefined(e[n]) || i.isUndefined(this.__color.__state[n]) || e[n] === this.__color.__state[n] ? void 0 : (t = !0, {})
			}, this), t && i.extend(this.__color.__state, e)
		}
		i.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1;
		var a = .5 > this.__color.v || .5 < this.__color.s ? 255 : 0, s = 255 - a;
		i.extend(this.__field_knob.style, {marginLeft: 100 * this.__color.s - 7 + "px", marginTop: 100 * (1 - this.__color.v) - 7 + "px", backgroundColor: this.__temp.toString(), border: this.__field_knob_border + "rgb(" + a + "," + a + "," + a + ")"}), this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px", this.__temp.s = 1, this.__temp.v = 1, o(this.__saturation_field, "left", "#fff", this.__temp.toString()), i.extend(this.__input.style, {backgroundColor: this.__input.value = this.__color.toString(), color: "rgb(" + a + "," + a + "," + a + ")", textShadow: this.__input_textShadow + "rgba(" + s + "," + s + "," + s + ",.7)"})
	}});
	var l = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
	return s
}(dat.controllers.Controller, dat.dom.dom, dat.color.Color = function (e, t, n, r) {
		function i(e, t, n) {
			Object.defineProperty(e, t, {get: function () {
				return"RGB" === this.__state.space ? this.__state[t] : (a(this, t, n), this.__state[t])
			}, set: function (e) {
				"RGB" !== this.__state.space && (a(this, t, n), this.__state.space = "RGB"), this.__state[t] = e
			}})
		}

		function o(e, t) {
			Object.defineProperty(e, t, {get: function () {
				return"HSV" === this.__state.space ? this.__state[t] : (s(this), this.__state[t])
			}, set: function (e) {
				"HSV" !== this.__state.space && (s(this), this.__state.space = "HSV"), this.__state[t] = e
			}})
		}

		function a(e, n, i) {
			if ("HEX" === e.__state.space)e.__state[n] = t.component_from_hex(e.__state.hex, i); else {
				if ("HSV" !== e.__state.space)throw"Corrupted color state";
				r.extend(e.__state, t.hsv_to_rgb(e.__state.h, e.__state.s, e.__state.v))
			}
		}

		function s(e) {
			var n = t.rgb_to_hsv(e.r, e.g, e.b);
			r.extend(e.__state, {s: n.s, v: n.v}), r.isNaN(n.h) ? r.isUndefined(e.__state.h) && (e.__state.h = 0) : e.__state.h = n.h
		}

		var l = function () {
			if (this.__state = e.apply(this, arguments), !1 === this.__state)throw"Failed to interpret color arguments";
			this.__state.a = this.__state.a || 1
		};
		return l.COMPONENTS = "r g b h s v hex a".split(" "), r.extend(l.prototype, {toString: function () {
			return n(this)
		}, toOriginal: function () {
			return this.__state.conversion.write(this)
		}}), i(l.prototype, "r", 2), i(l.prototype, "g", 1), i(l.prototype, "b", 0), o(l.prototype, "h"), o(l.prototype, "s"), o(l.prototype, "v"), Object.defineProperty(l.prototype, "a", {get: function () {
			return this.__state.a
		}, set: function (e) {
			this.__state.a = e
		}}), Object.defineProperty(l.prototype, "hex", {get: function () {
			return"HEX" !== !this.__state.space && (this.__state.hex = t.rgb_to_hex(this.r, this.g, this.b)), this.__state.hex
		}, set: function (e) {
			this.__state.space = "HEX", this.__state.hex = e
		}}), l
	}(dat.color.interpret, dat.color.math = function () {
		var e;
		return{hsv_to_rgb: function (e, t, n) {
			var r = e / 60 - Math.floor(e / 60), i = n * (1 - t), o = n * (1 - r * t);
			return t = n * (1 - (1 - r) * t), e = [
				[n, t, i],
				[o, n, i],
				[i, n, t],
				[i, o, n],
				[t, i, n],
				[n, i, o]
			][Math.floor(e / 60) % 6], {r: 255 * e[0], g: 255 * e[1], b: 255 * e[2]}
		}, rgb_to_hsv: function (e, t, n) {
			var r = Math.min(e, t, n), i = Math.max(e, t, n), r = i - r;
			return 0 == i ? {h: 0 / 0, s: 0, v: 0} : (e = (e == i ? (t - n) / r : t == i ? 2 + (n - e) / r : 4 + (e - t) / r) / 6, 0 > e && (e += 1), {h: 360 * e, s: r / i, v: i / 255})
		}, rgb_to_hex: function (e, t, n) {
			return e = this.hex_with_component(0, 2, e), e = this.hex_with_component(e, 1, t), e = this.hex_with_component(e, 0, n)
		}, component_from_hex: function (e, t) {
			return e >> 8 * t & 255
		}, hex_with_component: function (t, n, r) {
			return r << (e = 8 * n) | t & ~(255 << e)
		}}
	}(), dat.color.toString, dat.utils.common), dat.color.interpret, dat.utils.common), dat.utils.requestAnimationFrame = function () {
	return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (e) {
		window.setTimeout(e, 1e3 / 60)
	}
}(), dat.dom.CenteredDiv = function (e, t) {
	var n = function () {
		this.backgroundElement = document.createElement("div"), t.extend(this.backgroundElement.style, {backgroundColor: "rgba(0,0,0,0.8)", top: 0, left: 0, display: "none", zIndex: "1000", opacity: 0, WebkitTransition: "opacity 0.2s linear"}), e.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), t.extend(this.domElement.style, {position: "fixed", display: "none", zIndex: "1001", opacity: 0, WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear"}), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement);
		var n = this;
		e.bind(this.backgroundElement, "click", function () {
			n.hide()
		})
	};
	return n.prototype.show = function () {
		var e = this;
		this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), t.defer(function () {
			e.backgroundElement.style.opacity = 1, e.domElement.style.opacity = 1, e.domElement.style.webkitTransform = "scale(1)"
		})
	}, n.prototype.hide = function () {
		var t = this, n = function () {
			t.domElement.style.display = "none", t.backgroundElement.style.display = "none", e.unbind(t.domElement, "webkitTransitionEnd", n), e.unbind(t.domElement, "transitionend", n), e.unbind(t.domElement, "oTransitionEnd", n)
		};
		e.bind(this.domElement, "webkitTransitionEnd", n), e.bind(this.domElement, "transitionend", n), e.bind(this.domElement, "oTransitionEnd", n), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)"
	}, n.prototype.layout = function () {
		this.domElement.style.left = window.innerWidth / 2 - e.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - e.getHeight(this.domElement) / 2 + "px"
	}, n
}(dat.dom.dom, dat.utils.common), dat.dom.dom, dat.utils.common), !function (e, t, n, r, i, o, a) {
	function s() {
		et = e(".message-box"), tt = et.find("#message-box-name"), nt = et.find("#message-box-party"), rt = et.find("#message-box-value"), it = et.find("img"), ot = e(".search-box input")
	}

	function l(i) {
		var l, u, p, m, g, E = o.innerWidth, v = o.innerHeight, T = 40, x = E / v, b = .1, _ = 2e4, H = {criterion: a}, k = Object.create(H), N = ["nb_mandats", "semaines_presence", "commission_presences", "commission_interventions", "hemicycle_interventions", "hemicycle_interventions_courtes", "amendements_signes", "amendements_adoptes", "rapports", "propositions_ecrites", "propositions_signees", "questions_ecrites", "questions_orales"];
		F = new n.MeshBasicMaterial({color: 65280, side: n.BackSide}), e(s), f(), z = i, J = t.scale.linear().domain([0, ut]).range([0, 1]), S = new n.Scene, C = new n.PerspectiveCamera(T, x, b, _), S.add(C), C.position.set(-400, 400, -400), C.lookAt(S.position), A = Detector.webgl ? new n.WebGLRenderer({antialias: !0}) : new n.CanvasRenderer, A.setSize(E, v), M = document.getElementById("container"), M.appendChild(A.domElement), r.WindowResize(A, C), L = new n.OrbitControls(C, A.domElement), d(), l = new n.AxisHelper(100), u = new n.BoxGeometry(1e4, 1e4, 1e4), p = new n.MeshBasicMaterial({color: 16777215, side: n.BackSide}), m = new n.Mesh(u, p), S.add(m), P = new n.Projector, D = new dat.GUI, g = D.add(k, "criterion", N), D.open(), g.onFinishChange(function (e) {
			w(), a = e, h()
		}), o.addEventListener("click", R, !1), h(), c(), y()
	}

	function u() {
		lt = 0, m(), g(), E()
	}

	function c() {
		ot.autocomplete({lookup: U.map(function (e) {
			return{value: e.nom, data: e}
		}), onSelect: function (e) {
			b(e.data)
		}})
	}

	function h() {
		var e;
		U = z.deputes.map(function (e) {
			return e.depute
		}), V = t.scale.linear().domain([0, t.max(U, function (e) {
			return parseInt(e[a])
		})]).rangeRound([0, 100]), U.sort(function (e, t) {
			return e.groupe_sigle !== t.groupe_sigle ? ht[e.groupe_sigle] - ht[t.groupe_sigle] : e[a] - t[a]
		}), B = new Array, e = i.groupBy(U, function (e) {
			return e.groupe_sigle
		});
		for (var n in e)B.push({party: n, value: t.round(t.mean(e[n], function (e) {
			return parseInt(e[a])
		}), 2)});
		$ = t.scale.linear().domain([0, B.length - 1]).rangeRound([-G / 2, G / 2]), u()
	}

	function f() {
		O = 0, I = 0, j = 10, W = 58, G = 150, X = 300, q = t.scale.linear().domain([0, j]).rangeRound([G, X]), Y = -Math.PI / 2, K = Math.PI / 2, Z = t.scale.linear().domain([0, W]).range([Y, K]), Q = 7
	}

	function d() {
		var e = new n.HemisphereLight(16777215, 16777215, .6);
		e.position.set(0, 500, 0);
		var t = new n.DirectionalLight(16777215, .6);
		t.position.set(-1, .75, 1), t.position.multiplyScalar(50), t.name = "dirlight", t.castShadow = !0, t.shadowMapWidth = t.shadowMapHeight = 2048;
		var r = 300;
		t.shadowCameraLeft = -r, t.shadowCameraRight = r, t.shadowCameraTop = r, t.shadowCameraBottom = -r, t.shadowCameraFar = 3500, t.shadowBias = -1e-4, t.shadowDarkness = .35, S.add(e), S.add(t)
	}

	function p() {
		if (ut >= lt) {
			var e = J(lt);
			v(e), lt += 1
		}
	}

	function m() {
		st.forEach(function (e) {
			S.remove(e)
		}), at = new Array, st = new Array
	}

	function g() {
		var e, t, r, i, o, s, l, u, c;
		for (I = 0; W > I; I += 1)for (O = 0; j > O; O += 1)e = I * j + O, e < U.length && (t = U[e], r = V(t[a]), o = q(O), i = Z(I), s = [Math.cos(i) * o, Math.sin(i) * o], l = new n.CylinderGeometry(3, 3, r, 20, 4), u = new n.MeshLambertMaterial({color: ct[t.groupe_sigle]}), c = new n.Mesh(l, u), c.position.set(s[0], r / 2, s[1]), c.scale.setY(0), c.userData.depute = t, S.add(c), at.push(c), st.push(c))
	}

	function E() {
		var e, t, r, i, o = 0;
		B.forEach(function (a, s) {
			o = V(a.value), i = $(s), e = new n.CylinderGeometry(6, 6, o, 20, 4), t = new n.MeshLambertMaterial({color: ct[a.party]}), r = new n.Mesh(e, t), r.position.set(0, o / 2, i), r.scale.setY(0), S.add(r), st.push(r)
		})
	}

	function v(e) {
		st.forEach(function (t) {
			t.scale.setY(e)
		})
	}

	function y() {
		requestAnimationFrame(y), p(), x(), T()
	}

	function T() {
		L.update()
	}

	function x() {
		A.render(S, C)
	}

	function R(e) {
		var t, r, i;
		k = {x: e.clientX / window.innerWidth * 2 - 1, y: 2 * -(e.clientY / window.innerHeight) + 1}, t = new n.Vector3(k.x, k.y, 1), P.unprojectVector(t, C), r = new n.Raycaster(C.position, t.sub(C.position).normalize()), i = r.intersectObjects(at), i.length > 0 ? b(i[0].object.userData.depute, i[0].object) : w()
	}

	function b(e, t) {
		_(e), H(t ? t : i.find(at, function (t) {
			return t.userData.depute.id === e.id
		})), ot.val("")
	}

	function _(e) {
		it.attr("src", "http://www.nosdeputes.fr/depute/photo/" + e.slug + "/245"), tt.html(e.nom), nt.html(e.parti_ratt_financier), rt.html(e[a]), et.css({opacity: 1})
	}

	function w() {
		et.css({opacity: 0}), S.remove(N)
	}

	function H(e) {
		S.remove(N);
		var t = 2, r = new n.CylinderGeometry(e.geometry.parameters.radiusTop + t, e.geometry.parameters.radiusBottom + t, e.geometry.parameters.height + t, 20, 4);
		N = new n.Mesh(r, F), N.position.set(e.position.x, e.position.y, e.position.z), S.add(N)
	}

	var M, S, C, A, L, k, P, D, F, N, z, U, V, B, O, I, j, W, G, X, q, Y, K, Z, Q, $, J, et, tt, nt, rt, it, ot, at = new Array, st = new Array, lt = 0, ut = 10, ct = {ECOLO: 9498256, GDR: 16711731, NI: 10066329, RRDP: 16747520, SRC: 16738740, UDI: 11591910, UMP: 4286945}, ht = {ECOLO: 1, GDR: 0, NI: 6, RRDP: 3, SRC: 2, UDI: 4, UMP: 5};
	t.json("api/synthese", l)
}(jQuery, d3, THREE, THREEx, _, window, "commission_presences");